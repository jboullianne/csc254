<html><a name="1"></a>/* picoc expression evaluator - a stack-based expression evaluation system
<br><a name="2"></a> * which handles operator precedence */
<br><a name="3"></a> 
<br><a name="4"></a>#<font color="red">include </font>"interpreter.h"
<br><a name="5"></a>
<br><a name="6"></a>/* whether evaluation is left to right <font color="red">for </font>a given precedence level */
<br><a name="7"></a>#define IS_LEFT_TO_RIGHT(p) ((p) != 2 && (p) != 14)
<br><a name="8"></a>#define BRACKET_PRECEDENCE 20
<br><a name="9"></a>
<br><a name="10"></a>/* If the destination is not float, we can't assign a floating value to it, we need to convert it to integer instead */
<br><a name="11"></a>#define ASSIGN_FP_OR_INT(value) \
<br><a name="12"></a>        <font color="red">if </font>(IS_FP(BottomValue)) { ResultFP = <a style="color:green" href="expression.html#272">ExpressionAssignFP</a>(Parser, BottomValue, value); } \
<br><a name="13"></a>        else { ResultInt = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(Parser, BottomValue, (long)(value), FALSE); ResultIsInt = TRUE; } \
<br><a name="14"></a>
<br><a name="15"></a>#define DEEP_PRECEDENCE (BRACKET_PRECEDENCE*1000)
<br><a name="16"></a>
<br><a name="17"></a>#ifdef DEBUG_EXPRESSIONS
<br><a name="18"></a>#define <a style="color:green" href="expression.html#20">debugf</a> printf
<br><a name="19"></a>#else
<br><a name="20"></a>void debugf(<font color="blue">char </font>*Format, ...)
<br><a name="21"></a>{
<br><a name="22"></a>}
<br><a name="23"></a>#endif
<br><a name="24"></a>
<br><a name="25"></a>/* local prototypes */
<br><a name="26"></a>enum OperatorOrder
<br><a name="27"></a>{
<br><a name="28"></a>    OrderNone,
<br><a name="29"></a>    OrderPrefix,
<br><a name="30"></a>    OrderInfix,
<br><a name="31"></a>    OrderPostfix
<br><a name="32"></a>};
<br><a name="33"></a>
<br><a name="34"></a>/* a stack of expressions we use in evaluation */
<br><a name="35"></a><font color="blue">struct </font>ExpressionStack
<br><a name="36"></a>{
<br><a name="37"></a>    <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> *Next;       /* the next lower item on the stack */
<br><a name="38"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217"><a href="expression.html#1571">Val</a>ue</a> *<a href="expression.html#1571">Val</a>;                  /* the value <font color="red">for </font>this stack node */
<br><a name="39"></a>    enum LexToken Op;                   /* the operator */
<br><a name="40"></a>    <font color="blue">short </font><font color="blue">unsigned </font><font color="blue">int </font><a href="expression.html#1084">Precedence</a>;      /* the operator precedence of this node */
<br><a name="41"></a>    <font color="blue">unsigned </font><font color="blue">char </font>Order;                /* the evaluation order of this operator */
<br><a name="42"></a>};
<br><a name="43"></a>
<br><a name="44"></a>/* operator precedence definitions */
<br><a name="45"></a><font color="blue">struct </font>OpPrecedence
<br><a name="46"></a>{
<br><a name="47"></a>    <font color="blue">unsigned </font><font color="blue">int </font>PrefixPrecedence:4;
<br><a name="48"></a>    <font color="blue">unsigned </font><font color="blue">int </font>PostfixPrecedence:4;
<br><a name="49"></a>    <font color="blue">unsigned </font><font color="blue">int </font>InfixPrecedence:4;
<br><a name="50"></a>    <font color="blue">char </font>*Name;
<br><a name="51"></a>};
<br><a name="52"></a>
<br><a name="53"></a>/* NOTE: the order of this array must correspond exactly to the order of these tokens in enum LexToken */
<br><a name="54"></a>static <font color="blue">struct </font><a href="expression.html#45">OpPrecedence</a> OperatorPrecedence<font color="red">[</font><font color="red">]</font> =
<br><a name="55"></a>{
<br><a name="56"></a>    /* TokenNone, */ { 0, 0, 0, "none" },
<br><a name="57"></a>    /* TokenComma, */ { 0, 0, 0, "," },
<br><a name="58"></a>    /* TokenAssign, */ { 0, 0, 2, "=" }, /* TokenAddAssign, */ { 0, 0, 2, "+=" }, /* TokenSubtractAssign, */ { 0, 0, 2, "-=" }, 
<br><a name="59"></a>    /* TokenMultiplyAssign, */ { 0, 0, 2, "*=" }, /* TokenDivideAssign, */ { 0, 0, 2, "/=" }, /* TokenModulusAssign, */ { 0, 0, 2, "%=" },
<br><a name="60"></a>    /* TokenShiftLeftAssign, */ { 0, 0, 2, "&lt;&lt;=" }, /* TokenShiftRightAssign, */ { 0, 0, 2, "&gt;&gt;=" }, /* TokenArithmeticAndAssign, */ { 0, 0, 2, "&=" }, 
<br><a name="61"></a>    /* TokenArithmeticOrAssign, */ { 0, 0, 2, "|=" }, /* TokenArithmeticExorAssign, */ { 0, 0, 2, "^=" },
<br><a name="62"></a>    /* TokenQuestionMark, */ { 0, 0, 3, "?" }, /* TokenColon, */ { 0, 0, 3, ":" },
<br><a name="63"></a>    /* TokenLogicalOr, */ { 0, 0, 4, "||" },
<br><a name="64"></a>    /* TokenLogicalAnd, */ { 0, 0, 5, "&&" },
<br><a name="65"></a>    /* TokenArithmeticOr, */ { 0, 0, 6, "|" },
<br><a name="66"></a>    /* TokenArithmeticExor, */ { 0, 0, 7, "^" },
<br><a name="67"></a>    /* TokenAmpersand, */ { 14, 0, 8, "&" },
<br><a name="68"></a>    /* TokenEqual, */  { 0, 0, 9, "==" }, /* TokenNotEqual, */ { 0, 0, 9, "!=" },
<br><a name="69"></a>    /* TokenLessThan, */ { 0, 0, 10, "&lt;" }, /* TokenGreaterThan, */ { 0, 0, 10, "&gt;" }, /* TokenLessEqual, */ { 0, 0, 10, "&lt;=" }, /* TokenGreaterEqual, */ { 0, 0, 10, "&gt;=" },
<br><a name="70"></a>    /* TokenShiftLeft, */ { 0, 0, 11, "&lt;&lt;" }, /* TokenShiftRight, */ { 0, 0, 11, "&gt;&gt;" },
<br><a name="71"></a>    /* TokenPlus, */ { 14, 0, 12, "+" }, /* TokenMinus, */ { 14, 0, 12, "-" },
<br><a name="72"></a>    /* TokenAsterisk, */ { 14, 0, 13, "*" }, /* TokenSlash, */ { 0, 0, 13, "/" }, /* TokenModulus, */ { 0, 0, 13, "%" },
<br><a name="73"></a>    /* TokenIncrement, */ { 14, 15, 0, "++" }, /* TokenDecrement, */ { 14, 15, 0, "--" }, /* TokenUnaryNot, */ { 14, 0, 0, "!" }, /* TokenUnaryExor, */ { 14, 0, 0, "~" }, /* TokenSizeof, */ { 14, 0, 0, "sizeof" }, /* TokenCast, */ { 14, 0, 0, "cast" },
<br><a name="74"></a>    /* TokenLeftSquareBracket, */ { 0, 0, 15, "<font color="red">[</font>" }, /* TokenRightSquareBracket, */ { 0, 15, 0, "<font color="red">]</font>" }, /* TokenDot, */ { 0, 0, 15, "." }, /* TokenArrow, */ { 0, 0, 15, "->" },
<br><a name="75"></a>    /* TokenOpenBracket, */ { 15, 0, 0, "(" }, /* TokenCloseBracket, */ { 0, 15, 0, ")" }
<br><a name="76"></a>};
<br><a name="77"></a>
<br><a name="78"></a>void <a style="color:green" href="expression.html#1441">ExpressionParseFunctionCall</a>(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *Parser, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#1086">StackTop</a>, const <font color="blue">char </font>*FuncName, <font color="blue">int </font>RunIt);
<br><a name="79"></a>
<br><a name="80"></a>#ifdef DEBUG_EXPRESSIONS
<br><a name="81"></a>/* show the contents of the expression stack */
<br><a name="82"></a>void <a href="expression.html#35">ExpressionStack</a>Show(<a href="interpreter_header.html#61">Picoc</a> *pc, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> *<a href="expression.html#1086">StackTop</a>)
<br><a name="83"></a>{
<br><a name="84"></a>    printf("Expression stack <font color="red">[</font>0x%lx,0x%lx<font color="red">]</font>: ", (long)pc->Heap<a href="expression.html#1086">StackTop</a>, (long)<a href="expression.html#1086">StackTop</a>);
<br><a name="85"></a>    
<br><a name="86"></a>    <font color="red">while </font>(<a href="expression.html#1086">StackTop</a> != NULL)
<br><a name="87"></a>    {
<br><a name="88"></a>        <font color="red">if </font>(<a href="expression.html#1086">StackTop</a>->Order == OrderNone)
<br><a name="89"></a>        { 
<br><a name="90"></a>            /* it's a value */
<br><a name="91"></a>            <font color="red">if </font>(<a href="expression.html#1086">StackTop</a>->Val->IsLValue)
<br><a name="92"></a>                printf("lvalue=");
<br><a name="93"></a>            else
<br><a name="94"></a>                printf("value=");
<br><a name="95"></a>                
<br><a name="96"></a>            switch (<a href="expression.html#1086">StackTop</a>->Val->Typ->Base)
<br><a name="97"></a>            {
<br><a name="98"></a>                case TypeVoid:      printf("void"); break;
<br><a name="99"></a>                case TypeInt:       printf("%d:int", <a href="expression.html#1086">StackTop</a>->Val->Val->Integer); break;
<br><a name="100"></a>                case TypeShort:     printf("%d:short", <a href="expression.html#1086">StackTop</a>->Val->Val->ShortInteger); break;
<br><a name="101"></a>                case TypeChar:      printf("%d:char", <a href="expression.html#1086">StackTop</a>->Val->Val->Character); break;
<br><a name="102"></a>                case TypeLong:      printf("%ld:long", <a href="expression.html#1086">StackTop</a>->Val->Val->LongInteger); break;
<br><a name="103"></a>                case TypeUnsignedShort: printf("%d:<font color="blue">unsigned </font>short", <a href="expression.html#1086">StackTop</a>->Val->Val->UnsignedShortInteger); break;
<br><a name="104"></a>                case TypeUnsignedInt: printf("%d:<font color="blue">unsigned </font>int", <a href="expression.html#1086">StackTop</a>->Val->Val->UnsignedInteger); break;
<br><a name="105"></a>                case TypeUnsignedLong: printf("%ld:<font color="blue">unsigned </font>long", <a href="expression.html#1086">StackTop</a>->Val->Val->UnsignedLongInteger); break;
<br><a name="106"></a>                case TypeFP:        printf("%f:fp", <a href="expression.html#1086">StackTop</a>->Val->Val->FP); break;
<br><a name="107"></a>                case TypeFunction:  printf("%s:function", <a href="expression.html#1086">StackTop</a>->Val->Val->Identifier); break;
<br><a name="108"></a>                case TypeMacro:     printf("%s:macro", <a href="expression.html#1086">StackTop</a>->Val->Val->Identifier); break;
<br><a name="109"></a>                case TypePointer:
<br><a name="110"></a>                    <font color="red">if </font>(<a href="expression.html#1086">StackTop</a>->Val->Val->Pointer == NULL)
<br><a name="111"></a>                        printf("ptr(NULL)");
<br><a name="112"></a>                    else <font color="red">if </font>(<a href="expression.html#1086">StackTop</a>->Val->Typ->FromType->Base == TypeChar)
<br><a name="113"></a>                        printf("\"%s\":string", (<font color="blue">char </font>*)<a href="expression.html#1086">StackTop</a>->Val->Val->Pointer);
<br><a name="114"></a>                    else
<br><a name="115"></a>                        printf("ptr(0x%lx)", (long)<a href="expression.html#1086">StackTop</a>->Val->Val->Pointer); 
<br><a name="116"></a>                    break;
<br><a name="117"></a>                case TypeArray:     printf("array"); break;
<br><a name="118"></a>                case TypeStruct:    printf("%s:struct", <a href="expression.html#1086">StackTop</a>->Val->Val->Identifier); break;
<br><a name="119"></a>                case TypeUnion:     printf("%s:union", <a href="expression.html#1086">StackTop</a>->Val->Val->Identifier); break;
<br><a name="120"></a>                case TypeEnum:      printf("%s:enum", <a href="expression.html#1086">StackTop</a>->Val->Val->Identifier); break;
<br><a name="121"></a>                case Type_Type:     <a style="color:green" href="clibrary.html#54">PrintType</a>(<a href="expression.html#1086">StackTop</a>->Val->Val->Typ, pc->CStdOut); printf(":type"); break;
<br><a name="122"></a>                default:            printf("unknown"); break;
<br><a name="123"></a>            }
<br><a name="124"></a>            printf("<font color="red">[</font>0x%lx,0x%lx<font color="red">]</font>", (long)<a href="expression.html#1086">StackTop</a>, (long)<a href="expression.html#1086">StackTop</a>->Val);
<br><a name="125"></a>        }
<br><a name="126"></a>        else
<br><a name="127"></a>        { 
<br><a name="128"></a>            /* it's an operator */
<br><a name="129"></a>            printf("op='%s' %s %d", OperatorPrecedence<font color="red">[</font>(int)<a href="expression.html#1086">StackTop</a>->Op<font color="red">]</font>.Name, 
<br><a name="130"></a>                (<a href="expression.html#1086">StackTop</a>->Order == OrderPrefix) ? "prefix" : ((<a href="expression.html#1086">StackTop</a>->Order == OrderPostfix) ? "postfix" : "infix"), 
<br><a name="131"></a>                <a href="expression.html#1086">StackTop</a>->Precedence);
<br><a name="132"></a>            printf("<font color="red">[</font>0x%lx<font color="red">]</font>", (long)<a href="expression.html#1086">StackTop</a>);
<br><a name="133"></a>        }
<br><a name="134"></a>        
<br><a name="135"></a>        <a href="expression.html#1086">StackTop</a> = <a href="expression.html#1086">StackTop</a>->Next;
<br><a name="136"></a>        <font color="red">if </font>(<a href="expression.html#1086">StackTop</a> != NULL)
<br><a name="137"></a>            printf(", ");
<br><a name="138"></a>    }
<br><a name="139"></a>    
<br><a name="140"></a>    printf("\n");
<br><a name="141"></a>}
<br><a name="142"></a>#endif
<br><a name="143"></a>
<br><a name="144"></a><font color="blue">int </font>IsTypeToken(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> * Parser, enum LexToken t, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> * Lex<a href="interpreter_header.html#217">Value</a>)
<br><a name="145"></a>{
<br><a name="146"></a>    <font color="red">if </font>(<a href="expression.html#144">t</a> >= TokenIn<a href="expression.html#144">t</a>Type && <a href="expression.html#144">t</a> <= TokenUnsignedType)
<br><a name="147"></a>        <font color="red">return </font>1; /* base type */
<br><a name="148"></a>    
<br><a name="149"></a>    /* typedef'ed type? */
<br><a name="150"></a>    <font color="red">if </font>(<a href="expression.html#144">t</a> == TokenIden<a href="expression.html#144">t</a>ifier) /* see TypeParseFron<a href="expression.html#144">t</a>, case TokenIden<a href="expression.html#144">t</a>ifier and <a style="color:green" href="parse.html#549">ParseTypedef</a> */
<br><a name="151"></a>    {
<br><a name="152"></a>        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> * Var<a href="interpreter_header.html#217">Value</a>;
<br><a name="153"></a>        <font color="red">if </font>(<a style="color:green" href="variable.html#346">VariableDefined</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">LexValue</a>->Val->Pointer))
<br><a name="154"></a>        {
<br><a name="155"></a>            <a style="color:green" href="variable.html#360">VariableGet</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, <a href="expression.html#144">LexValue</a>->Val->Pointer, &VarValue);
<br><a name="156"></a>            <font color="red">if </font>(<a href="expression.html#152">VarValue</a>->Typ == &Parser->pc->TypeType)
<br><a name="157"></a>                <font color="red">return </font>1;
<br><a name="158"></a>        }
<br><a name="159"></a>    }
<br><a name="160"></a>    
<br><a name="161"></a>    <font color="red">return </font>0;
<br><a name="162"></a>}
<br><a name="163"></a>
<br><a name="164"></a><font color="blue">long </font>ExpressionCoerceInteger(<font color="blue">struct </font><a href="interpreter_header.html#217"><a href="expression.html#1571">Val</a>ue</a> *<a href="expression.html#1571">Val</a>)
<br><a name="165"></a>{
<br><a name="166"></a>    switch (<a href="expression.html#164">Val</a>->Typ->Base)
<br><a name="167"></a>    {
<br><a name="168"></a>        case TypeInt:             <font color="red">return </font>(long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->Integer;
<br><a name="169"></a>        case TypeChar:            <font color="red">return </font>(long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->Character;
<br><a name="170"></a>        case TypeShort:           <font color="red">return </font>(long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->ShortInteger;
<br><a name="171"></a>        case TypeLong:            <font color="red">return </font>(long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->LongInteger;
<br><a name="172"></a>        case TypeUnsignedInt:     <font color="red">return </font>(long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedInteger;
<br><a name="173"></a>        case TypeUnsignedShort:   <font color="red">return </font>(long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedShortInteger;
<br><a name="174"></a>        case TypeUnsignedLong:    <font color="red">return </font>(long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedLongInteger;
<br><a name="175"></a>        case TypeUnsignedChar:    <font color="red">return </font>(long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedCharacter;
<br><a name="176"></a>        case TypePointer:         <font color="red">return </font>(long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->Pointer;
<br><a name="177"></a>#ifndef NO_FP
<br><a name="178"></a>        case TypeFP:              <font color="red">return </font>(long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->FP;
<br><a name="179"></a>#endif
<br><a name="180"></a>        default:                  <font color="red">return </font>0;
<br><a name="181"></a>    }
<br><a name="182"></a>}
<br><a name="183"></a>
<br><a name="184"></a><font color="blue">unsigned </font><font color="blue">long </font>ExpressionCoerceUnsignedInteger(<font color="blue">struct </font><a href="interpreter_header.html#217"><a href="expression.html#164">Val</a>ue</a> *<a href="expression.html#164">Val</a>)
<br><a name="185"></a>{
<br><a name="186"></a>    switch (<a href="expression.html#164">Val</a>->Typ->Base)
<br><a name="187"></a>    {
<br><a name="188"></a>        case TypeInt:             <font color="red">return </font>(<font color="blue">unsigned </font>long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->Integer;
<br><a name="189"></a>        case TypeChar:            <font color="red">return </font>(<font color="blue">unsigned </font>long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->Character;
<br><a name="190"></a>        case TypeShort:           <font color="red">return </font>(<font color="blue">unsigned </font>long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->ShortInteger;
<br><a name="191"></a>        case TypeLong:            <font color="red">return </font>(<font color="blue">unsigned </font>long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->LongInteger;
<br><a name="192"></a>        case TypeUnsignedInt:     <font color="red">return </font>(<font color="blue">unsigned </font>long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedInteger;
<br><a name="193"></a>        case TypeUnsignedShort:   <font color="red">return </font>(<font color="blue">unsigned </font>long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedShortInteger;
<br><a name="194"></a>        case TypeUnsignedLong:    <font color="red">return </font>(<font color="blue">unsigned </font>long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedLongInteger;
<br><a name="195"></a>        case TypeUnsignedChar:    <font color="red">return </font>(<font color="blue">unsigned </font>long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedCharacter;
<br><a name="196"></a>        case TypePointer:         <font color="red">return </font>(<font color="blue">unsigned </font>long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->Pointer;
<br><a name="197"></a>#ifndef NO_FP
<br><a name="198"></a>        case TypeFP:              <font color="red">return </font>(<font color="blue">unsigned </font>long)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->FP;
<br><a name="199"></a>#endif
<br><a name="200"></a>        default:                  <font color="red">return </font>0;
<br><a name="201"></a>    }
<br><a name="202"></a>}
<br><a name="203"></a>
<br><a name="204"></a>#ifndef NO_FP
<br><a name="205"></a><font color="blue">double </font>ExpressionCoerceFP(<font color="blue">struct </font><a href="interpreter_header.html#217"><a href="expression.html#164">Val</a>ue</a> *<a href="expression.html#164">Val</a>)
<br><a name="206"></a>{
<br><a name="207"></a>#ifndef BROKEN_FLOAT_CASTS
<br><a name="208"></a>    <font color="blue">int </font>IntVal;
<br><a name="209"></a>    <font color="blue">unsigned </font>UnsignedVal;
<br><a name="210"></a>    
<br><a name="211"></a>    switch (<a href="expression.html#164">Val</a>->Typ->Base)
<br><a name="212"></a>    {
<br><a name="213"></a>        case TypeInt:             <a href="expression.html#208">Int<a href="expression.html#164">Val</a></a> = <a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->Integer; <font color="red">return </font>(double)<a href="expression.html#208">Int<a href="expression.html#164">Val</a></a>;
<br><a name="214"></a>        case TypeChar:            <a href="expression.html#208">Int<a href="expression.html#164">Val</a></a> = <a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->Character; <font color="red">return </font>(double)<a href="expression.html#208">Int<a href="expression.html#164">Val</a></a>;
<br><a name="215"></a>        case TypeShort:           <a href="expression.html#208">Int<a href="expression.html#164">Val</a></a> = <a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->ShortInteger; <font color="red">return </font>(double)<a href="expression.html#208">Int<a href="expression.html#164">Val</a></a>;
<br><a name="216"></a>        case TypeLong:            <a href="expression.html#208">Int<a href="expression.html#164">Val</a></a> = <a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->LongInteger; <font color="red">return </font>(double)<a href="expression.html#208">Int<a href="expression.html#164">Val</a></a>;
<br><a name="217"></a>        case TypeUnsignedInt:     <a href="expression.html#209">Unsigned<a href="expression.html#164">Val</a></a> = <a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedInteger; <font color="red">return </font>(double)<a href="expression.html#209">Unsigned<a href="expression.html#164">Val</a></a>;
<br><a name="218"></a>        case TypeUnsignedShort:   <a href="expression.html#209">Unsigned<a href="expression.html#164">Val</a></a> = <a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedShortInteger; <font color="red">return </font>(double)<a href="expression.html#209">Unsigned<a href="expression.html#164">Val</a></a>;
<br><a name="219"></a>        case TypeUnsignedLong:    <a href="expression.html#209">Unsigned<a href="expression.html#164">Val</a></a> = <a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedLongInteger; <font color="red">return </font>(double)<a href="expression.html#209">Unsigned<a href="expression.html#164">Val</a></a>;
<br><a name="220"></a>        case TypeUnsignedChar:    <a href="expression.html#209">Unsigned<a href="expression.html#164">Val</a></a> = <a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedCharacter; <font color="red">return </font>(double)<a href="expression.html#209">Unsigned<a href="expression.html#164">Val</a></a>;
<br><a name="221"></a>        case TypeFP:              <font color="red">return </font><a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->FP;
<br><a name="222"></a>        default:                  <font color="red">return </font>0.0;
<br><a name="223"></a>    }
<br><a name="224"></a>#else
<br><a name="225"></a>    switch (<a href="expression.html#164">Val</a>->Typ->Base)
<br><a name="226"></a>    {
<br><a name="227"></a>        case TypeInt:             <font color="red">return </font>(double)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->Integer;
<br><a name="228"></a>        case TypeChar:            <font color="red">return </font>(double)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->Character;
<br><a name="229"></a>        case TypeShort:           <font color="red">return </font>(double)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->ShortInteger;
<br><a name="230"></a>        case TypeLong:            <font color="red">return </font>(double)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->LongInteger;
<br><a name="231"></a>        case TypeUnsignedInt:     <font color="red">return </font>(double)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedInteger;
<br><a name="232"></a>        case TypeUnsignedShort:   <font color="red">return </font>(double)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedShortInteger;
<br><a name="233"></a>        case TypeUnsignedLong:    <font color="red">return </font>(double)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedLongInteger;
<br><a name="234"></a>        case TypeUnsignedChar:    <font color="red">return </font>(double)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->UnsignedCharacter;
<br><a name="235"></a>        case TypeFP:              <font color="red">return </font>(double)<a href="expression.html#164">Val</a>-><a href="expression.html#164">Val</a>->FP;
<br><a name="236"></a>        default:                  <font color="red">return </font>0.0;
<br><a name="237"></a>    }
<br><a name="238"></a>#endif
<br><a name="239"></a>}
<br><a name="240"></a>#endif
<br><a name="241"></a>
<br><a name="242"></a>/* assign an integer value */
<br><a name="243"></a><font color="blue">long </font>ExpressionAssignInt(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Dest<a href="interpreter_header.html#217">Value</a>, <font color="blue">long </font>FromInt, <font color="blue">int </font>After)
<br><a name="244"></a>{
<br><a name="245"></a>    <font color="blue">long </font><a href="expression.html#519">Result</a>;
<br><a name="246"></a>    
<br><a name="247"></a>    <font color="red">if </font>(!DestValue->IsLValue) 
<br><a name="248"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "can't assign to this"); 
<br><a name="249"></a>    
<br><a name="250"></a>    <font color="red">if </font>(<a href="expression.html#243">After</a>)
<br><a name="251"></a>        <a href="expression.html#245">Result</a> = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#243">DestValue</a>);
<br><a name="252"></a>    else
<br><a name="253"></a>        <a href="expression.html#245">Result</a> = <a href="expression.html#243">FromInt</a>;
<br><a name="254"></a>
<br><a name="255"></a>    switch (<a href="expression.html#243">DestValue</a>->Typ->Base)
<br><a name="256"></a>    {
<br><a name="257"></a>        case TypeInt:           <a href="expression.html#243">DestValue</a>->Val->Integer = <a href="expression.html#243">FromInt</a>; break;
<br><a name="258"></a>        case TypeShort:         <a href="expression.html#243">DestValue</a>->Val->ShortInteger = (short)<a href="expression.html#243">FromInt</a>; break;
<br><a name="259"></a>        case TypeChar:          <a href="expression.html#243">DestValue</a>->Val->Character = (char)<a href="expression.html#243">FromInt</a>; break;
<br><a name="260"></a>        case TypeLong:          <a href="expression.html#243">DestValue</a>->Val->LongInteger = (long)<a href="expression.html#243">FromInt</a>; break;
<br><a name="261"></a>        case TypeUnsignedInt:   <a href="expression.html#243">DestValue</a>->Val->UnsignedInteger = (<font color="blue">unsigned </font>int)<a href="expression.html#243">FromInt</a>; break;
<br><a name="262"></a>        case TypeUnsignedShort: <a href="expression.html#243">DestValue</a>->Val->UnsignedShortInteger = (<font color="blue">unsigned </font>short)<a href="expression.html#243">FromInt</a>; break;
<br><a name="263"></a>        case TypeUnsignedLong:  <a href="expression.html#243">DestValue</a>->Val->UnsignedLongInteger = (<font color="blue">unsigned </font>long)<a href="expression.html#243">FromInt</a>; break;
<br><a name="264"></a>        case TypeUnsignedChar:  <a href="expression.html#243">DestValue</a>->Val->UnsignedCharacter = (<font color="blue">unsigned </font>char)<a href="expression.html#243">FromInt</a>; break;
<br><a name="265"></a>        default: break;
<br><a name="266"></a>    }
<br><a name="267"></a>    <font color="red">return </font><a href="expression.html#245">Result</a>;
<br><a name="268"></a>}
<br><a name="269"></a>
<br><a name="270"></a>#ifndef NO_FP
<br><a name="271"></a>/* assign a floating po<font color="blue">int </font>value */
<br><a name="272"></a><font color="blue">double </font>ExpressionAssignFP(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Dest<a href="interpreter_header.html#217">Value</a>, <font color="blue">double </font>FromFP)
<br><a name="273"></a>{
<br><a name="274"></a>    <font color="red">if </font>(!DestValue->IsLValue) 
<br><a name="275"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "can't assign to this"); 
<br><a name="276"></a>    
<br><a name="277"></a>    <a href="expression.html#243">DestValue</a>->Val->FP = <a href="expression.html#272">FromFP</a>;
<br><a name="278"></a>    <font color="red">return </font><a href="expression.html#272">FromFP</a>;
<br><a name="279"></a>}
<br><a name="280"></a>#endif
<br><a name="281"></a>
<br><a name="282"></a>/* push a node on to the expression stack */
<br><a name="283"></a>void <a href="expression.html#35">ExpressionStack</a>Push<a href="interpreter_header.html#217">Value</a>Node(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#1086">StackTop</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>Loc)
<br><a name="284"></a>{
<br><a name="285"></a>    <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> *<a href="expression.html#1021">StackNode</a> = <a style="color:green" href="variable.html#68">VariableAlloc</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>), FALSE);
<br><a name="286"></a>    <a href="expression.html#285">StackNode</a>->Next = *<a href="expression.html#283">StackTop</a>;
<br><a name="287"></a>    <a href="expression.html#285">StackNode</a>->Val = <a href="expression.html#283">ValueLoc</a>;
<br><a name="288"></a>    *<a href="expression.html#283">StackTop</a> = <a href="expression.html#285">StackNode</a>;
<br><a name="289"></a>#ifdef FANCY_ERROR_MESSAGES
<br><a name="290"></a>    <a href="expression.html#285">StackNode</a>->Line = <a href="expression.html#144">Parser</a>->Line;
<br><a name="291"></a>    <a href="expression.html#285">StackNode</a>->CharacterPos = <a href="expression.html#144">Parser</a>->CharacterPos;
<br><a name="292"></a>#endif
<br><a name="293"></a>#ifdef DEBUG_EXPRESSIONS
<br><a name="294"></a>    ExpressionStackShow(<a href="expression.html#144">Parser</a>->pc, *<a href="expression.html#283">StackTop</a>);
<br><a name="295"></a>#endif
<br><a name="296"></a>}
<br><a name="297"></a>
<br><a name="298"></a>/* push a blank value on to the expression stack by type */
<br><a name="299"></a><font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="expression.html#35">ExpressionStack</a>Push<a href="interpreter_header.html#217">Value</a>ByType(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>Type *PushType)
<br><a name="300"></a>{
<br><a name="301"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>Loc = VariableAlloc<a href="interpreter_header.html#217">Value</a>FromType(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, <a href="expression.html#299">PushType</a>, FALSE, NULL, FALSE);
<br><a name="302"></a>    <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#283">ValueLoc</a>);
<br><a name="303"></a>    
<br><a name="304"></a>    <font color="red">return </font><a href="expression.html#283">ValueLoc</a>;
<br><a name="305"></a>}
<br><a name="306"></a>
<br><a name="307"></a>/* push a value on to the expression stack */
<br><a name="308"></a>void <a href="expression.html#35">ExpressionStack</a>Push<a href="interpreter_header.html#217">Value</a>(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Push<a href="interpreter_header.html#217">Value</a>)
<br><a name="309"></a>{
<br><a name="310"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>Loc = VariableAlloc<a href="interpreter_header.html#217">Value</a>AndCopy(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, Push<a href="interpreter_header.html#217">Value</a>, FALSE);
<br><a name="311"></a>    <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#283">ValueLoc</a>);
<br><a name="312"></a>}
<br><a name="313"></a>
<br><a name="314"></a>void <a href="expression.html#35">ExpressionStack</a>PushL<a href="interpreter_header.html#217">Value</a>(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Push<a href="interpreter_header.html#217">Value</a>, <font color="blue">int </font><a href="expression.html#325">Offset</a>)
<br><a name="315"></a>{
<br><a name="316"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>Loc = VariableAlloc<a href="interpreter_header.html#217">Value</a>Shared(<a href="expression.html#144">Parser</a>, Push<a href="interpreter_header.html#217">Value</a>);
<br><a name="317"></a>    <a href="expression.html#283">ValueLoc</a>->Val = (void *)((<font color="blue">char </font>*)<a href="expression.html#283">ValueLoc</a>->Val + <a href="expression.html#314">Offset</a>);
<br><a name="318"></a>    <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#283">ValueLoc</a>);
<br><a name="319"></a>}
<br><a name="320"></a>
<br><a name="321"></a>void <a href="expression.html#35">ExpressionStack</a>PushDereference(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Dereference<a href="interpreter_header.html#217">Value</a>)
<br><a name="322"></a>{
<br><a name="323"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *DerefVal;
<br><a name="324"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>Loc;
<br><a name="325"></a>    <font color="blue">int </font><a href="expression.html#314">Offset</a>;
<br><a name="326"></a>    <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *DerefType;
<br><a name="327"></a>    <font color="blue">int </font>DerefIsLValue;
<br><a name="328"></a>    void *<a href="expression.html#1052">DerefDataLoc</a> = <a style="color:green" href="variable.html#458">VariableDereferencePointer</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#321">DereferenceValue</a>, &DerefVal, &Offset, &DerefType, &DerefIsLValue);
<br><a name="329"></a>    <font color="red">if </font>(<a href="expression.html#328">DerefDataLoc</a> == NULL)
<br><a name="330"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "NULL pointer dereference");
<br><a name="331"></a>
<br><a name="332"></a>    <a href="expression.html#283">ValueLoc</a> = <a style="color:green" href="variable.html#135">VariableAllocValueFromExistingData</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#326">DerefType</a>, (union <a href="interpreter_header.html#196">AnyValue</a> *)<a href="expression.html#328">DerefDataLoc</a>, <a href="expression.html#327">DerefIsLValue</a>, <a href="expression.html#323">DerefVal</a>);
<br><a name="333"></a>    <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#283">ValueLoc</a>);
<br><a name="334"></a>}
<br><a name="335"></a>
<br><a name="336"></a>void ExpressionPushInt(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, <font color="blue">long </font>IntValue)
<br><a name="337"></a>{
<br><a name="338"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>Loc = VariableAlloc<a href="interpreter_header.html#217">Value</a>FromType(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, &<a href="expression.html#144">Parser</a>->pc->IntType, FALSE, NULL, FALSE);
<br><a name="339"></a>    <a href="expression.html#283">ValueLoc</a>->Val->Integer = <a href="expression.html#336">IntValue</a>;
<br><a name="340"></a>    <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#283">ValueLoc</a>);
<br><a name="341"></a>}
<br><a name="342"></a>
<br><a name="343"></a>#ifndef NO_FP
<br><a name="344"></a>void ExpressionPushFP(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, <font color="blue">double </font>FPValue)
<br><a name="345"></a>{
<br><a name="346"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>Loc = VariableAlloc<a href="interpreter_header.html#217">Value</a>FromType(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, &<a href="expression.html#144">Parser</a>->pc->FPType, FALSE, NULL, FALSE);
<br><a name="347"></a>    <a href="expression.html#283">ValueLoc</a>->Val->FP = <a href="expression.html#344">FPValue</a>;
<br><a name="348"></a>    <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#283">ValueLoc</a>);
<br><a name="349"></a>}
<br><a name="350"></a>#endif
<br><a name="351"></a>
<br><a name="352"></a>/* assign to a pointer */
<br><a name="353"></a>void ExpressionAssignToPointer(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *To<a href="interpreter_header.html#217">Value</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *From<a href="interpreter_header.html#217">Value</a>, const <font color="blue">char </font>*FuncName, <font color="blue">int </font>ParamNo, <font color="blue">int </font>AllowPointerCoercion)
<br><a name="354"></a>{
<br><a name="355"></a>    <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *PointedToType = <a href="expression.html#353">ToValue</a>->Typ->FromType;
<br><a name="356"></a>    
<br><a name="357"></a>    <font color="red">if </font>(<a href="expression.html#353">FromValue</a>->Typ == <a href="expression.html#353">ToValue</a>->Typ || <a href="expression.html#353">FromValue</a>->Typ == <a href="expression.html#144">Parser</a>->pc->VoidPtrType || (<a href="expression.html#353">ToValue</a>->Typ == <a href="expression.html#144">Parser</a>->pc->VoidPtrType && <a href="expression.html#353">FromValue</a>->Typ->Base == TypePointer))
<br><a name="358"></a>        <a href="expression.html#353">ToValue</a>->Val->Pointer = <a href="expression.html#353">FromValue</a>->Val->Pointer;      /* plain old pointer assignment */
<br><a name="359"></a>        
<br><a name="360"></a>    else <font color="red">if </font>(<a href="expression.html#353">FromValue</a>->Typ->Base == TypeArray && (<a href="expression.html#355">PointedToType</a> == <a href="expression.html#353">FromValue</a>->Typ->FromType || <a href="expression.html#353">ToValue</a>->Typ == <a href="expression.html#144">Parser</a>->pc->VoidPtrType))
<br><a name="361"></a>    {
<br><a name="362"></a>        /* the form is: blah *x = array of blah */
<br><a name="363"></a>        <a href="expression.html#353">ToValue</a>->Val->Pointer = (void *)&FromValue->Val->ArrayMem<font color="red">[</font>0<font color="red">]</font>;
<br><a name="364"></a>    }
<br><a name="365"></a>    else <font color="red">if </font>(<a href="expression.html#353">FromValue</a>->Typ->Base == TypePointer && <a href="expression.html#353">FromValue</a>->Typ->FromType->Base == TypeArray && 
<br><a name="366"></a>               (<a href="expression.html#355">PointedToType</a> == <a href="expression.html#353">FromValue</a>->Typ->FromType->FromType || <a href="expression.html#353">ToValue</a>->Typ == <a href="expression.html#144">Parser</a>->pc->VoidPtrType) )
<br><a name="367"></a>    {
<br><a name="368"></a>        /* the form is: blah *x = pointer to array of blah */
<br><a name="369"></a>        <a href="expression.html#353">ToValue</a>->Val->Pointer = <a style="color:green" href="variable.html#458">VariableDereferencePointer</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#353">FromValue</a>, NULL, NULL, NULL, NULL);
<br><a name="370"></a>    }
<br><a name="371"></a>    else <font color="red">if </font>(IS_NUMERIC_COERCIBLE(<a href="expression.html#353">FromValue</a>) && <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#353">FromValue</a>) == 0)
<br><a name="372"></a>    {
<br><a name="373"></a>        /* null pointer assignment */
<br><a name="374"></a>        <a href="expression.html#353">ToValue</a>->Val->Pointer = NULL;
<br><a name="375"></a>    }
<br><a name="376"></a>    else <font color="red">if </font>(<a href="expression.html#353">AllowPointerCoercion</a> && IS_NUMERIC_COERCIBLE(<a href="expression.html#353">FromValue</a>))
<br><a name="377"></a>    {
<br><a name="378"></a>        /* assign integer to native pointer */
<br><a name="379"></a>        <a href="expression.html#353">ToValue</a>->Val->Pointer = (void *)(<font color="blue">unsigned </font>long)<a style="color:green" href="expression.html#184">ExpressionCoerceUnsignedInteger</a>(<a href="expression.html#353">FromValue</a>);
<br><a name="380"></a>    }
<br><a name="381"></a>    else <font color="red">if </font>(<a href="expression.html#353">AllowPointerCoercion</a> && <a href="expression.html#353">FromValue</a>->Typ->Base == TypePointer)
<br><a name="382"></a>    {
<br><a name="383"></a>        /* assign a pointer to a pointer to a different type */
<br><a name="384"></a>        <a href="expression.html#353">ToValue</a>->Val->Pointer = <a href="expression.html#353">FromValue</a>->Val->Pointer;
<br><a name="385"></a>    }
<br><a name="386"></a>    else
<br><a name="387"></a>        <a style="color:green" href="platform.html#159">AssignFail</a>(<a href="expression.html#144">Parser</a>, "%t from %t", <a href="expression.html#353">ToValue</a>->Typ, <a href="expression.html#353">FromValue</a>->Typ, 0, 0, <a href="expression.html#353">FuncName</a>, <a href="expression.html#353">ParamNo</a>); 
<br><a name="388"></a>}
<br><a name="389"></a>
<br><a name="390"></a>/* assign any kind of value */
<br><a name="391"></a>void ExpressionAssign(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Dest<a href="interpreter_header.html#217">Value</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Source<a href="interpreter_header.html#217">Value</a>, <font color="blue">int </font>Force, const <font color="blue">char </font>*<a href="expression.html#353">FuncName</a>, <font color="blue">int </font><a href="expression.html#353">ParamNo</a>, <font color="blue">int </font><a href="expression.html#353">AllowPointerCoercion</a>)
<br><a name="392"></a>{
<br><a name="393"></a>    <font color="red">if </font>(!DestValue->IsLValue && !Force) 
<br><a name="394"></a>        <a style="color:green" href="platform.html#159">AssignFail</a>(<a href="expression.html#144">Parser</a>, "not an lvalue", NULL, NULL, 0, 0, <a href="expression.html#353">FuncName</a>, <a href="expression.html#353">ParamNo</a>); 
<br><a name="395"></a>
<br><a name="396"></a>    <font color="red">if </font>(IS_NUMERIC_COERCIBLE(<a href="expression.html#243">DestValue</a>) && !IS_NUMERIC_COERCIBLE_PLUS_POINTERS(<a href="expression.html#391">SourceValue</a>, <a href="expression.html#353">AllowPointerCoercion</a>))
<br><a name="397"></a>        <a style="color:green" href="platform.html#159">AssignFail</a>(<a href="expression.html#144">Parser</a>, "%t from %t", <a href="expression.html#243">DestValue</a>->Typ, <a href="expression.html#391">SourceValue</a>->Typ, 0, 0, <a href="expression.html#353">FuncName</a>, <a href="expression.html#353">ParamNo</a>); 
<br><a name="398"></a>
<br><a name="399"></a>    switch (<a href="expression.html#243">DestValue</a>->Typ->Base)
<br><a name="400"></a>    {
<br><a name="401"></a>        case TypeInt:           <a href="expression.html#243">DestValue</a>->Val->Integer = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#391">SourceValue</a>); break;
<br><a name="402"></a>        case TypeShort:         <a href="expression.html#243">DestValue</a>->Val->ShortInteger = (short)<a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#391">SourceValue</a>); break;
<br><a name="403"></a>        case TypeChar:          <a href="expression.html#243">DestValue</a>->Val->Character = (char)<a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#391">SourceValue</a>); break;
<br><a name="404"></a>        case TypeLong:          <a href="expression.html#243">DestValue</a>->Val->LongInteger = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#391">SourceValue</a>); break;
<br><a name="405"></a>        case TypeUnsignedInt:   <a href="expression.html#243">DestValue</a>->Val->UnsignedInteger = <a style="color:green" href="expression.html#184">ExpressionCoerceUnsignedInteger</a>(<a href="expression.html#391">SourceValue</a>); break;
<br><a name="406"></a>        case TypeUnsignedShort: <a href="expression.html#243">DestValue</a>->Val->UnsignedShortInteger = (<font color="blue">unsigned </font>short)<a style="color:green" href="expression.html#184">ExpressionCoerceUnsignedInteger</a>(<a href="expression.html#391">SourceValue</a>); break;
<br><a name="407"></a>        case TypeUnsignedLong:  <a href="expression.html#243">DestValue</a>->Val->UnsignedLongInteger = <a style="color:green" href="expression.html#184">ExpressionCoerceUnsignedInteger</a>(<a href="expression.html#391">SourceValue</a>); break;
<br><a name="408"></a>        case TypeUnsignedChar:  <a href="expression.html#243">DestValue</a>->Val->UnsignedCharacter = (<font color="blue">unsigned </font>char)<a style="color:green" href="expression.html#184">ExpressionCoerceUnsignedInteger</a>(<a href="expression.html#391">SourceValue</a>); break;
<br><a name="409"></a>
<br><a name="410"></a>#ifndef NO_FP
<br><a name="411"></a>        case TypeFP:
<br><a name="412"></a>            <font color="red">if </font>(!IS_NUMERIC_COERCIBLE_PLUS_POINTERS(<a href="expression.html#391">SourceValue</a>, <a href="expression.html#353">AllowPointerCoercion</a>)) 
<br><a name="413"></a>                <a style="color:green" href="platform.html#159">AssignFail</a>(<a href="expression.html#144">Parser</a>, "%t from %t", <a href="expression.html#243">DestValue</a>->Typ, <a href="expression.html#391">SourceValue</a>->Typ, 0, 0, <a href="expression.html#353">FuncName</a>, <a href="expression.html#353">ParamNo</a>); 
<br><a name="414"></a>            
<br><a name="415"></a>            <a href="expression.html#243">DestValue</a>->Val->FP = <a style="color:green" href="expression.html#205">ExpressionCoerceFP</a>(<a href="expression.html#391">SourceValue</a>);
<br><a name="416"></a>            break;
<br><a name="417"></a>#endif
<br><a name="418"></a>        case TypePointer:
<br><a name="419"></a>            <a style="color:green" href="expression.html#353">ExpressionAssignToPointer</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#243">DestValue</a>, <a href="expression.html#391">SourceValue</a>, <a href="expression.html#353">FuncName</a>, <a href="expression.html#353">ParamNo</a>, <a href="expression.html#353">AllowPointerCoercion</a>);
<br><a name="420"></a>            break;
<br><a name="421"></a>        
<br><a name="422"></a>        case TypeArray:
<br><a name="423"></a>            <font color="red">if </font>(<a href="expression.html#391">SourceValue</a>->Typ->Base == TypeArray && <a href="expression.html#243">DestValue</a>->Typ->FromType == <a href="expression.html#243">DestValue</a>->Typ->FromType && <a href="expression.html#243">DestValue</a>->Typ->ArraySize == 0)
<br><a name="424"></a>            {
<br><a name="425"></a>                /* destination array is unsized - need to resize the destination array to the same size as the source array */
<br><a name="426"></a>                <a href="expression.html#243">DestValue</a>->Typ = <a href="expression.html#391">SourceValue</a>->Typ;
<br><a name="427"></a>                <a style="color:green" href="variable.html#156">VariableRealloc</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#243">DestValue</a>, <a style="color:green" href="type.html#69">TypeSizeValue</a>(<a href="expression.html#243">DestValue</a>, FALSE));
<br><a name="428"></a>                
<br><a name="429"></a>                <font color="red">if </font>(<a href="expression.html#243">DestValue</a>->LValueFrom != NULL)
<br><a name="430"></a>                {
<br><a name="431"></a>                    /* copy the resized value back to the LValue */
<br><a name="432"></a>                    <a href="expression.html#243">DestValue</a>->LValueFrom->Val = <a href="expression.html#243">DestValue</a>->Val;
<br><a name="433"></a>                    <a href="expression.html#243">DestValue</a>->LValueFrom->AnyValOnHeap = <a href="expression.html#243">DestValue</a>->AnyValOnHeap;
<br><a name="434"></a>                }
<br><a name="435"></a>            }
<br><a name="436"></a>
<br><a name="437"></a>            /* <font color="blue">char </font>array = "abcd" */
<br><a name="438"></a>            <font color="red">if </font>(<a href="expression.html#243">DestValue</a>->Typ->FromType->Base == TypeChar && <a href="expression.html#391">SourceValue</a>->Typ->Base == TypePointer && <a href="expression.html#391">SourceValue</a>->Typ->FromType->Base == TypeChar)
<br><a name="439"></a>            {
<br><a name="440"></a>                <font color="red">if </font>(<a href="expression.html#243">DestValue</a>->Typ->ArraySize == 0) /* <font color="blue">char </font>x<font color="red">[</font><font color="red">]</font> = "abcd", x is unsized */
<br><a name="441"></a>                {
<br><a name="442"></a>                    <font color="blue">int </font><a href="expression.html#590">Size</a> = strlen(<a href="expression.html#391">SourceValue</a>->Val->Pointer) + 1;
<br><a name="443"></a>                    #ifdef DEBUG_ARRAY_INITIALIZER
<br><a name="444"></a>                    PRINT_SOURCE_POS;
<br><a name="445"></a>                    fprintf(<a href="stdio_header.html#170">stderr</a>, "str size: %d\n", <a href="expression.html#442">Size</a>);
<br><a name="446"></a>                    #endif
<br><a name="447"></a>                    <a href="expression.html#243">DestValue</a>->Typ = <a style="color:green" href="type.html#32">TypeGetMatching</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, <a href="expression.html#243">DestValue</a>->Typ->FromType, <a href="expression.html#243">DestValue</a>->Typ->Base, <a href="expression.html#442">Size</a>, <a href="expression.html#243">DestValue</a>->Typ->Identifier, TRUE);
<br><a name="448"></a>                    <a style="color:green" href="variable.html#156">VariableRealloc</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#243">DestValue</a>, <a style="color:green" href="type.html#69">TypeSizeValue</a>(<a href="expression.html#243">DestValue</a>, FALSE));
<br><a name="449"></a>                }
<br><a name="450"></a>                /* else, it's <font color="blue">char </font>x<font color="red">[</font>10<font color="red">]</font> = "abcd" */
<br><a name="451"></a>
<br><a name="452"></a>                #ifdef DEBUG_ARRAY_INITIALIZER
<br><a name="453"></a>                PRINT_SOURCE_POS;
<br><a name="454"></a>                fprintf(<a href="stdio_header.html#170">stderr</a>, "char<font color="red">[</font>%d<font color="red">]</font> from char* (len=%d)\n", <a href="expression.html#243">DestValue</a>->Typ->ArraySize, strlen(<a href="expression.html#391">SourceValue</a>->Val->Pointer));
<br><a name="455"></a>                #endif
<br><a name="456"></a>                memcpy((void *)<a href="expression.html#243">DestValue</a>->Val, <a href="expression.html#391">SourceValue</a>->Val->Pointer, <a style="color:green" href="type.html#69">TypeSizeValue</a>(<a href="expression.html#243">DestValue</a>, FALSE));
<br><a name="457"></a>                break;
<br><a name="458"></a>            }
<br><a name="459"></a>
<br><a name="460"></a>            <font color="red">if </font>(<a href="expression.html#243">DestValue</a>->Typ != <a href="expression.html#391">SourceValue</a>->Typ)
<br><a name="461"></a>                <a style="color:green" href="platform.html#159">AssignFail</a>(<a href="expression.html#144">Parser</a>, "%t from %t", <a href="expression.html#243">DestValue</a>->Typ, <a href="expression.html#391">SourceValue</a>->Typ, 0, 0, <a href="expression.html#353">FuncName</a>, <a href="expression.html#353">ParamNo</a>); 
<br><a name="462"></a>            
<br><a name="463"></a>            <font color="red">if </font>(<a href="expression.html#243">DestValue</a>->Typ->ArraySize != <a href="expression.html#391">SourceValue</a>->Typ->ArraySize)
<br><a name="464"></a>                <a style="color:green" href="platform.html#159">AssignFail</a>(<a href="expression.html#144">Parser</a>, "from an array of size %d to one of size %d", NULL, NULL, <a href="expression.html#243">DestValue</a>->Typ->ArraySize, <a href="expression.html#391">SourceValue</a>->Typ->ArraySize, <a href="expression.html#353">FuncName</a>, <a href="expression.html#353">ParamNo</a>);
<br><a name="465"></a>            
<br><a name="466"></a>            memcpy((void *)<a href="expression.html#243">DestValue</a>->Val, (void *)<a href="expression.html#391">SourceValue</a>->Val, <a style="color:green" href="type.html#69">TypeSizeValue</a>(<a href="expression.html#243">DestValue</a>, FALSE));
<br><a name="467"></a>            break;
<br><a name="468"></a>        
<br><a name="469"></a>        case TypeStruct:
<br><a name="470"></a>        case TypeUnion:
<br><a name="471"></a>            <font color="red">if </font>(<a href="expression.html#243">DestValue</a>->Typ != <a href="expression.html#391">SourceValue</a>->Typ)
<br><a name="472"></a>                <a style="color:green" href="platform.html#159">AssignFail</a>(<a href="expression.html#144">Parser</a>, "%t from %t", <a href="expression.html#243">DestValue</a>->Typ, <a href="expression.html#391">SourceValue</a>->Typ, 0, 0, <a href="expression.html#353">FuncName</a>, <a href="expression.html#353">ParamNo</a>); 
<br><a name="473"></a>            
<br><a name="474"></a>            memcpy((void *)<a href="expression.html#243">DestValue</a>->Val, (void *)<a href="expression.html#391">SourceValue</a>->Val, <a style="color:green" href="type.html#69">TypeSizeValue</a>(<a href="expression.html#391">SourceValue</a>, FALSE));
<br><a name="475"></a>            break;
<br><a name="476"></a>        
<br><a name="477"></a>        default:
<br><a name="478"></a>            <a style="color:green" href="platform.html#159">AssignFail</a>(<a href="expression.html#144">Parser</a>, "%t", <a href="expression.html#243">DestValue</a>->Typ, NULL, 0, 0, <a href="expression.html#353">FuncName</a>, <a href="expression.html#353">ParamNo</a>); 
<br><a name="479"></a>            break;
<br><a name="480"></a>    }
<br><a name="481"></a>}
<br><a name="482"></a>
<br><a name="483"></a>/* evaluate the first half of a ternary operator x ? y : z */
<br><a name="484"></a>void ExpressionQuestionMarkOperator(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Bottom<a href="interpreter_header.html#217">Value</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Top<a href="interpreter_header.html#217">Value</a>)
<br><a name="485"></a>{
<br><a name="486"></a>    <font color="red">if </font>(!IS_NUMERIC_COERCIBLE(<a href="expression.html#484">TopValue</a>))
<br><a name="487"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "first argument to '?' should be a number");
<br><a name="488"></a>
<br><a name="489"></a>    <font color="red">if </font>(<a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#484">TopValue</a>))
<br><a name="490"></a>    {
<br><a name="491"></a>        /* the condition's true, <font color="red">return </font>the <a href="expression.html#484">BottomValue</a> */
<br><a name="492"></a>        <a style="color:green" href="expression.html#308">ExpressionStackPushValue</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">BottomValue</a>);
<br><a name="493"></a>    }
<br><a name="494"></a>    else
<br><a name="495"></a>    {
<br><a name="496"></a>        /* the condition's false, <font color="red">return </font>void */
<br><a name="497"></a>        <a style="color:green" href="expression.html#299">ExpressionStackPushValueByType</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, &<a href="expression.html#144">Parser</a>->pc->VoidType);
<br><a name="498"></a>    }
<br><a name="499"></a>}
<br><a name="500"></a>
<br><a name="501"></a>/* evaluate the second half of a ternary operator x ? y : z */
<br><a name="502"></a>void ExpressionColonOperator(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Bottom<a href="interpreter_header.html#217">Value</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Top<a href="interpreter_header.html#217">Value</a>)
<br><a name="503"></a>{
<br><a name="504"></a>    <font color="red">if </font>(<a href="expression.html#484">TopValue</a>->Typ->Base == TypeVoid)
<br><a name="505"></a>    {
<br><a name="506"></a>        /* invoke the "else" part - <font color="red">return </font>the <a href="expression.html#484">BottomValue</a> */
<br><a name="507"></a>        <a style="color:green" href="expression.html#308">ExpressionStackPushValue</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">BottomValue</a>);
<br><a name="508"></a>    }
<br><a name="509"></a>    else
<br><a name="510"></a>    {
<br><a name="511"></a>        /* it was a "then" - <font color="red">return </font>the <a href="expression.html#484">TopValue</a> */
<br><a name="512"></a>        <a style="color:green" href="expression.html#308">ExpressionStackPushValue</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">TopValue</a>);
<br><a name="513"></a>    }
<br><a name="514"></a>}
<br><a name="515"></a>
<br><a name="516"></a>/* evaluate a prefix operator */
<br><a name="517"></a>void ExpressionPrefixOperator(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, enum LexToken Op, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Top<a href="interpreter_header.html#217">Value</a>)
<br><a name="518"></a>{
<br><a name="519"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="expression.html#245">Result</a>;
<br><a name="520"></a>    union <a href="interpreter_header.html#196">AnyValue</a> *ValPtr;
<br><a name="521"></a>
<br><a name="522"></a>    <a style="color:green" href="expression.html#20">debugf</a>("ExpressionPrefixOperator()\n");
<br><a name="523"></a>    switch (<a href="expression.html#517">Op</a>)
<br><a name="524"></a>    {
<br><a name="525"></a>        case TokenAmpersand:
<br><a name="526"></a>            <font color="red">if </font>(!TopValue->IsLValue)
<br><a name="527"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "can't get the address of this");
<br><a name="528"></a>
<br><a name="529"></a>&nbsp&nbsp&nbsp&nbsp    <a href="expression.html#520">ValPtr</a> = <a href="expression.html#484">TopValue</a>->Val;
<br><a name="530"></a>            <a href="expression.html#245">Result</a> = <a style="color:green" href="variable.html#107">VariableAllocValueFromType</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, <a style="color:green" href="type.html#32">TypeGetMatching</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, <a href="expression.html#484">TopValue</a>->Typ, TypePointer, 0, <a href="expression.html#144">Parser</a>->pc->StrEmpty, TRUE), FALSE, NULL, FALSE);
<br><a name="531"></a>            <a href="expression.html#245">Result</a>->Val->Pointer = (void *)<a href="expression.html#520">ValPtr</a>;
<br><a name="532"></a>            <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#245">Result</a>);
<br><a name="533"></a>            break;
<br><a name="534"></a>
<br><a name="535"></a>        case TokenAsterisk:
<br><a name="536"></a>            <a style="color:green" href="expression.html#321">ExpressionStackPushDereference</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">TopValue</a>);
<br><a name="537"></a>            break;
<br><a name="538"></a>        
<br><a name="539"></a>        case TokenSizeof:
<br><a name="540"></a>            /* <font color="red">return </font>the size of the argument */
<br><a name="541"></a>            <font color="red">if </font>(<a href="expression.html#484">TopValue</a>->Typ == &Parser->pc->TypeType)
<br><a name="542"></a>                <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a style="color:green" href="type.html#80">TypeSize</a>(<a href="expression.html#484">TopValue</a>->Val->Typ, <a href="expression.html#484">TopValue</a>->Val->Typ->ArraySize, TRUE));
<br><a name="543"></a>            else
<br><a name="544"></a>                <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a style="color:green" href="type.html#80">TypeSize</a>(<a href="expression.html#484">TopValue</a>->Typ, <a href="expression.html#484">TopValue</a>->Typ->ArraySize, TRUE));
<br><a name="545"></a>            break;
<br><a name="546"></a>        
<br><a name="547"></a>        default:
<br><a name="548"></a>            /* an arithmetic operator */
<br><a name="549"></a>#ifndef NO_FP
<br><a name="550"></a>            <font color="red">if </font>(<a href="expression.html#484">TopValue</a>->Typ == &Parser->pc->FPType)
<br><a name="551"></a>            {
<br><a name="552"></a>                /* floating po<font color="blue">int </font>prefix arithmetic */
<br><a name="553"></a>                <font color="blue">double </font><a href="expression.html#625">ResultFP</a> = 0.0;
<br><a name="554"></a>                
<br><a name="555"></a>                switch (<a href="expression.html#517">Op</a>)
<br><a name="556"></a>                {
<br><a name="557"></a>                    case TokenPlus:         <a href="expression.html#553">ResultFP</a> = <a href="expression.html#484">TopValue</a>->Val->FP; break;
<br><a name="558"></a>                    case TokenMinus:        <a href="expression.html#553">ResultFP</a> = -<a href="expression.html#484">TopValue</a>->Val->FP; break;
<br><a name="559"></a>                    case TokenIncrement:    <a href="expression.html#553">ResultFP</a> = <a style="color:green" href="expression.html#272">ExpressionAssignFP</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">TopValue</a>, <a href="expression.html#484">TopValue</a>->Val->FP+1); break;
<br><a name="560"></a>                    case TokenDecrement:    <a href="expression.html#553">ResultFP</a> = <a style="color:green" href="expression.html#272">ExpressionAssignFP</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">TopValue</a>, <a href="expression.html#484">TopValue</a>->Val->FP-1); break;
<br><a name="561"></a>                    case TokenUnaryNot:     <a href="expression.html#553">ResultFP</a> = !TopValue->Val->FP; break;
<br><a name="562"></a>                    default:                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation"); break;
<br><a name="563"></a>                }
<br><a name="564"></a>                
<br><a name="565"></a>                <a style="color:green" href="expression.html#344">ExpressionPushFP</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#553">ResultFP</a>);
<br><a name="566"></a>            }
<br><a name="567"></a>            else 
<br><a name="568"></a>#endif
<br><a name="569"></a>            <font color="red">if </font>(IS_NUMERIC_COERCIBLE(<a href="expression.html#484">TopValue</a>))
<br><a name="570"></a>            {
<br><a name="571"></a>                /* integer prefix arithmetic */
<br><a name="572"></a>                <font color="blue">long </font><a href="expression.html#640">ResultInt</a> = 0;
<br><a name="573"></a>                <font color="blue">long </font><a href="expression.html#641">TopInt</a> = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#484">TopValue</a>);
<br><a name="574"></a>                switch (<a href="expression.html#517">Op</a>)
<br><a name="575"></a>                {
<br><a name="576"></a>                    case TokenPlus:         <a href="expression.html#572">ResultInt</a> = <a href="expression.html#573">TopInt</a>; break;
<br><a name="577"></a>                    case TokenMinus:        <a href="expression.html#572">ResultInt</a> = -<a href="expression.html#573">TopInt</a>; break;
<br><a name="578"></a>                    case TokenIncrement:    <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">TopValue</a>, <a href="expression.html#573">TopInt</a>+1, FALSE); break;
<br><a name="579"></a>                    case TokenDecrement:    <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">TopValue</a>, <a href="expression.html#573">TopInt</a>-1, FALSE); break;
<br><a name="580"></a>                    case TokenUnaryNot:     <a href="expression.html#572">ResultInt</a> = !TopInt; break;
<br><a name="581"></a>                    case TokenUnaryExor:    <a href="expression.html#572">ResultInt</a> = ~TopInt; break;
<br><a name="582"></a>                    default:                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation"); break;
<br><a name="583"></a>                }
<br><a name="584"></a>
<br><a name="585"></a>                <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#572">ResultInt</a>);
<br><a name="586"></a>            }
<br><a name="587"></a>            else <font color="red">if </font>(<a href="expression.html#484">TopValue</a>->Typ->Base == TypePointer)
<br><a name="588"></a>            {
<br><a name="589"></a>                /* pointer prefix arithmetic */
<br><a name="590"></a>                <font color="blue">int </font><a href="expression.html#442">Size</a> = Type<a href="expression.html#442">Size</a>(<a href="expression.html#484">TopValue</a>->Typ->FromType, 0, TRUE);
<br><a name="591"></a>                <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Stack<a href="interpreter_header.html#217">Value</a>;
<br><a name="592"></a>                void *ResultPtr;
<br><a name="593"></a>
<br><a name="594"></a>                <font color="red">if </font>(<a href="expression.html#484">TopValue</a>->Val->Pointer == NULL)
<br><a name="595"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid use of a NULL pointer");
<br><a name="596"></a>                
<br><a name="597"></a>                <font color="red">if </font>(!TopValue->IsLValue) 
<br><a name="598"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "can't assign to this"); 
<br><a name="599"></a>                    
<br><a name="600"></a>                switch (<a href="expression.html#517">Op</a>)
<br><a name="601"></a>                {
<br><a name="602"></a>                    case TokenIncrement:    <a href="expression.html#484">TopValue</a>->Val->Pointer = (void *)((<font color="blue">char </font>*)<a href="expression.html#484">TopValue</a>->Val->Pointer + <a href="expression.html#442">Size</a>); break;
<br><a name="603"></a>                    case TokenDecrement:    <a href="expression.html#484">TopValue</a>->Val->Pointer = (void *)((<font color="blue">char </font>*)<a href="expression.html#484">TopValue</a>->Val->Pointer - <a href="expression.html#442">Size</a>); break;
<br><a name="604"></a>                    default:                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation"); break;
<br><a name="605"></a>                }
<br><a name="606"></a>
<br><a name="607"></a>                <a href="expression.html#592">ResultPtr</a> = <a href="expression.html#484">TopValue</a>->Val->Pointer;
<br><a name="608"></a>                <a href="expression.html#591">StackValue</a> = <a style="color:green" href="expression.html#299">ExpressionStackPushValueByType</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">TopValue</a>->Typ);
<br><a name="609"></a>                <a href="expression.html#591">StackValue</a>->Val->Pointer = <a href="expression.html#592">ResultPtr</a>;
<br><a name="610"></a>            }
<br><a name="611"></a>            else
<br><a name="612"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation");
<br><a name="613"></a>            break;
<br><a name="614"></a>    }
<br><a name="615"></a>}
<br><a name="616"></a>
<br><a name="617"></a>/* evaluate a postfix operator */
<br><a name="618"></a>void ExpressionPostfix<a href="expression.html#517">Op</a>erator(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, enum LexToken <a href="expression.html#517">Op</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Top<a href="interpreter_header.html#217">Value</a>)
<br><a name="619"></a>{
<br><a name="620"></a>    <a style="color:green" href="expression.html#20">debugf</a>("ExpressionPostfixOperator()\n");
<br><a name="621"></a>#ifndef NO_FP
<br><a name="622"></a>    <font color="red">if </font>(<a href="expression.html#484">TopValue</a>->Typ == &Parser->pc->FPType)
<br><a name="623"></a>    {
<br><a name="624"></a>        /* floating po<font color="blue">int </font>prefix arithmetic */
<br><a name="625"></a>        <font color="blue">double </font><a href="expression.html#553">ResultFP</a> = 0.0;
<br><a name="626"></a>        
<br><a name="627"></a>        switch (<a href="expression.html#517">Op</a>)
<br><a name="628"></a>        {
<br><a name="629"></a>            case TokenIncrement:    <a href="expression.html#553">ResultFP</a> = <a style="color:green" href="expression.html#272">ExpressionAssignFP</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">TopValue</a>, <a href="expression.html#484">TopValue</a>->Val->FP+1); break;
<br><a name="630"></a>            case TokenDecrement:    <a href="expression.html#553">ResultFP</a> = <a style="color:green" href="expression.html#272">ExpressionAssignFP</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">TopValue</a>, <a href="expression.html#484">TopValue</a>->Val->FP-1); break;
<br><a name="631"></a>            default:                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation"); break;
<br><a name="632"></a>        }
<br><a name="633"></a>        
<br><a name="634"></a>        <a style="color:green" href="expression.html#344">ExpressionPushFP</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#553">ResultFP</a>);
<br><a name="635"></a>    }
<br><a name="636"></a>    else 
<br><a name="637"></a>#endif
<br><a name="638"></a>    <font color="red">if </font>(IS_NUMERIC_COERCIBLE(<a href="expression.html#484">TopValue</a>))
<br><a name="639"></a>    {
<br><a name="640"></a>        <font color="blue">long </font><a href="expression.html#572">ResultInt</a> = 0;
<br><a name="641"></a>        <font color="blue">long </font><a href="expression.html#573">TopInt</a> = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#484">TopValue</a>);
<br><a name="642"></a>        switch (<a href="expression.html#517">Op</a>)
<br><a name="643"></a>        {
<br><a name="644"></a>            case TokenIncrement:            <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">TopValue</a>, <a href="expression.html#573">TopInt</a>+1, TRUE); break;
<br><a name="645"></a>            case TokenDecrement:            <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">TopValue</a>, <a href="expression.html#573">TopInt</a>-1, TRUE); break;
<br><a name="646"></a>            case TokenRightSquareBracket:   <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "not supported"); break;  /* XXX */
<br><a name="647"></a>            case TokenCloseBracket:         <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "not supported"); break;  /* XXX */
<br><a name="648"></a>            default:                        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation"); break;
<br><a name="649"></a>        }
<br><a name="650"></a>    
<br><a name="651"></a>        <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#572">ResultInt</a>);
<br><a name="652"></a>    }
<br><a name="653"></a>    else <font color="red">if </font>(<a href="expression.html#484">TopValue</a>->Typ->Base == TypePointer)
<br><a name="654"></a>    {
<br><a name="655"></a>        /* pointer postfix arithmetic */
<br><a name="656"></a>        <font color="blue">int </font><a href="expression.html#442">Size</a> = Type<a href="expression.html#442">Size</a>(<a href="expression.html#484">TopValue</a>->Typ->FromType, 0, TRUE);
<br><a name="657"></a>        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Stack<a href="interpreter_header.html#217">Value</a>;
<br><a name="658"></a>        void *OrigPointer = <a href="expression.html#484">TopValue</a>->Val->Pointer;
<br><a name="659"></a>        
<br><a name="660"></a>        <font color="red">if </font>(<a href="expression.html#484">TopValue</a>->Val->Pointer == NULL)
<br><a name="661"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid use of a NULL pointer");
<br><a name="662"></a>            
<br><a name="663"></a>        <font color="red">if </font>(!TopValue->IsLValue) 
<br><a name="664"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "can't assign to this"); 
<br><a name="665"></a>        
<br><a name="666"></a>        switch (<a href="expression.html#517">Op</a>)
<br><a name="667"></a>        {
<br><a name="668"></a>            case TokenIncrement:    <a href="expression.html#484">TopValue</a>->Val->Pointer = (void *)((<font color="blue">char </font>*)<a href="expression.html#484">TopValue</a>->Val->Pointer + <a href="expression.html#442">Size</a>); break;
<br><a name="669"></a>            case TokenDecrement:    <a href="expression.html#484">TopValue</a>->Val->Pointer = (void *)((<font color="blue">char </font>*)<a href="expression.html#484">TopValue</a>->Val->Pointer - <a href="expression.html#442">Size</a>); break;
<br><a name="670"></a>            default:                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation"); break;
<br><a name="671"></a>        }
<br><a name="672"></a>        
<br><a name="673"></a>        <a href="expression.html#591">StackValue</a> = <a style="color:green" href="expression.html#299">ExpressionStackPushValueByType</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">TopValue</a>->Typ);
<br><a name="674"></a>        <a href="expression.html#591">StackValue</a>->Val->Pointer = <a href="expression.html#658">OrigPointer</a>;
<br><a name="675"></a>    }
<br><a name="676"></a>    else
<br><a name="677"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation");
<br><a name="678"></a>}
<br><a name="679"></a>
<br><a name="680"></a>/* evaluate an infix operator */
<br><a name="681"></a>void ExpressionInfix<a href="expression.html#517">Op</a>erator(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, enum LexToken <a href="expression.html#517">Op</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Bottom<a href="interpreter_header.html#217">Value</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Top<a href="interpreter_header.html#217">Value</a>)
<br><a name="682"></a>{
<br><a name="683"></a>    <font color="blue">long </font><a href="expression.html#572">ResultInt</a> = 0;
<br><a name="684"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Stack<a href="interpreter_header.html#217">Value</a>;
<br><a name="685"></a>    void *Pointer;
<br><a name="686"></a>    
<br><a name="687"></a>    <a style="color:green" href="expression.html#20">debugf</a>("ExpressionInfixOperator()\n");
<br><a name="688"></a>    <font color="red">if </font>(<a href="expression.html#484">BottomValue</a> == NULL || <a href="expression.html#484">TopValue</a> == NULL)
<br><a name="689"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid expression");
<br><a name="690"></a>        
<br><a name="691"></a>    <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenLeftSquareBracket)
<br><a name="692"></a>    { 
<br><a name="693"></a>        /* array index */
<br><a name="694"></a>        <font color="blue">int </font>ArrayIndex;
<br><a name="695"></a>        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="expression.html#245">Result</a> = NULL;
<br><a name="696"></a>        
<br><a name="697"></a>        <font color="red">if </font>(!IS_NUMERIC_COERCIBLE(<a href="expression.html#484">TopValue</a>))
<br><a name="698"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "array index must be an integer");
<br><a name="699"></a>        
<br><a name="700"></a>        <a href="expression.html#694">ArrayIndex</a> = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#484">TopValue</a>);
<br><a name="701"></a>
<br><a name="702"></a>        /* make the array element result */
<br><a name="703"></a>        switch (<a href="expression.html#484">BottomValue</a>->Typ->Base)
<br><a name="704"></a>        {
<br><a name="705"></a>            case TypeArray:   <a href="expression.html#245">Result</a> = <a style="color:green" href="variable.html#135">VariableAllocValueFromExistingData</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>->Typ->FromType, (union <a href="interpreter_header.html#196">AnyValue</a> *)(&<a href="expression.html#484">BottomValue</a>->Val->ArrayMem<font color="red">[</font>0<font color="red">]</font> + <a style="color:green" href="type.html#80">TypeSize</a>(<a href="expression.html#484">BottomValue</a>->Typ, <a href="expression.html#694">ArrayIndex</a>, TRUE)), <a href="expression.html#484">BottomValue</a>->IsLValue, <a href="expression.html#484">BottomValue</a>->LValueFrom); break;
<br><a name="706"></a>            case TypePointer: <a href="expression.html#245">Result</a> = <a style="color:green" href="variable.html#135">VariableAllocValueFromExistingData</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>->Typ->FromType, (union <a href="interpreter_header.html#196">AnyValue</a> *)((<font color="blue">char </font>*)<a href="expression.html#484">BottomValue</a>->Val->Pointer + <a style="color:green" href="type.html#80">TypeSize</a>(<a href="expression.html#484">BottomValue</a>->Typ->FromType, 0, TRUE) * <a href="expression.html#694">ArrayIndex</a>), <a href="expression.html#484">BottomValue</a>->IsLValue, <a href="expression.html#484">BottomValue</a>->LValueFrom); break;
<br><a name="707"></a>            default:          <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "this %t is not an array", <a href="expression.html#484">BottomValue</a>->Typ);
<br><a name="708"></a>        }
<br><a name="709"></a>        
<br><a name="710"></a>        <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#245">Result</a>);
<br><a name="711"></a>    }
<br><a name="712"></a>    else <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenQuestionMark)
<br><a name="713"></a>        <a style="color:green" href="expression.html#484">ExpressionQuestionMarkOperator</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">TopValue</a>, <a href="expression.html#484">BottomValue</a>);
<br><a name="714"></a>    
<br><a name="715"></a>    else <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenColon)
<br><a name="716"></a>        <a style="color:green" href="expression.html#502">ExpressionColonOperator</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">TopValue</a>, <a href="expression.html#484">BottomValue</a>);
<br><a name="717"></a>        
<br><a name="718"></a>#ifndef NO_FP
<br><a name="719"></a>    else <font color="red">if </font>( (<a href="expression.html#484">TopValue</a>->Typ == &Parser->pc->FPType && <a href="expression.html#484">BottomValue</a>->Typ == &Parser->pc->FPType) ||
<br><a name="720"></a>              (<a href="expression.html#484">TopValue</a>->Typ == &Parser->pc->FPType && IS_NUMERIC_COERCIBLE(<a href="expression.html#484">BottomValue</a>)) ||
<br><a name="721"></a>              (IS_NUMERIC_COERCIBLE(<a href="expression.html#484">TopValue</a>) && <a href="expression.html#484">BottomValue</a>->Typ == &Parser->pc->FPType) )
<br><a name="722"></a>    {
<br><a name="723"></a>        /* floating po<font color="blue">int </font>infix arithmetic */
<br><a name="724"></a>        <font color="blue">int </font>ResultIsInt = FALSE;
<br><a name="725"></a>        <font color="blue">double </font><a href="expression.html#553">ResultFP</a> = 0.0;
<br><a name="726"></a>        <font color="blue">double </font>TopFP = (<a href="expression.html#484">TopValue</a>->Typ == &Parser->pc->FPType) ? <a href="expression.html#484">TopValue</a>->Val->FP : (double)<a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#484">TopValue</a>);
<br><a name="727"></a>        <font color="blue">double </font>BottomFP = (<a href="expression.html#484">BottomValue</a>->Typ == &Parser->pc->FPType) ? <a href="expression.html#484">BottomValue</a>->Val->FP : (double)<a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#484">BottomValue</a>);
<br><a name="728"></a>
<br><a name="729"></a>        switch (<a href="expression.html#517">Op</a>)
<br><a name="730"></a>        {
<br><a name="731"></a>            case TokenAssign:               ASSIGN_FP_OR_INT(<a href="expression.html#726">TopFP</a>); break;
<br><a name="732"></a>            case TokenAddAssign:            ASSIGN_FP_OR_INT(<a href="expression.html#727">BottomFP</a> + <a href="expression.html#726">TopFP</a>); break;
<br><a name="733"></a>            case TokenSubtractAssign:       ASSIGN_FP_OR_INT(<a href="expression.html#727">BottomFP</a> - <a href="expression.html#726">TopFP</a>); break;
<br><a name="734"></a>            case TokenMultiplyAssign:       ASSIGN_FP_OR_INT(<a href="expression.html#727">BottomFP</a> * <a href="expression.html#726">TopFP</a>); break;
<br><a name="735"></a>            case TokenDivideAssign:         ASSIGN_FP_OR_INT(<a href="expression.html#727">BottomFP</a> / <a href="expression.html#726">TopFP</a>); break;
<br><a name="736"></a>            case TokenEqual:                <a href="expression.html#572">ResultInt</a> = <a href="expression.html#727">BottomFP</a> == <a href="expression.html#726">TopFP</a>; <a href="expression.html#724">ResultIsInt</a> = TRUE; break;
<br><a name="737"></a>            case TokenNotEqual:             <a href="expression.html#572">ResultInt</a> = <a href="expression.html#727">BottomFP</a> != <a href="expression.html#726">TopFP</a>; <a href="expression.html#724">ResultIsInt</a> = TRUE; break;
<br><a name="738"></a>            case TokenLessThan:             <a href="expression.html#572">ResultInt</a> = <a href="expression.html#727">BottomFP</a> < <a href="expression.html#726">TopFP</a>; <a href="expression.html#724">ResultIsInt</a> = TRUE; break;
<br><a name="739"></a>            case TokenGreaterThan:          <a href="expression.html#572">ResultInt</a> = <a href="expression.html#727">BottomFP</a> > <a href="expression.html#726">TopFP</a>; <a href="expression.html#724">ResultIsInt</a> = TRUE; break;
<br><a name="740"></a>            case TokenLessEqual:            <a href="expression.html#572">ResultInt</a> = <a href="expression.html#727">BottomFP</a> <= <a href="expression.html#726">TopFP</a>; <a href="expression.html#724">ResultIsInt</a> = TRUE; break;
<br><a name="741"></a>            case TokenGreaterEqual:         <a href="expression.html#572">ResultInt</a> = <a href="expression.html#727">BottomFP</a> >= <a href="expression.html#726">TopFP</a>; <a href="expression.html#724">ResultIsInt</a> = TRUE; break;
<br><a name="742"></a>            case TokenPlus:                 <a href="expression.html#553">ResultFP</a> = <a href="expression.html#727">BottomFP</a> + <a href="expression.html#726">TopFP</a>; break;
<br><a name="743"></a>            case TokenMinus:                <a href="expression.html#553">ResultFP</a> = <a href="expression.html#727">BottomFP</a> - <a href="expression.html#726">TopFP</a>; break;
<br><a name="744"></a>            case TokenAsterisk:             <a href="expression.html#553">ResultFP</a> = <a href="expression.html#727">BottomFP</a> * <a href="expression.html#726">TopFP</a>; break;
<br><a name="745"></a>            case TokenSlash:                <a href="expression.html#553">ResultFP</a> = <a href="expression.html#727">BottomFP</a> / <a href="expression.html#726">TopFP</a>; break;
<br><a name="746"></a>            default:                        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation"); break;
<br><a name="747"></a>        }
<br><a name="748"></a>
<br><a name="749"></a>        <font color="red">if </font>(<a href="expression.html#724">ResultIsInt</a>)
<br><a name="750"></a>            <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#572">ResultInt</a>);
<br><a name="751"></a>        else
<br><a name="752"></a>            <a style="color:green" href="expression.html#344">ExpressionPushFP</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#553">ResultFP</a>);
<br><a name="753"></a>    }
<br><a name="754"></a>#endif
<br><a name="755"></a>    else <font color="red">if </font>(IS_NUMERIC_COERCIBLE(<a href="expression.html#484">TopValue</a>) && IS_NUMERIC_COERCIBLE(<a href="expression.html#484">BottomValue</a>))
<br><a name="756"></a>    { 
<br><a name="757"></a>        /* integer operation */
<br><a name="758"></a>        <font color="blue">long </font><a href="expression.html#573">TopInt</a> = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#484">TopValue</a>);
<br><a name="759"></a>        <font color="blue">long </font>BottomInt = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#484">BottomValue</a>);
<br><a name="760"></a>        switch (<a href="expression.html#517">Op</a>)
<br><a name="761"></a>        {
<br><a name="762"></a>            case TokenAssign:               <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="763"></a>            case TokenAddAssign:            <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#759">BottomInt</a> + <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="764"></a>            case TokenSubtractAssign:       <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#759">BottomInt</a> - <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="765"></a>            case TokenMultiplyAssign:       <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#759">BottomInt</a> * <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="766"></a>            case TokenDivideAssign:         <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#759">BottomInt</a> / <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="767"></a>#ifndef NO_MODULUS
<br><a name="768"></a>            case TokenModulusAssign:        <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#759">BottomInt</a> % <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="769"></a>#endif
<br><a name="770"></a>            case TokenShiftLeftAssign:      <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#759">BottomInt</a> << <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="771"></a>            case TokenShiftRightAssign:     <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#759">BottomInt</a> >> <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="772"></a>            case TokenArithmeticAndAssign:  <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#759">BottomInt</a> & <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="773"></a>            case TokenArithmeticOrAssign:   <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#759">BottomInt</a> | <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="774"></a>            case TokenArithmeticExorAssign: <a href="expression.html#572">ResultInt</a> = <a style="color:green" href="expression.html#243">ExpressionAssignInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#759">BottomInt</a> ^ <a href="expression.html#573">TopInt</a>, FALSE); break;
<br><a name="775"></a>            case TokenLogicalOr:            <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> || <a href="expression.html#573">TopInt</a>; break;
<br><a name="776"></a>            case TokenLogicalAnd:           <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> && <a href="expression.html#573">TopInt</a>; break;
<br><a name="777"></a>            case TokenArithmeticOr:         <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> | <a href="expression.html#573">TopInt</a>; break;
<br><a name="778"></a>            case TokenArithmeticExor:       <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> ^ <a href="expression.html#573">TopInt</a>; break;
<br><a name="779"></a>            case TokenAmpersand:            <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> & <a href="expression.html#573">TopInt</a>; break;
<br><a name="780"></a>            case TokenEqual:                <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> == <a href="expression.html#573">TopInt</a>; break;
<br><a name="781"></a>            case TokenNotEqual:             <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> != <a href="expression.html#573">TopInt</a>; break;
<br><a name="782"></a>            case TokenLessThan:             <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> < <a href="expression.html#573">TopInt</a>; break;
<br><a name="783"></a>            case TokenGreaterThan:          <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> > <a href="expression.html#573">TopInt</a>; break;
<br><a name="784"></a>            case TokenLessEqual:            <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> <= <a href="expression.html#573">TopInt</a>; break;
<br><a name="785"></a>            case TokenGreaterEqual:         <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> >= <a href="expression.html#573">TopInt</a>; break;
<br><a name="786"></a>            case TokenShiftLeft:            <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> << <a href="expression.html#573">TopInt</a>; break;
<br><a name="787"></a>            case TokenShiftRight:           <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> >> <a href="expression.html#573">TopInt</a>; break;
<br><a name="788"></a>            case TokenPlus:                 <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> + <a href="expression.html#573">TopInt</a>; break;
<br><a name="789"></a>            case TokenMinus:                <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> - <a href="expression.html#573">TopInt</a>; break;
<br><a name="790"></a>            case TokenAsterisk:             <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> * <a href="expression.html#573">TopInt</a>; break;
<br><a name="791"></a>            case TokenSlash:                <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> / <a href="expression.html#573">TopInt</a>; break;
<br><a name="792"></a>#ifndef NO_MODULUS
<br><a name="793"></a>            case TokenModulus:              <a href="expression.html#572">ResultInt</a> = <a href="expression.html#759">BottomInt</a> % <a href="expression.html#573">TopInt</a>; break;
<br><a name="794"></a>#endif
<br><a name="795"></a>            default:                        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation"); break;
<br><a name="796"></a>        }
<br><a name="797"></a>        
<br><a name="798"></a>        <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#572">ResultInt</a>);
<br><a name="799"></a>    }
<br><a name="800"></a>    else <font color="red">if </font>(<a href="expression.html#484">BottomValue</a>->Typ->Base == TypePointer && IS_NUMERIC_COERCIBLE(<a href="expression.html#484">TopValue</a>))
<br><a name="801"></a>    {
<br><a name="802"></a>        /* pointer/integer infix arithmetic */
<br><a name="803"></a>        <font color="blue">long </font><a href="expression.html#573">TopInt</a> = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#484">TopValue</a>);
<br><a name="804"></a>
<br><a name="805"></a>        <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenEqual || <a href="expression.html#517">Op</a> == TokenNotEqual)
<br><a name="806"></a>        {
<br><a name="807"></a>            /* comparison to a NULL pointer */
<br><a name="808"></a>            <font color="red">if </font>(<a href="expression.html#573">TopInt</a> != 0) 
<br><a name="809"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation");
<br><a name="810"></a>            
<br><a name="811"></a>            <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenEqual)
<br><a name="812"></a>                <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">BottomValue</a>->Val->Pointer == NULL);
<br><a name="813"></a>            else
<br><a name="814"></a>                <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">BottomValue</a>->Val->Pointer != NULL);
<br><a name="815"></a>        }
<br><a name="816"></a>        else <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenPlus || <a href="expression.html#517">Op</a> == TokenMinus)
<br><a name="817"></a>        {
<br><a name="818"></a>            /* pointer arithmetic */
<br><a name="819"></a>            <font color="blue">int </font><a href="expression.html#442">Size</a> = Type<a href="expression.html#442">Size</a>(<a href="expression.html#484">BottomValue</a>->Typ->FromType, 0, TRUE);
<br><a name="820"></a>            
<br><a name="821"></a>            <a href="expression.html#685">Pointer</a> = <a href="expression.html#484">BottomValue</a>->Val-><a href="expression.html#685">Pointer</a>;
<br><a name="822"></a>            <font color="red">if </font>(<a href="expression.html#685">Pointer</a> == NULL)
<br><a name="823"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid use of a NULL pointer");
<br><a name="824"></a>            
<br><a name="825"></a>            <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenPlus)
<br><a name="826"></a>                <a href="expression.html#685">Pointer</a> = (void *)((<font color="blue">char </font>*)<a href="expression.html#685">Pointer</a> + <a href="expression.html#573">TopInt</a> * <a href="expression.html#442">Size</a>);
<br><a name="827"></a>            else
<br><a name="828"></a>                <a href="expression.html#685">Pointer</a> = (void *)((<font color="blue">char </font>*)<a href="expression.html#685">Pointer</a> - <a href="expression.html#573">TopInt</a> * <a href="expression.html#442">Size</a>);
<br><a name="829"></a>            
<br><a name="830"></a>            <a href="expression.html#591">StackValue</a> = <a style="color:green" href="expression.html#299">ExpressionStackPushValueByType</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">BottomValue</a>->Typ);
<br><a name="831"></a>            <a href="expression.html#591">StackValue</a>->Val-><a href="expression.html#685">Pointer</a> = <a href="expression.html#685">Pointer</a>;
<br><a name="832"></a>        }
<br><a name="833"></a>        else <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenAssign && <a href="expression.html#573">TopInt</a> == 0)
<br><a name="834"></a>        {
<br><a name="835"></a>            /* assign a NULL pointer */
<br><a name="836"></a>            <a style="color:green" href="heap.html#83">HeapUnpopStack</a>(<a href="expression.html#144">Parser</a>->pc, sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>));
<br><a name="837"></a>            <a style="color:green" href="expression.html#391">ExpressionAssign</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#484">TopValue</a>, FALSE, NULL, 0, FALSE);
<br><a name="838"></a>            <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">BottomValue</a>);
<br><a name="839"></a>        }
<br><a name="840"></a>        else <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenAddAssign || <a href="expression.html#517">Op</a> == TokenSubtractAssign)
<br><a name="841"></a>        {
<br><a name="842"></a>            /* pointer arithmetic */
<br><a name="843"></a>            <font color="blue">int </font><a href="expression.html#442">Size</a> = Type<a href="expression.html#442">Size</a>(<a href="expression.html#484">BottomValue</a>->Typ->FromType, 0, TRUE);
<br><a name="844"></a>
<br><a name="845"></a>            <a href="expression.html#685">Pointer</a> = <a href="expression.html#484">BottomValue</a>->Val-><a href="expression.html#685">Pointer</a>;
<br><a name="846"></a>            <font color="red">if </font>(<a href="expression.html#685">Pointer</a> == NULL)
<br><a name="847"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid use of a NULL pointer");
<br><a name="848"></a>
<br><a name="849"></a>            <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenAddAssign)
<br><a name="850"></a>                <a href="expression.html#685">Pointer</a> = (void *)((<font color="blue">char </font>*)<a href="expression.html#685">Pointer</a> + <a href="expression.html#573">TopInt</a> * <a href="expression.html#442">Size</a>);
<br><a name="851"></a>            else
<br><a name="852"></a>                <a href="expression.html#685">Pointer</a> = (void *)((<font color="blue">char </font>*)<a href="expression.html#685">Pointer</a> - <a href="expression.html#573">TopInt</a> * <a href="expression.html#442">Size</a>);
<br><a name="853"></a>
<br><a name="854"></a>            <a style="color:green" href="heap.html#83">HeapUnpopStack</a>(<a href="expression.html#144">Parser</a>->pc, sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>));
<br><a name="855"></a>            <a href="expression.html#484">BottomValue</a>->Val-><a href="expression.html#685">Pointer</a> = <a href="expression.html#685">Pointer</a>;
<br><a name="856"></a>            <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">BottomValue</a>);
<br><a name="857"></a>        }
<br><a name="858"></a>        else
<br><a name="859"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation");
<br><a name="860"></a>    }
<br><a name="861"></a>    else <font color="red">if </font>(<a href="expression.html#484">BottomValue</a>->Typ->Base == TypePointer && <a href="expression.html#484">TopValue</a>->Typ->Base == TypePointer && <a href="expression.html#517">Op</a> != TokenAssign)
<br><a name="862"></a>    {
<br><a name="863"></a>        /* pointer/pointer operations */
<br><a name="864"></a>        <font color="blue">char </font>*TopLoc = (<font color="blue">char </font>*)<a href="expression.html#484">TopValue</a>->Val->Pointer;
<br><a name="865"></a>        <font color="blue">char </font>*BottomLoc = (<font color="blue">char </font>*)<a href="expression.html#484">BottomValue</a>->Val->Pointer;
<br><a name="866"></a>        
<br><a name="867"></a>        switch (<a href="expression.html#517">Op</a>)
<br><a name="868"></a>        {
<br><a name="869"></a>            case TokenEqual:                <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#865">BottomLoc</a> == <a href="expression.html#864">TopLoc</a>); break;
<br><a name="870"></a>            case TokenNotEqual:             <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#865">BottomLoc</a> != <a href="expression.html#864">TopLoc</a>); break;
<br><a name="871"></a>            case TokenMinus:                <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#865">BottomLoc</a> - <a href="expression.html#864">TopLoc</a>); break;
<br><a name="872"></a>            default:                        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation"); break;
<br><a name="873"></a>        }
<br><a name="874"></a>    }
<br><a name="875"></a>    else <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenAssign)
<br><a name="876"></a>    {
<br><a name="877"></a>        /* assign a non-numeric type */
<br><a name="878"></a>        <a style="color:green" href="heap.html#83">HeapUnpopStack</a>(<a href="expression.html#144">Parser</a>->pc, sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>));   /* XXX - possible bug <font color="red">if </font>lvalue is a temp value and takes more than sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>) */
<br><a name="879"></a>        <a style="color:green" href="expression.html#391">ExpressionAssign</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#484">TopValue</a>, FALSE, NULL, 0, FALSE);
<br><a name="880"></a>        <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#484">BottomValue</a>);
<br><a name="881"></a>    }
<br><a name="882"></a>    else <font color="red">if </font>(<a href="expression.html#517">Op</a> == TokenCast)
<br><a name="883"></a>    {
<br><a name="884"></a>        /* cast a value to a different type */   /* XXX - possible bug <font color="red">if </font>the destination type takes more than sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>) + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>Type *) */
<br><a name="885"></a>        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>Loc = ExpressionStackPush<a href="interpreter_header.html#217">Value</a>ByType(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, Bottom<a href="interpreter_header.html#217">Value</a>->Val->Typ);
<br><a name="886"></a>        <a style="color:green" href="expression.html#391">ExpressionAssign</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">ValueLoc</a>, <a href="expression.html#484">TopValue</a>, TRUE, NULL, 0, TRUE);
<br><a name="887"></a>    }
<br><a name="888"></a>    else
<br><a name="889"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid operation");
<br><a name="890"></a>}
<br><a name="891"></a>
<br><a name="892"></a>/* take the contents of the expression stack and compute the top until there's nothing greater than the given precedence */
<br><a name="893"></a>void <a href="expression.html#35">ExpressionStack</a>Collapse(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, <font color="blue">int </font><a href="expression.html#1084">Precedence</a>, <font color="blue">int </font>*Ignore<a href="expression.html#1084">Precedence</a>)
<br><a name="894"></a>{
<br><a name="895"></a>    <font color="blue">int </font>Found<a href="expression.html#893">Precedence</a> = <a href="expression.html#893">Precedence</a>;
<br><a name="896"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Top<a href="interpreter_header.html#217">Value</a>;
<br><a name="897"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Bottom<a href="interpreter_header.html#217">Value</a>;
<br><a name="898"></a>    <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> *TopStackNode = *<a href="expression.html#283">StackTop</a>;
<br><a name="899"></a>    <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> *TopOperatorNode;
<br><a name="900"></a>    
<br><a name="901"></a>    <a style="color:green" href="expression.html#20">debugf</a>("ExpressionStackCollapse(%d):\n", <a href="expression.html#893">Precedence</a>);
<br><a name="902"></a>#ifdef DEBUG_EXPRESSIONS
<br><a name="903"></a>    ExpressionStackShow(<a href="expression.html#144">Parser</a>->pc, *<a href="expression.html#283">StackTop</a>);
<br><a name="904"></a>#endif
<br><a name="905"></a>    <font color="red">while </font>(<a href="expression.html#898">TopStackNode</a> != NULL && <a href="expression.html#898">TopStackNode</a>->Next != NULL && <a href="expression.html#895">Found<a href="expression.html#893">Precedence</a></a> >= <a href="expression.html#893">Precedence</a>)
<br><a name="906"></a>    {
<br><a name="907"></a>        /* find the top operator on the stack */
<br><a name="908"></a>        <font color="red">if </font>(<a href="expression.html#898">TopStackNode</a>->Order == OrderNone)
<br><a name="909"></a>            <a href="expression.html#899">TopOperatorNode</a> = <a href="expression.html#898">TopStackNode</a>->Next;
<br><a name="910"></a>        else
<br><a name="911"></a>            <a href="expression.html#899">TopOperatorNode</a> = <a href="expression.html#898">TopStackNode</a>;
<br><a name="912"></a>        
<br><a name="913"></a>        <a href="expression.html#895">FoundPrecedence</a> = <a href="expression.html#899">TopOperatorNode</a>->Precedence;
<br><a name="914"></a>        
<br><a name="915"></a>        /* does it have a high enough precedence? */
<br><a name="916"></a>        <font color="red">if </font>(<a href="expression.html#895">Found<a href="expression.html#893">Precedence</a></a> >= <a href="expression.html#893">Precedence</a> && <a href="expression.html#899">TopOperatorNode</a> != NULL)
<br><a name="917"></a>        {
<br><a name="918"></a>            /* execute this operator */
<br><a name="919"></a>            switch (<a href="expression.html#899">TopOperatorNode</a>->Order)
<br><a name="920"></a>            {
<br><a name="921"></a>                case OrderPrefix:
<br><a name="922"></a>                    /* prefix evaluation */
<br><a name="923"></a>                    <a style="color:green" href="expression.html#20">debugf</a>("prefix evaluation\n");
<br><a name="924"></a>                    <a href="expression.html#484">TopValue</a> = <a href="expression.html#898">TopStackNode</a>->Val;
<br><a name="925"></a>                    
<br><a name="926"></a>                    /* pop the value and then the prefix operator - assume they'll still be there until we're done */
<br><a name="927"></a>                    <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="expression.html#144">Parser</a>->pc, NULL, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>) + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>) + TypeStackSize<a href="interpreter_header.html#217">Value</a>(Top<a href="interpreter_header.html#217">Value</a>));
<br><a name="928"></a>                    <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#899">TopOperatorNode</a>, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>));
<br><a name="929"></a>                    *<a href="expression.html#283">StackTop</a> = <a href="expression.html#899">TopOperatorNode</a>->Next;
<br><a name="930"></a>                    
<br><a name="931"></a>                    /* do the prefix operation */
<br><a name="932"></a>                    <font color="red">if </font>(<a href="expression.html#144">Parser</a>->Mode == RunModeRun /* && <a href="expression.html#895">FoundPrecedence</a> < *<a href="expression.html#893">IgnorePrecedence</a> */)
<br><a name="933"></a>                    {
<br><a name="934"></a>                        /* run the operator */
<br><a name="935"></a>                        <a style="color:green" href="expression.html#517">ExpressionPrefixOperator</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#899">TopOperatorNode</a>->Op, <a href="expression.html#484">TopValue</a>);
<br><a name="936"></a>                    }
<br><a name="937"></a>                    else
<br><a name="938"></a>                    {
<br><a name="939"></a>                        /* we're not running it so just <font color="red">return </font>0 */
<br><a name="940"></a>                        <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, 0);
<br><a name="941"></a>                    }
<br><a name="942"></a>                    break;
<br><a name="943"></a>                
<br><a name="944"></a>                case OrderPostfix:
<br><a name="945"></a>                    /* postfix evaluation */
<br><a name="946"></a>                    <a style="color:green" href="expression.html#20">debugf</a>("postfix evaluation\n");
<br><a name="947"></a>                    <a href="expression.html#484">TopValue</a> = <a href="expression.html#898">TopStackNode</a>->Next->Val;
<br><a name="948"></a>                    
<br><a name="949"></a>                    /* pop the postfix operator and then the value - assume they'll still be there until we're done */
<br><a name="950"></a>                    <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="expression.html#144">Parser</a>->pc, NULL, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>));
<br><a name="951"></a>                    <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#484">Top<a href="interpreter_header.html#217">Value</a></a>, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>) + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>) + TypeStackSize<a href="interpreter_header.html#217">Value</a>(<a href="expression.html#484">Top<a href="interpreter_header.html#217">Value</a></a>));
<br><a name="952"></a>                    *<a href="expression.html#283">StackTop</a> = <a href="expression.html#898">TopStackNode</a>->Next->Next;
<br><a name="953"></a>
<br><a name="954"></a>                    /* do the postfix operation */
<br><a name="955"></a>                    <font color="red">if </font>(<a href="expression.html#144">Parser</a>->Mode == RunModeRun /* && <a href="expression.html#895">FoundPrecedence</a> < *<a href="expression.html#893">IgnorePrecedence</a> */)
<br><a name="956"></a>                    {
<br><a name="957"></a>                        /* run the operator */
<br><a name="958"></a>                        <a style="color:green" href="expression.html#618">ExpressionPostfixOperator</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#899">TopOperatorNode</a>->Op, <a href="expression.html#484">TopValue</a>);
<br><a name="959"></a>                    }
<br><a name="960"></a>                    else
<br><a name="961"></a>                    {
<br><a name="962"></a>                        /* we're not running it so just <font color="red">return </font>0 */
<br><a name="963"></a>                        <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, 0);
<br><a name="964"></a>                    }
<br><a name="965"></a>                    break;
<br><a name="966"></a>                
<br><a name="967"></a>                case OrderInfix:
<br><a name="968"></a>                    /* infix evaluation */
<br><a name="969"></a>                    <a style="color:green" href="expression.html#20">debugf</a>("infix evaluation\n");
<br><a name="970"></a>                    <a href="expression.html#484">TopValue</a> = <a href="expression.html#898">TopStackNode</a>->Val;
<br><a name="971"></a>                    <font color="red">if </font>(<a href="expression.html#484">TopValue</a> != NULL)
<br><a name="972"></a>                    {
<br><a name="973"></a>                        <a href="expression.html#484">BottomValue</a> = <a href="expression.html#899">TopOperatorNode</a>->Next->Val;
<br><a name="974"></a>                        
<br><a name="975"></a>                        /* pop a value, the operator and another value - assume they'll still be there until we're done */
<br><a name="976"></a>                        <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="expression.html#144">Parser</a>->pc, NULL, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>) + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>) + TypeStackSize<a href="interpreter_header.html#217">Value</a>(Top<a href="interpreter_header.html#217">Value</a>));
<br><a name="977"></a>                        <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="expression.html#144">Parser</a>->pc, NULL, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>));
<br><a name="978"></a>                        <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#484">Bottom<a href="interpreter_header.html#217">Value</a></a>, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>) + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>) + TypeStackSize<a href="interpreter_header.html#217">Value</a>(<a href="expression.html#484">Bottom<a href="interpreter_header.html#217">Value</a></a>));
<br><a name="979"></a>                        *<a href="expression.html#283">StackTop</a> = <a href="expression.html#899">TopOperatorNode</a>->Next->Next;
<br><a name="980"></a>                        
<br><a name="981"></a>                        /* do the infix operation */
<br><a name="982"></a>                        <font color="red">if </font>(<a href="expression.html#144">Parser</a>->Mode == RunModeRun /* && <a href="expression.html#895">FoundPrecedence</a> <= *<a href="expression.html#893">IgnorePrecedence</a> */)
<br><a name="983"></a>                        {
<br><a name="984"></a>                            /* run the operator */
<br><a name="985"></a>                            <a style="color:green" href="expression.html#681">ExpressionInfixOperator</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#899">TopOperatorNode</a>->Op, <a href="expression.html#484">BottomValue</a>, <a href="expression.html#484">TopValue</a>);
<br><a name="986"></a>                        }
<br><a name="987"></a>                        else
<br><a name="988"></a>                        {
<br><a name="989"></a>                            /* we're not running it so just <font color="red">return </font>0 */
<br><a name="990"></a>                            <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, 0);
<br><a name="991"></a>                        }
<br><a name="992"></a>                    }
<br><a name="993"></a>                    else
<br><a name="994"></a>                        <a href="expression.html#895">FoundPrecedence</a> = -1;
<br><a name="995"></a>                    break;
<br><a name="996"></a>
<br><a name="997"></a>                case OrderNone:
<br><a name="998"></a>                    /* this should never happen */
<br><a name="999"></a>                    assert(<a href="expression.html#899">TopOperatorNode</a>->Order != OrderNone);
<br><a name="1000"></a>                    break;
<br><a name="1001"></a>            }
<br><a name="1002"></a>            
<br><a name="1003"></a>            /* <font color="red">if </font>we've returned above the ignored precedence level turn ignoring off */
<br><a name="1004"></a>            <font color="red">if </font>(<a href="expression.html#895">FoundPrecedence</a> <= *<a href="expression.html#893">IgnorePrecedence</a>)
<br><a name="1005"></a>                *<a href="expression.html#893">IgnorePrecedence</a> = DEEP_PRECEDENCE;
<br><a name="1006"></a>        }
<br><a name="1007"></a>#ifdef DEBUG_EXPRESSIONS
<br><a name="1008"></a>        ExpressionStackShow(<a href="expression.html#144">Parser</a>->pc, *<a href="expression.html#283">StackTop</a>);
<br><a name="1009"></a>#endif
<br><a name="1010"></a>        <a href="expression.html#898">TopStackNode</a> = *<a href="expression.html#283">StackTop</a>;
<br><a name="1011"></a>    }
<br><a name="1012"></a>    <a style="color:green" href="expression.html#20">debugf</a>("ExpressionStackCollapse() finished\n");
<br><a name="1013"></a>#ifdef DEBUG_EXPRESSIONS
<br><a name="1014"></a>    ExpressionStackShow(<a href="expression.html#144">Parser</a>->pc, *<a href="expression.html#283">StackTop</a>);
<br><a name="1015"></a>#endif
<br><a name="1016"></a>}
<br><a name="1017"></a>
<br><a name="1018"></a>/* push an operator on to the expression stack */
<br><a name="1019"></a>void <a href="expression.html#35">ExpressionStack</a>PushOperator(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, enum OperatorOrder Order, enum Lex<a href="expression.html#1093">Token</a> <a href="expression.html#1093">Token</a>, <font color="blue">int </font><a href="expression.html#893">Precedence</a>)
<br><a name="1020"></a>{
<br><a name="1021"></a>    <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> *<a href="expression.html#285">StackNode</a> = <a style="color:green" href="variable.html#68">VariableAlloc</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>), FALSE);
<br><a name="1022"></a>    <a href="expression.html#285">StackNode</a>->Next = *<a href="expression.html#283">StackTop</a>;
<br><a name="1023"></a>    <a href="expression.html#285">StackNode</a>-><a href="expression.html#1019">Order</a> = <a href="expression.html#1019">Order</a>;
<br><a name="1024"></a>    <a href="expression.html#285">StackNode</a>->Op = <a href="expression.html#1019">Token</a>;
<br><a name="1025"></a>    <a href="expression.html#285">StackNode</a>-><a href="expression.html#893">Precedence</a> = <a href="expression.html#893">Precedence</a>;
<br><a name="1026"></a>    *<a href="expression.html#283">StackTop</a> = <a href="expression.html#285">StackNode</a>;
<br><a name="1027"></a>    <a style="color:green" href="expression.html#20">debugf</a>("ExpressionStackPushOperator()\n");
<br><a name="1028"></a>#ifdef FANCY_ERROR_MESSAGES
<br><a name="1029"></a>    <a href="expression.html#285">StackNode</a>->Line = <a href="expression.html#144">Parser</a>->Line;
<br><a name="1030"></a>    <a href="expression.html#285">StackNode</a>->CharacterPos = <a href="expression.html#144">Parser</a>->CharacterPos;
<br><a name="1031"></a>#endif
<br><a name="1032"></a>#ifdef DEBUG_EXPRESSIONS
<br><a name="1033"></a>    ExpressionStackShow(<a href="expression.html#144">Parser</a>->pc, *<a href="expression.html#283">StackTop</a>);
<br><a name="1034"></a>#endif
<br><a name="1035"></a>}
<br><a name="1036"></a>
<br><a name="1037"></a>/* do the '.' and '->' operators */
<br><a name="1038"></a>void ExpressionGetStructElement(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, enum Lex<a href="expression.html#1019">Token</a> <a href="expression.html#1019">Token</a>)
<br><a name="1039"></a>{
<br><a name="1040"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Ident;
<br><a name="1041"></a>    
<br><a name="1042"></a>    /* get the identifier following the '.' or '->' */
<br><a name="1043"></a>    <font color="red">if </font>(<a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="expression.html#144">Parser</a>, &Ident, TRUE) != TokenIdentifier)
<br><a name="1044"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "need an structure or union member after '%s'", (<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>Dot) ? "." : "->");
<br><a name="1045"></a>
<br><a name="1046"></a>    <font color="red">if </font>(<a href="expression.html#144">Parser</a>->Mode == RunModeRun)
<br><a name="1047"></a>    { 
<br><a name="1048"></a>        /* look up the <font color="blue">struct </font>element */
<br><a name="1049"></a>        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *ParamVal = (*<a href="expression.html#283">StackTop</a>)->Val;
<br><a name="1050"></a>        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *StructVal = <a href="expression.html#1049">ParamVal</a>;
<br><a name="1051"></a>        <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *StructType = <a href="expression.html#1049">ParamVal</a>->Typ;
<br><a name="1052"></a>        <font color="blue">char </font>*<a href="expression.html#328">DerefDataLoc</a> = (<font color="blue">char </font>*)<a href="expression.html#1049">ParamVal</a>->Val;
<br><a name="1053"></a>        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Member<a href="interpreter_header.html#217">Value</a> = NULL;
<br><a name="1054"></a>        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="expression.html#245">Result</a>;
<br><a name="1055"></a>
<br><a name="1056"></a>        /* <font color="red">if </font>we're doing '->' dereference the <font color="blue">struct </font>pointer first */
<br><a name="1057"></a>        <font color="red">if </font>(<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>Arrow)
<br><a name="1058"></a>            <a href="expression.html#328">DerefDataLoc</a> = <a style="color:green" href="variable.html#458">VariableDereferencePointer</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#1049">ParamVal</a>, &StructVal, NULL, &StructType, NULL);
<br><a name="1059"></a>        
<br><a name="1060"></a>        <font color="red">if </font>(<a href="expression.html#1051">StructType</a>->Base != TypeStruct && <a href="expression.html#1051">StructType</a>->Base != TypeUnion)
<br><a name="1061"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "can't use '%s' on something that's not a <font color="blue">struct </font>or union %s : it's a %t", (<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>Dot) ? "." : "->", (<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>Arrow) ? "pointer" : "", <a href="expression.html#1049">ParamVal</a>->Typ);
<br><a name="1062"></a>            
<br><a name="1063"></a>        <font color="red">if </font>(!TableGet(<a href="expression.html#1051">StructType</a>->Members, <a href="expression.html#1040">Ident</a>->Val-><a href="expression.html#1040">Ident</a>ifier, &MemberValue, NULL, NULL, NULL))
<br><a name="1064"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "doesn't have a member called '%s'", <a href="expression.html#1040">Ident</a>->Val-><a href="expression.html#1040">Ident</a>ifier);
<br><a name="1065"></a>        
<br><a name="1066"></a>        /* pop the value - assume it'll still be there until we're done */
<br><a name="1067"></a>        <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#1049">ParamVal</a>, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>) + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>) + TypeStackSize<a href="interpreter_header.html#217">Value</a>(<a href="expression.html#1050">StructVal</a>));
<br><a name="1068"></a>        *<a href="expression.html#283">StackTop</a> = (*<a href="expression.html#283">StackTop</a>)->Next;
<br><a name="1069"></a>        
<br><a name="1070"></a>        /* make the result value <font color="red">for </font>this member only */
<br><a name="1071"></a>        <a href="expression.html#245">Result</a> = <a style="color:green" href="variable.html#135">VariableAllocValueFromExistingData</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#1053">MemberValue</a>->Typ, (void *)(<a href="expression.html#328">DerefDataLoc</a> + <a href="expression.html#1053">MemberValue</a>->Val->Integer), TRUE, (<a href="expression.html#1050">StructVal</a> != NULL) ? <a href="expression.html#1050">StructVal</a>->LValueFrom : NULL);
<br><a name="1072"></a>        <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#245">Result</a>);
<br><a name="1073"></a>    }
<br><a name="1074"></a>}
<br><a name="1075"></a>
<br><a name="1076"></a>/* parse an expression with operator precedence */
<br><a name="1077"></a><font color="blue">int </font>ExpressionParse(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> **<a href="expression.html#245">Result</a>)
<br><a name="1078"></a>{
<br><a name="1079"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Lex<a href="interpreter_header.html#217">Value</a>;
<br><a name="1080"></a>    <font color="blue">int </font>PrefixState = TRUE;
<br><a name="1081"></a>    <font color="blue">int </font>Done = FALSE;
<br><a name="1082"></a>    <font color="blue">int </font>BracketPrecedence = 0;
<br><a name="1083"></a>    <font color="blue">int </font>LocalPrecedence;
<br><a name="1084"></a>    <font color="blue">int </font><a href="expression.html#893">Precedence</a> = 0;
<br><a name="1085"></a>    <font color="blue">int </font><a href="expression.html#893">IgnorePrecedence</a> = DEEP_PRECEDENCE;
<br><a name="1086"></a>    <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> *<a href="expression.html#283">StackTop</a> = NULL;
<br><a name="1087"></a>    <font color="blue">int </font>TernaryDepth = 0;
<br><a name="1088"></a>    
<br><a name="1089"></a>    <a style="color:green" href="expression.html#20">debugf</a>("ExpressionParse():\n");
<br><a name="1090"></a>    do
<br><a name="1091"></a>    {
<br><a name="1092"></a>        <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> PreState;
<br><a name="1093"></a>        enum Lex<a href="expression.html#1019">Token</a> <a href="expression.html#1019">Token</a>;
<br><a name="1094"></a>
<br><a name="1095"></a>        <a style="color:green" href="parse.html#429"><a href="expression.html#144">Parser</a>Copy</a>(&PreState, <a href="expression.html#144">Parser</a>);
<br><a name="1096"></a>        <a href="expression.html#1019">Token</a> = LexGet<a href="expression.html#1019">Token</a>(<a href="expression.html#144">Parser</a>, &LexValue, TRUE);
<br><a name="1097"></a>        <font color="red">if </font>( ( ( (int)<a href="expression.html#1019">Token</a> > <a href="expression.html#1019">Token</a>Comma && (int)<a href="expression.html#1019">Token</a> <= (int)<a href="expression.html#1019">Token</a>OpenBracket) || 
<br><a name="1098"></a>               (<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>CloseBracket && <a href="expression.html#1082">BracketPrecedence</a> != 0)) && 
<br><a name="1099"></a>               (<a href="expression.html#1019">Token</a> != <a href="expression.html#1019">Token</a>Colon || <a href="expression.html#1087">TernaryDepth</a> > 0) )
<br><a name="1100"></a>        { 
<br><a name="1101"></a>            /* it's an operator with precedence */
<br><a name="1102"></a>            <font color="red">if </font>(<a href="expression.html#1080">PrefixState</a>)
<br><a name="1103"></a>            { 
<br><a name="1104"></a>                /* expect a prefix operator */
<br><a name="1105"></a>                <font color="red">if </font>(OperatorPrecedence<font color="red">[</font>(int)Token<font color="red">]</font>.PrefixPrecedence == 0)
<br><a name="1106"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "operator not expected here");
<br><a name="1107"></a>                
<br><a name="1108"></a>                <a href="expression.html#1083">LocalPrecedence</a> = OperatorPrecedence<font color="red">[</font>(int)Token<font color="red">]</font>.PrefixPrecedence;
<br><a name="1109"></a>                <a href="expression.html#893">Precedence</a> = Bracket<a href="expression.html#893">Precedence</a> + Local<a href="expression.html#893">Precedence</a>;
<br><a name="1110"></a>
<br><a name="1111"></a>                <font color="red">if </font>(<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>OpenBracket)
<br><a name="1112"></a>                { 
<br><a name="1113"></a>                    /* it's either a new bracket level or a cast */
<br><a name="1114"></a>                    enum LexToken BracketToken = <a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="expression.html#144">Parser</a>, &LexValue, FALSE);
<br><a name="1115"></a>                    <font color="red">if </font>(<a style="color:green" href="expression.html#144">IsTypeToken</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#1114">BracketToken</a>, <a href="expression.html#144">LexValue</a>) && (<a href="expression.html#283">StackTop</a> == NULL || <a href="expression.html#283">StackTop</a>->Op != TokenSizeof) )
<br><a name="1116"></a>                    {
<br><a name="1117"></a>                        /* it's a cast - get the new type */
<br><a name="1118"></a>                        <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *CastType;
<br><a name="1119"></a>                        <font color="blue">char </font>*CastIdentifier;
<br><a name="1120"></a>                        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *CastType<a href="interpreter_header.html#217">Value</a>;
<br><a name="1121"></a>                        
<br><a name="1122"></a>                        <a style="color:green" href="type.html#526">TypeParse</a>(<a href="expression.html#144">Parser</a>, &CastType, &CastIdentifier, NULL);
<br><a name="1123"></a>                        <font color="red">if </font>(<a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="expression.html#144">Parser</a>, &LexValue, TRUE) != TokenCloseBracket)
<br><a name="1124"></a>                            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "brackets not closed");
<br><a name="1125"></a>                        
<br><a name="1126"></a>                        /* scan and collapse the stack to the precedence of this infix cast operator, then push */
<br><a name="1127"></a>                        <a href="expression.html#893">Precedence</a> = Bracket<a href="expression.html#893">Precedence</a> + Operator<a href="expression.html#893">Precedence</a><font color="red">[</font>(int)TokenCast<font color="red">]</font>.Prefix<a href="expression.html#893">Precedence</a>;
<br><a name="1128"></a>
<br><a name="1129"></a>                        <a style="color:green" href="expression.html#893">ExpressionStackCollapse</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#893">Precedence</a>+1, &Ignore<a href="expression.html#893">Precedence</a>);
<br><a name="1130"></a>                        <a href="expression.html#1120">CastTypeValue</a> = <a style="color:green" href="variable.html#107">VariableAllocValueFromType</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, &<a href="expression.html#144">Parser</a>->pc->TypeType, FALSE, NULL, FALSE);
<br><a name="1131"></a>                        <a href="expression.html#1120"><a href="expression.html#1118">CastType</a>Value</a>->Val->Typ = <a href="expression.html#1118">CastType</a>;
<br><a name="1132"></a>                        <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#1120">CastTypeValue</a>);
<br><a name="1133"></a>                        <a style="color:green" href="expression.html#1019">ExpressionStackPushOperator</a>(<a href="expression.html#144">Parser</a>, &StackTop, OrderInfix, TokenCast, <a href="expression.html#893">Precedence</a>);
<br><a name="1134"></a>                    }
<br><a name="1135"></a>                    else
<br><a name="1136"></a>                    {
<br><a name="1137"></a>                        /* boost the bracket operator precedence */
<br><a name="1138"></a>                        <a href="expression.html#1082">BracketPrecedence</a> += BRACKET_PRECEDENCE;
<br><a name="1139"></a>                    }
<br><a name="1140"></a>                }
<br><a name="1141"></a>                else
<br><a name="1142"></a>                { 
<br><a name="1143"></a>                    /* scan and collapse the stack to the precedence of this operator, then push */
<br><a name="1144"></a>                    
<br><a name="1145"></a>                    /* take some extra care <font color="red">for </font><font color="blue">double </font>prefix operators, e.g. x = - -5, or x = **y */
<br><a name="1146"></a>                    <font color="blue">int </font>NextToken = <a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="expression.html#144">Parser</a>, NULL, FALSE);
<br><a name="1147"></a>                    <font color="blue">int </font>TempPrecedenceBoost = 0;
<br><a name="1148"></a>                    <font color="red">if </font>(<a href="expression.html#1146">NextToken</a> > TokenComma && <a href="expression.html#1146">NextToken</a> < TokenOpenBracket)
<br><a name="1149"></a>                    {
<br><a name="1150"></a>                        <font color="blue">int </font>NextPrecedence = OperatorPrecedence<font color="red">[</font>(int)NextToken<font color="red">]</font>.PrefixPrecedence;
<br><a name="1151"></a>                        
<br><a name="1152"></a>                        /* two prefix operators with equal precedence? make sure the innermost one runs first */
<br><a name="1153"></a>                        /* XXX - probably not correct, but can't find a test that fails at this */
<br><a name="1154"></a>                        <font color="red">if </font>(<a href="expression.html#1083">LocalPrecedence</a> == <a href="expression.html#1150">NextPrecedence</a>)
<br><a name="1155"></a>                            <a href="expression.html#1147">TempPrecedenceBoost</a> = -1;
<br><a name="1156"></a>                    }
<br><a name="1157"></a>
<br><a name="1158"></a>                    <a style="color:green" href="expression.html#893">ExpressionStackCollapse</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#893">Precedence</a>, &Ignore<a href="expression.html#893">Precedence</a>);
<br><a name="1159"></a>                    <a style="color:green" href="expression.html#1019">ExpressionStackPushOperator</a>(<a href="expression.html#144">Parser</a>, &StackTop, OrderPrefix, <a href="expression.html#1019">Token</a>, <a href="expression.html#893">Precedence</a> + Temp<a href="expression.html#893">Precedence</a>Boost);
<br><a name="1160"></a>                }
<br><a name="1161"></a>            }
<br><a name="1162"></a>            else
<br><a name="1163"></a>            { 
<br><a name="1164"></a>                /* expect an infix or postfix operator */
<br><a name="1165"></a>                <font color="red">if </font>(OperatorPrecedence<font color="red">[</font>(int)Token<font color="red">]</font>.PostfixPrecedence != 0)
<br><a name="1166"></a>                {
<br><a name="1167"></a>                    switch (<a href="expression.html#1019">Token</a>)
<br><a name="1168"></a>                    {
<br><a name="1169"></a>                        case TokenCloseBracket:
<br><a name="1170"></a>                        case TokenRightSquareBracket:
<br><a name="1171"></a>                            <font color="red">if </font>(<a href="expression.html#1082">BracketPrecedence</a> == 0)
<br><a name="1172"></a>                            { 
<br><a name="1173"></a>                                /* assume this bracket is after the end of the expression */
<br><a name="1174"></a>                                <a style="color:green" href="parse.html#429"><a href="expression.html#144">Parser</a>Copy</a>(<a href="expression.html#144">Parser</a>, &PreState);
<br><a name="1175"></a>                                <a href="expression.html#1081">Done</a> = TRUE;
<br><a name="1176"></a>                            }
<br><a name="1177"></a>                            else
<br><a name="1178"></a>                            {
<br><a name="1179"></a>                                /* collapse to the bracket precedence */
<br><a name="1180"></a>                                <a style="color:green" href="expression.html#893">ExpressionStackCollapse</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#1082">BracketPrecedence</a>, &IgnorePrecedence);
<br><a name="1181"></a>                                <a href="expression.html#1082">BracketPrecedence</a> -= BRACKET_PRECEDENCE;
<br><a name="1182"></a>                            }    
<br><a name="1183"></a>                            break;
<br><a name="1184"></a>                    
<br><a name="1185"></a>                        default:
<br><a name="1186"></a>                            /* scan and collapse the stack to the precedence of this operator, then push */
<br><a name="1187"></a>                            <a href="expression.html#893">Precedence</a> = Bracket<a href="expression.html#893">Precedence</a> + Operator<a href="expression.html#893">Precedence</a><font color="red">[</font>(int)Token<font color="red">]</font>.Postfix<a href="expression.html#893">Precedence</a>;
<br><a name="1188"></a>                            <a style="color:green" href="expression.html#893">ExpressionStackCollapse</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#893">Precedence</a>, &Ignore<a href="expression.html#893">Precedence</a>);
<br><a name="1189"></a>                            <a style="color:green" href="expression.html#1019">ExpressionStackPushOperator</a>(<a href="expression.html#144">Parser</a>, &StackTop, OrderPostfix, <a href="expression.html#1019">Token</a>, <a href="expression.html#893">Precedence</a>);
<br><a name="1190"></a>                            break;
<br><a name="1191"></a>                    }
<br><a name="1192"></a>                }
<br><a name="1193"></a>                else <font color="red">if </font>(OperatorPrecedence<font color="red">[</font>(int)Token<font color="red">]</font>.InfixPrecedence != 0)
<br><a name="1194"></a>                { 
<br><a name="1195"></a>                    /* scan and collapse the stack, then push */
<br><a name="1196"></a>                    <a href="expression.html#893">Precedence</a> = Bracket<a href="expression.html#893">Precedence</a> + Operator<a href="expression.html#893">Precedence</a><font color="red">[</font>(int)Token<font color="red">]</font>.Infix<a href="expression.html#893">Precedence</a>;
<br><a name="1197"></a>                    
<br><a name="1198"></a>                    /* <font color="red">for </font>right to left order, only go down to the next higher precedence so we evaluate it in reverse order */
<br><a name="1199"></a>                    /* <font color="red">for </font>left to right order, collapse down to this precedence so we evaluate it in forward order */
<br><a name="1200"></a>                    <font color="red">if </font>(IS_LEFT_TO_RIGHT(OperatorPrecedence<font color="red">[</font>(int)Token<font color="red">]</font>.InfixPrecedence))
<br><a name="1201"></a>                        <a style="color:green" href="expression.html#893">ExpressionStackCollapse</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#893">Precedence</a>, &Ignore<a href="expression.html#893">Precedence</a>);
<br><a name="1202"></a>                    else
<br><a name="1203"></a>                        <a style="color:green" href="expression.html#893">ExpressionStackCollapse</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#893">Precedence</a>+1, &Ignore<a href="expression.html#893">Precedence</a>);
<br><a name="1204"></a>                        
<br><a name="1205"></a>                    <font color="red">if </font>(<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>Dot || <a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>Arrow)
<br><a name="1206"></a>                    {
<br><a name="1207"></a>                        <a style="color:green" href="expression.html#1038">ExpressionGetStructElement</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#1019">Token</a>); /* this operator is followed by a <font color="blue">struct </font>element so handle it as a special case */
<br><a name="1208"></a>                    }
<br><a name="1209"></a>                    else
<br><a name="1210"></a>                    { 
<br><a name="1211"></a>                        /* <font color="red">if </font>it's a && or || operator we may not need to evaluate the right hand side of the expression */
<br><a name="1212"></a>                        <font color="red">if </font>( (<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>LogicalOr || <a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>LogicalAnd) && IS_NUMERIC_COERCIBLE(<a href="expression.html#283">StackTop</a>->Val))
<br><a name="1213"></a>                        {
<br><a name="1214"></a>                            <font color="blue">long </font>LHSInt = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#283">StackTop</a>->Val);
<br><a name="1215"></a>                            <font color="red">if </font>( ( (<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>LogicalOr && <a href="expression.html#1214">LHSInt</a>) || (<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>LogicalAnd && !<a href="expression.html#1214">LHSInt</a>) ) &&
<br><a name="1216"></a>                                 (<a href="expression.html#893">Ignore<a href="expression.html#893">Precedence</a></a> > <a href="expression.html#893">Precedence</a>) )
<br><a name="1217"></a>                                <a href="expression.html#893">Ignore<a href="expression.html#893">Precedence</a></a> = <a href="expression.html#893">Precedence</a>;
<br><a name="1218"></a>                        }
<br><a name="1219"></a>                        
<br><a name="1220"></a>                        /* push the operator on the stack */
<br><a name="1221"></a>                        <a style="color:green" href="expression.html#1019">ExpressionStackPushOperator</a>(<a href="expression.html#144">Parser</a>, &StackTop, OrderInfix, <a href="expression.html#1019">Token</a>, <a href="expression.html#893">Precedence</a>);
<br><a name="1222"></a>                        <a href="expression.html#1080">PrefixState</a> = TRUE;
<br><a name="1223"></a>                        
<br><a name="1224"></a>                        switch (<a href="expression.html#1019">Token</a>)
<br><a name="1225"></a>                        {
<br><a name="1226"></a>                            case TokenQuestionMark: <a href="expression.html#1087">TernaryDepth</a>++; break;
<br><a name="1227"></a>                            case TokenColon: <a href="expression.html#1087">TernaryDepth</a>--; break;
<br><a name="1228"></a>                            default: break;
<br><a name="1229"></a>                        }
<br><a name="1230"></a>                    }
<br><a name="1231"></a>
<br><a name="1232"></a>                    /* treat an open square bracket as an infix array index operator followed by an open bracket */
<br><a name="1233"></a>                    <font color="red">if </font>(<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>LeftSquareBracket)
<br><a name="1234"></a>                    { 
<br><a name="1235"></a>                        /* boost the bracket operator precedence, then push */
<br><a name="1236"></a>                        <a href="expression.html#1082">BracketPrecedence</a> += BRACKET_PRECEDENCE;
<br><a name="1237"></a>                    }
<br><a name="1238"></a>                }
<br><a name="1239"></a>                else
<br><a name="1240"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "operator not expected here");
<br><a name="1241"></a>            }
<br><a name="1242"></a>        }
<br><a name="1243"></a>        else <font color="red">if </font>(<a href="expression.html#1019">Token</a> == <a href="expression.html#1019">Token</a>Identifier)
<br><a name="1244"></a>        { 
<br><a name="1245"></a>            /* it's a variable, function or a macro */
<br><a name="1246"></a>            <font color="red">if </font>(!PrefixState)
<br><a name="1247"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "identifier not expected here");
<br><a name="1248"></a>                
<br><a name="1249"></a>            <font color="red">if </font>(<a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="expression.html#144">Parser</a>, NULL, FALSE) == TokenOpenBracket)
<br><a name="1250"></a>            {
<br><a name="1251"></a>                <a style="color:green" href="expression.html#1441">ExpressionParseFunctionCall</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#144">LexValue</a>->Val->Identifier, <a href="expression.html#144">Parser</a>->Mode == RunModeRun && <a href="expression.html#893">Precedence</a> < Ignore<a href="expression.html#893">Precedence</a>);
<br><a name="1252"></a>            }
<br><a name="1253"></a>            else
<br><a name="1254"></a>            {
<br><a name="1255"></a>                <font color="red">if </font>(<a href="expression.html#144">Parser</a>->Mode == RunModeRun /* && <a href="expression.html#893">Precedence</a> < Ignore<a href="expression.html#893">Precedence</a> */)
<br><a name="1256"></a>                {
<br><a name="1257"></a>                    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Variable<a href="interpreter_header.html#217">Value</a> = NULL;
<br><a name="1258"></a>                    
<br><a name="1259"></a>                    <a style="color:green" href="variable.html#360">VariableGet</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, <a href="expression.html#144">LexValue</a>->Val->Identifier, &VariableValue);
<br><a name="1260"></a>                    <font color="red">if </font>(<a href="expression.html#1257">VariableValue</a>->Typ->Base == TypeMacro)
<br><a name="1261"></a>                    {
<br><a name="1262"></a>                        /* evaluate a macro as a kind of simple subroutine */
<br><a name="1263"></a>                        <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> <a href="expression.html#1415">MacroParser</a>;
<br><a name="1264"></a>                        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *MacroResult;
<br><a name="1265"></a>                        
<br><a name="1266"></a>                        <a style="color:green" href="parse.html#429">ParserCopy</a>(&MacroParser, &VariableValue->Val->MacroDef.Body);
<br><a name="1267"></a>                        <a href="expression.html#1263">Macro<a href="expression.html#144">Parser</a></a>.Mode = <a href="expression.html#144">Parser</a>->Mode;
<br><a name="1268"></a>                        <font color="red">if </font>(<a href="expression.html#1257">VariableValue</a>->Val->MacroDef.NumParams != 0)
<br><a name="1269"></a>                            <a style="color:green" href="platform.html#134">ProgramFail</a>(&MacroParser, "macro arguments missing");
<br><a name="1270"></a>                            
<br><a name="1271"></a>                        <font color="red">if </font>(!ExpressionParse(&MacroParser, &MacroResult) || <a style="color:green" href="lex.html#883">LexGetToken</a>(&MacroParser, NULL, FALSE) != TokenEndOfFunction)
<br><a name="1272"></a>                            <a style="color:green" href="platform.html#134">ProgramFail</a>(&MacroParser, "expression expected");
<br><a name="1273"></a>                        
<br><a name="1274"></a>                        <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#1264">MacroResult</a>);
<br><a name="1275"></a>                    }
<br><a name="1276"></a>                    else <font color="red">if </font>(<a href="expression.html#1257">VariableValue</a>->Typ == &Parser->pc->VoidType)
<br><a name="1277"></a>                        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "a void value isn't much use here");
<br><a name="1278"></a>                    else
<br><a name="1279"></a>                        <a style="color:green" href="expression.html#314">ExpressionStackPushLValue</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#1257">VariableValue</a>, 0); /* it's a value variable */
<br><a name="1280"></a>                }
<br><a name="1281"></a>                else /* push a dummy value */
<br><a name="1282"></a>                    <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, &StackTop, 0);
<br><a name="1283"></a>                    
<br><a name="1284"></a>            }
<br><a name="1285"></a>
<br><a name="1286"></a>             /* <font color="red">if </font>we've successfully ignored the RHS turn ignoring off */
<br><a name="1287"></a>            <font color="red">if </font>(<a href="expression.html#893">Precedence</a> <= Ignore<a href="expression.html#893">Precedence</a>)
<br><a name="1288"></a>                <a href="expression.html#893">IgnorePrecedence</a> = DEEP_PRECEDENCE;
<br><a name="1289"></a>
<br><a name="1290"></a>            <a href="expression.html#1080">PrefixState</a> = FALSE;
<br><a name="1291"></a>        }
<br><a name="1292"></a>        else <font color="red">if </font>((int)<a href="expression.html#1019">Token</a> > <a href="expression.html#1019">Token</a>CloseBracket && (int)<a href="expression.html#1019">Token</a> <= <a href="expression.html#1019">Token</a>CharacterConstant)
<br><a name="1293"></a>        { 
<br><a name="1294"></a>            /* it's a value of some sort, push it */
<br><a name="1295"></a>            <font color="red">if </font>(!PrefixState)
<br><a name="1296"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "value not expected here");
<br><a name="1297"></a>                
<br><a name="1298"></a>            <a href="expression.html#1080">PrefixState</a> = FALSE;
<br><a name="1299"></a>            <a style="color:green" href="expression.html#308">ExpressionStackPushValue</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#144">LexValue</a>);
<br><a name="1300"></a>        }
<br><a name="1301"></a>        else <font color="red">if </font>(<a style="color:green" href="expression.html#144">IsType<a href="expression.html#1019">Token</a></a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#1019">Token</a>, <a href="expression.html#144">LexValue</a>))
<br><a name="1302"></a>        {
<br><a name="1303"></a>            /* it's a type. push it on the stack like a value. this is used in sizeof() */
<br><a name="1304"></a>            <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *Typ;
<br><a name="1305"></a>            <font color="blue">char </font>*Identifier;
<br><a name="1306"></a>            <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Type<a href="interpreter_header.html#217">Value</a>;
<br><a name="1307"></a>            
<br><a name="1308"></a>            <font color="red">if </font>(!PrefixState)
<br><a name="1309"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "type not expected here");
<br><a name="1310"></a>                
<br><a name="1311"></a>            <a href="expression.html#1080">PrefixState</a> = FALSE;
<br><a name="1312"></a>            <a style="color:green" href="parse.html#429"><a href="expression.html#144">Parser</a>Copy</a>(<a href="expression.html#144">Parser</a>, &PreState);
<br><a name="1313"></a>            <a style="color:green" href="type.html#526">TypeParse</a>(<a href="expression.html#144">Parser</a>, &Typ, &Identifier, NULL);
<br><a name="1314"></a>            <a href="expression.html#1306">TypeValue</a> = <a style="color:green" href="variable.html#107">VariableAllocValueFromType</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, &<a href="expression.html#144">Parser</a>->pc->TypeType, FALSE, NULL, FALSE);
<br><a name="1315"></a>            <a href="expression.html#1306"><a href="expression.html#1304">Typ</a>eValue</a>->Val-><a href="expression.html#1304">Typ</a> = <a href="expression.html#1304">Typ</a>;
<br><a name="1316"></a>            <a style="color:green" href="expression.html#283">ExpressionStackPushValueNode</a>(<a href="expression.html#144">Parser</a>, &StackTop, <a href="expression.html#1306">TypeValue</a>);
<br><a name="1317"></a>        }
<br><a name="1318"></a>        else
<br><a name="1319"></a>        { 
<br><a name="1320"></a>            /* it isn't a token from an expression */
<br><a name="1321"></a>            <a style="color:green" href="parse.html#429"><a href="expression.html#144">Parser</a>Copy</a>(<a href="expression.html#144">Parser</a>, &PreState);
<br><a name="1322"></a>            <a href="expression.html#1081">Done</a> = TRUE;
<br><a name="1323"></a>        }
<br><a name="1324"></a>        
<br><a name="1325"></a>    } <font color="red">while </font>(!Done);
<br><a name="1326"></a>    
<br><a name="1327"></a>    /* check that brackets have been closed */
<br><a name="1328"></a>    <font color="red">if </font>(<a href="expression.html#1082">BracketPrecedence</a> > 0)
<br><a name="1329"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "brackets not closed");
<br><a name="1330"></a>        
<br><a name="1331"></a>    /* scan and collapse the stack to precedence 0 */
<br><a name="1332"></a>    <a style="color:green" href="expression.html#893">ExpressionStackCollapse</a>(<a href="expression.html#144">Parser</a>, &StackTop, 0, &IgnorePrecedence);
<br><a name="1333"></a>    
<br><a name="1334"></a>    /* fix up the stack and <font color="red">return </font>the result <font color="red">if </font>we're in run mode */
<br><a name="1335"></a>    <font color="red">if </font>(<a href="expression.html#283">StackTop</a> != NULL)
<br><a name="1336"></a>    {
<br><a name="1337"></a>        /* all that should be left is a single value on the stack */
<br><a name="1338"></a>        <font color="red">if </font>(<a href="expression.html#144">Parser</a>->Mode == RunModeRun)
<br><a name="1339"></a>        {
<br><a name="1340"></a>            <font color="red">if </font>(<a href="expression.html#283">StackTop</a>->Order != OrderNone || <a href="expression.html#283">StackTop</a>->Next != NULL)
<br><a name="1341"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "invalid expression");
<br><a name="1342"></a>                
<br><a name="1343"></a>            *<a href="expression.html#245">Result</a> = <a href="expression.html#283">StackTop</a>->Val;
<br><a name="1344"></a>            <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#283">StackTop</a>, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>));
<br><a name="1345"></a>        }
<br><a name="1346"></a>        else
<br><a name="1347"></a>            <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#283">StackTop</a>->Val, sizeof(<font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a>) + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>) + TypeStackSize<a href="interpreter_header.html#217">Value</a>(<a href="expression.html#283">StackTop</a>->Val));
<br><a name="1348"></a>    }
<br><a name="1349"></a>    
<br><a name="1350"></a>    <a style="color:green" href="expression.html#20">debugf</a>("ExpressionParse() done\n\n");
<br><a name="1351"></a>#ifdef DEBUG_EXPRESSIONS
<br><a name="1352"></a>    ExpressionStackShow(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#283">StackTop</a>);
<br><a name="1353"></a>#endif
<br><a name="1354"></a>    <font color="red">return </font><a href="expression.html#283">StackTop</a> != NULL;
<br><a name="1355"></a>}
<br><a name="1356"></a>
<br><a name="1357"></a>
<br><a name="1358"></a>/* do a parameterised macro call */
<br><a name="1359"></a>void ExpressionParseMacroCall(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, const <font color="blue">char </font>*MacroName, <font color="blue">struct </font><a href="interpreter_header.html#188">MacroDef</a> *MDef)
<br><a name="1360"></a>{
<br><a name="1361"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Return<a href="interpreter_header.html#217">Value</a> = NULL;
<br><a name="1362"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="expression.html#1445">Param</a>;
<br><a name="1363"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> **<a href="expression.html#1446">ParamArray</a> = NULL;
<br><a name="1364"></a>    <font color="blue">int </font><a href="expression.html#1447">ArgCount</a>;
<br><a name="1365"></a>    enum Lex<a href="expression.html#1019">Token</a> <a href="expression.html#1019">Token</a>;
<br><a name="1366"></a>    
<br><a name="1367"></a>    <font color="red">if </font>(<a href="expression.html#144">Parser</a>->Mode == RunModeRun) 
<br><a name="1368"></a>    { 
<br><a name="1369"></a>        /* create a stack frame <font color="red">for </font>this macro */
<br><a name="1370"></a>#ifndef NO_FP
<br><a name="1371"></a>        <a style="color:green" href="expression.html#299">ExpressionStackPushValueByType</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, &<a href="expression.html#144">Parser</a>->pc->FPType);  /* largest <font color="red">return </font>type there is */
<br><a name="1372"></a>#else
<br><a name="1373"></a>        <a style="color:green" href="expression.html#299">ExpressionStackPushValueByType</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, &<a href="expression.html#144">Parser</a>->pc->IntType);  /* largest <font color="red">return </font>type there is */
<br><a name="1374"></a>#endif
<br><a name="1375"></a>        <a href="expression.html#1361">ReturnValue</a> = (*<a href="expression.html#283">StackTop</a>)->Val;
<br><a name="1376"></a>        <a style="color:green" href="heap.html#108">HeapPushStackFrame</a>(<a href="expression.html#144">Parser</a>->pc);
<br><a name="1377"></a>        <a href="expression.html#1363">ParamArray</a> = <a style="color:green" href="heap.html#67">HeapAllocStack</a>(<a href="expression.html#144">Parser</a>->pc, sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *) * <a href="expression.html#1359">MDef</a>->NumParams);    
<br><a name="1378"></a>        <font color="red">if </font>(<a href="expression.html#1363">ParamArray</a> == NULL)
<br><a name="1379"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "out of memory");
<br><a name="1380"></a>    }
<br><a name="1381"></a>    else
<br><a name="1382"></a>        <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, 0);
<br><a name="1383"></a>        
<br><a name="1384"></a>    /* parse arguments */
<br><a name="1385"></a>    <a href="expression.html#1364">ArgCount</a> = 0;
<br><a name="1386"></a>    do {
<br><a name="1387"></a>        <font color="red">if </font>(<a style="color:green" href="expression.html#1077">ExpressionParse</a>(<a href="expression.html#144">Parser</a>, &Param))
<br><a name="1388"></a>        {
<br><a name="1389"></a>            <font color="red">if </font>(<a href="expression.html#144">Parser</a>->Mode == RunModeRun)
<br><a name="1390"></a>            { 
<br><a name="1391"></a>                <font color="red">if </font>(<a href="expression.html#1364">ArgCount</a> &lt; <a href="expression.html#1359">MDef</a>-&gt;NumParams)
<br><a name="1392"></a>                    <a href="expression.html#1362">Param</a>Array<font color="red">[</font>ArgCount<font color="red">]</font> = <a href="expression.html#1362">Param</a>;
<br><a name="1393"></a>                else
<br><a name="1394"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "too many arguments to %s()", <a href="expression.html#1359">MacroName</a>);
<br><a name="1395"></a>            }
<br><a name="1396"></a>            
<br><a name="1397"></a>            <a href="expression.html#1364">ArgCount</a>++;
<br><a name="1398"></a>            <a href="expression.html#1019">Token</a> = LexGet<a href="expression.html#1019">Token</a>(<a href="expression.html#144">Parser</a>, NULL, TRUE);
<br><a name="1399"></a>            <font color="red">if </font>(<a href="expression.html#1019">Token</a> != <a href="expression.html#1019">Token</a>Comma && <a href="expression.html#1019">Token</a> != <a href="expression.html#1019">Token</a>CloseBracket)
<br><a name="1400"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "comma expected");
<br><a name="1401"></a>        }
<br><a name="1402"></a>        else
<br><a name="1403"></a>        { 
<br><a name="1404"></a>            /* end of argument list? */
<br><a name="1405"></a>            <a href="expression.html#1019">Token</a> = LexGet<a href="expression.html#1019">Token</a>(<a href="expression.html#144">Parser</a>, NULL, TRUE);
<br><a name="1406"></a>            <font color="red">if </font>(!TokenCloseBracket)
<br><a name="1407"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "bad argument");
<br><a name="1408"></a>        }
<br><a name="1409"></a>        
<br><a name="1410"></a>    } <font color="red">while </font>(<a href="expression.html#1019">Token</a> != <a href="expression.html#1019">Token</a>CloseBracket);
<br><a name="1411"></a>    
<br><a name="1412"></a>    <font color="red">if </font>(<a href="expression.html#144">Parser</a>->Mode == RunModeRun) 
<br><a name="1413"></a>    { 
<br><a name="1414"></a>        /* evaluate the macro */
<br><a name="1415"></a>        <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> <a href="expression.html#1263">MacroParser</a>;
<br><a name="1416"></a>        <font color="blue">int </font><a href="expression.html#1526">Count</a>;
<br><a name="1417"></a>        <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Eval<a href="interpreter_header.html#217">Value</a>;
<br><a name="1418"></a>        
<br><a name="1419"></a>        <font color="red">if </font>(<a href="expression.html#1364">ArgCount</a> &lt; <a href="expression.html#1359">MDef</a>-&gt;NumParams)
<br><a name="1420"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "not enough arguments to '%s'", <a href="expression.html#1359">MacroName</a>);
<br><a name="1421"></a>        
<br><a name="1422"></a>        <font color="red">if </font>(<a href="expression.html#1359">MDef</a>->Body.Pos == NULL)
<br><a name="1423"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "'%s' is undefined", <a href="expression.html#1359">MacroName</a>);
<br><a name="1424"></a>        
<br><a name="1425"></a>        <a style="color:green" href="parse.html#429">ParserCopy</a>(&MacroParser, &MDef->Body);
<br><a name="1426"></a>        <a href="expression.html#1263">Macro<a href="expression.html#144">Parser</a></a>.Mode = <a href="expression.html#144">Parser</a>->Mode;
<br><a name="1427"></a>        <a style="color:green" href="variable.html#412">VariableStackFrameAdd</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#1359">MacroName</a>, 0);
<br><a name="1428"></a>        <a href="expression.html#144">Parser</a>->pc->TopStackFrame->NumParams = <a href="expression.html#1364">ArgCount</a>;
<br><a name="1429"></a>        <a href="expression.html#144">Parser</a>->pc->TopStackFrame-><a href="expression.html#1361">ReturnValue</a> = <a href="expression.html#1361">ReturnValue</a>;
<br><a name="1430"></a>        <font color="red">for </font>(<a href="expression.html#1416">Count</a> = 0; <a href="expression.html#1416">Count</a> &lt; <a href="expression.html#1359">MDef</a>-&gt;NumParams; <a href="expression.html#1416">Count</a>++)
<br><a name="1431"></a>            <a style="color:green" href="variable.html#259">VariableDefine</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, <a href="expression.html#1359">MDef</a>->ParamName<font color="red">[</font>Count<font color="red">]</font>, ParamArray<font color="red">[</font>Count<font color="red">]</font>, NULL, TRUE);
<br><a name="1432"></a>            
<br><a name="1433"></a>        <a style="color:green" href="expression.html#1077">ExpressionParse</a>(&MacroParser, &EvalValue);
<br><a name="1434"></a>        <a style="color:green" href="expression.html#391">ExpressionAssign</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#1361">ReturnValue</a>, <a href="expression.html#1417">EvalValue</a>, TRUE, <a href="expression.html#1359">MacroName</a>, 0, FALSE);
<br><a name="1435"></a>        <a style="color:green" href="variable.html#430">VariableStackFramePop</a>(<a href="expression.html#144">Parser</a>);
<br><a name="1436"></a>        <a style="color:green" href="heap.html#119">HeapPopStackFrame</a>(<a href="expression.html#144">Parser</a>->pc);
<br><a name="1437"></a>    }
<br><a name="1438"></a>}
<br><a name="1439"></a>
<br><a name="1440"></a>/* do a function call */
<br><a name="1441"></a>void ExpressionParseFunctionCall(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>, <font color="blue">struct </font><a href="expression.html#35">ExpressionStack</a> **<a href="expression.html#283">StackTop</a>, const <font color="blue">char </font>*<a href="expression.html#353">FuncName</a>, <font color="blue">int </font>RunIt)
<br><a name="1442"></a>{
<br><a name="1443"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Return<a href="interpreter_header.html#217">Value</a> = NULL;
<br><a name="1444"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Func<a href="interpreter_header.html#217">Value</a> = NULL;
<br><a name="1445"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="expression.html#1362">Param</a>;
<br><a name="1446"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> **<a href="expression.html#1363">ParamArray</a> = NULL;
<br><a name="1447"></a>    <font color="blue">int </font><a href="expression.html#1364">ArgCount</a>;
<br><a name="1448"></a>    enum Lex<a href="expression.html#1019">Token</a> <a href="expression.html#1019">Token</a> = LexGet<a href="expression.html#1019">Token</a>(<a href="expression.html#144">Parser</a>, NULL, TRUE);    /* open bracket */
<br><a name="1449"></a>    enum RunMode OldMode = <a href="expression.html#144">Parser</a>->Mode;
<br><a name="1450"></a>    
<br><a name="1451"></a>    <font color="red">if </font>(<a href="expression.html#1441">RunIt</a>)
<br><a name="1452"></a>    { 
<br><a name="1453"></a>        /* get the function definition */
<br><a name="1454"></a>        <a style="color:green" href="variable.html#360">VariableGet</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, <a href="expression.html#353">FuncName</a>, &FuncValue);
<br><a name="1455"></a>        
<br><a name="1456"></a>        <font color="red">if </font>(<a href="expression.html#1444">FuncValue</a>->Typ->Base == TypeMacro)
<br><a name="1457"></a>        {
<br><a name="1458"></a>            /* this is actually a macro, not a function */
<br><a name="1459"></a>            <a style="color:green" href="expression.html#1359">ExpressionParseMacroCall</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#353">FuncName</a>, &FuncValue->Val->MacroDef);
<br><a name="1460"></a>            return;
<br><a name="1461"></a>        }
<br><a name="1462"></a>        
<br><a name="1463"></a>        <font color="red">if </font>(<a href="expression.html#1444">FuncValue</a>->Typ->Base != TypeFunction)
<br><a name="1464"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "%t is not a function - can't call", <a href="expression.html#1444">FuncValue</a>->Typ);
<br><a name="1465"></a>    
<br><a name="1466"></a>        <a style="color:green" href="expression.html#299">ExpressionStackPushValueByType</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, <a href="expression.html#1444">FuncValue</a>->Val->FuncDef.ReturnType);
<br><a name="1467"></a>        <a href="expression.html#1361">ReturnValue</a> = (*<a href="expression.html#283">StackTop</a>)->Val;
<br><a name="1468"></a>        <a style="color:green" href="heap.html#108">HeapPushStackFrame</a>(<a href="expression.html#144">Parser</a>->pc);
<br><a name="1469"></a>        <a href="expression.html#1363">ParamArray</a> = <a style="color:green" href="heap.html#67">HeapAllocStack</a>(<a href="expression.html#144">Parser</a>->pc, sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *) * Func<a href="interpreter_header.html#217">Value</a>->Val->FuncDef.NumParams);    
<br><a name="1470"></a>        <font color="red">if </font>(<a href="expression.html#1363">ParamArray</a> == NULL)
<br><a name="1471"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "out of memory");
<br><a name="1472"></a>    }
<br><a name="1473"></a>    else
<br><a name="1474"></a>    {
<br><a name="1475"></a>        <a style="color:green" href="expression.html#336">ExpressionPushInt</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#283">StackTop</a>, 0);
<br><a name="1476"></a>        <a href="expression.html#144">Parser</a>->Mode = RunModeSkip;
<br><a name="1477"></a>    }
<br><a name="1478"></a>        
<br><a name="1479"></a>    /* parse arguments */
<br><a name="1480"></a>    <a href="expression.html#1364">ArgCount</a> = 0;
<br><a name="1481"></a>    do {
<br><a name="1482"></a>        <font color="red">if </font>(<a href="expression.html#1441">RunIt</a> && <a href="expression.html#1364">ArgCount</a> &lt; <a href="expression.html#1444">FuncValue</a>-&gt;Val-&gt;FuncDef.NumParams)
<br><a name="1483"></a>            ParamArray<font color="red">[</font>ArgCount<font color="red">]</font> = <a style="color:green" href="variable.html#107">VariableAllocValueFromType</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, <a href="expression.html#1444">FuncValue</a>->Val->FuncDef.ParamType<font color="red">[</font>ArgCount<font color="red">]</font>, FALSE, NULL, FALSE);
<br><a name="1484"></a>        
<br><a name="1485"></a>        <font color="red">if </font>(<a style="color:green" href="expression.html#1077">ExpressionParse</a>(<a href="expression.html#144">Parser</a>, &Param))
<br><a name="1486"></a>        {
<br><a name="1487"></a>            <font color="red">if </font>(<a href="expression.html#1441">RunIt</a>)
<br><a name="1488"></a>            { 
<br><a name="1489"></a>                <font color="red">if </font>(<a href="expression.html#1364">ArgCount</a> &lt; <a href="expression.html#1444">FuncValue</a>-&gt;Val-&gt;FuncDef.NumParams)
<br><a name="1490"></a>                {
<br><a name="1491"></a>                    <a style="color:green" href="expression.html#391">ExpressionAssign</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#1362">Param</a>Array<font color="red">[</font><a href="expression.html#1364">ArgCount</a><font color="red">]</font>, <a href="expression.html#1362">Param</a>, TRUE, <a href="expression.html#353">FuncName</a>, <a href="expression.html#1364">ArgCount</a>+1, FALSE);
<br><a name="1492"></a>                    <a style="color:green" href="variable.html#386">VariableStackPop</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#1362">Param</a>);
<br><a name="1493"></a>                }
<br><a name="1494"></a>                else
<br><a name="1495"></a>                {
<br><a name="1496"></a>                    <font color="red">if </font>(!FuncValue->Val->FuncDef.VarArgs)
<br><a name="1497"></a>                        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "too many arguments to %s()", <a href="expression.html#353">FuncName</a>);
<br><a name="1498"></a>                }
<br><a name="1499"></a>            }
<br><a name="1500"></a>            
<br><a name="1501"></a>            <a href="expression.html#1364">ArgCount</a>++;
<br><a name="1502"></a>            <a href="expression.html#1019">Token</a> = LexGet<a href="expression.html#1019">Token</a>(<a href="expression.html#144">Parser</a>, NULL, TRUE);
<br><a name="1503"></a>            <font color="red">if </font>(<a href="expression.html#1019">Token</a> != <a href="expression.html#1019">Token</a>Comma && <a href="expression.html#1019">Token</a> != <a href="expression.html#1019">Token</a>CloseBracket)
<br><a name="1504"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "comma expected");
<br><a name="1505"></a>        }
<br><a name="1506"></a>        else
<br><a name="1507"></a>        { 
<br><a name="1508"></a>            /* end of argument list? */
<br><a name="1509"></a>            <a href="expression.html#1019">Token</a> = LexGet<a href="expression.html#1019">Token</a>(<a href="expression.html#144">Parser</a>, NULL, TRUE);
<br><a name="1510"></a>            <font color="red">if </font>(!TokenCloseBracket)
<br><a name="1511"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "bad argument");
<br><a name="1512"></a>        }
<br><a name="1513"></a>        
<br><a name="1514"></a>    } <font color="red">while </font>(<a href="expression.html#1019">Token</a> != <a href="expression.html#1019">Token</a>CloseBracket);
<br><a name="1515"></a>    
<br><a name="1516"></a>    <font color="red">if </font>(<a href="expression.html#1441">RunIt</a>) 
<br><a name="1517"></a>    { 
<br><a name="1518"></a>        /* run the function */
<br><a name="1519"></a>        <font color="red">if </font>(<a href="expression.html#1364">ArgCount</a> &lt; <a href="expression.html#1444">FuncValue</a>-&gt;Val-&gt;FuncDef.NumParams)
<br><a name="1520"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "not enough arguments to '%s'", <a href="expression.html#353">FuncName</a>);
<br><a name="1521"></a>        
<br><a name="1522"></a>        <font color="red">if </font>(<a href="expression.html#1444">FuncValue</a>->Val->FuncDef.Intrinsic == NULL)
<br><a name="1523"></a>        { 
<br><a name="1524"></a>            /* run a user-defined function */
<br><a name="1525"></a>            <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> FuncParser;
<br><a name="1526"></a>            <font color="blue">int </font><a href="expression.html#1416">Count</a>;
<br><a name="1527"></a>            <font color="blue">int </font>OldScopeID = <a href="expression.html#144">Parser</a>->ScopeID;
<br><a name="1528"></a>            
<br><a name="1529"></a>            <font color="red">if </font>(<a href="expression.html#1444">FuncValue</a>->Val->FuncDef.Body.Pos == NULL)
<br><a name="1530"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "'%s' is undefined", <a href="expression.html#353">FuncName</a>);
<br><a name="1531"></a>            
<br><a name="1532"></a>            <a style="color:green" href="parse.html#429">ParserCopy</a>(&FuncParser, &FuncValue->Val->FuncDef.Body);
<br><a name="1533"></a>            <a style="color:green" href="variable.html#412">VariableStackFrameAdd</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#353">FuncName</a>, <a href="expression.html#1444">FuncValue</a>->Val->FuncDef.Intrinsic ? <a href="expression.html#1444">FuncValue</a>->Val->FuncDef.NumParams : 0);
<br><a name="1534"></a>            <a href="expression.html#144">Parser</a>->pc->TopStackFrame->NumParams = <a href="expression.html#1364">ArgCount</a>;
<br><a name="1535"></a>            <a href="expression.html#144">Parser</a>->pc->TopStackFrame-><a href="expression.html#1361">ReturnValue</a> = <a href="expression.html#1361">ReturnValue</a>;
<br><a name="1536"></a>
<br><a name="1537"></a>            /* Function parameters should not go out of scope */
<br><a name="1538"></a>            <a href="expression.html#144">Parser</a>->ScopeID = -1;
<br><a name="1539"></a>
<br><a name="1540"></a>            <font color="red">for </font>(<a href="expression.html#1416">Count</a> = 0; <a href="expression.html#1416">Count</a> &lt; <a href="expression.html#1444">FuncValue</a>-&gt;Val-&gt;FuncDef.NumParams; <a href="expression.html#1416">Count</a>++)
<br><a name="1541"></a>                <a style="color:green" href="variable.html#259">VariableDefine</a>(<a href="expression.html#144">Parser</a>->pc, <a href="expression.html#144">Parser</a>, <a href="expression.html#1444">FuncValue</a>->Val->FuncDef.ParamName<font color="red">[</font>Count<font color="red">]</font>, ParamArray<font color="red">[</font>Count<font color="red">]</font>, NULL, TRUE);
<br><a name="1542"></a>
<br><a name="1543"></a>            <a href="expression.html#144">Parser</a>->ScopeID = <a href="expression.html#1527">OldScopeID</a>;
<br><a name="1544"></a>                
<br><a name="1545"></a>            <font color="red">if </font>(<a style="color:green" href="parse.html#568">ParseStatement</a>(&FuncParser, TRUE) != ParseResultOk)
<br><a name="1546"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(&FuncParser, "function body expected");
<br><a name="1547"></a>            
<br><a name="1548"></a>            <font color="red">if </font>(<a href="expression.html#1441">RunIt</a>)
<br><a name="1549"></a>            {
<br><a name="1550"></a>                <font color="red">if </font>(<a href="expression.html#1525">FuncParser</a>.Mode == RunModeRun && <a href="expression.html#1444">FuncValue</a>->Val->FuncDef.ReturnType != &Parser->pc->VoidType)
<br><a name="1551"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(&FuncParser, "no value returned from a function returning %t", <a href="expression.html#1444">FuncValue</a>->Val->FuncDef.ReturnType);
<br><a name="1552"></a>
<br><a name="1553"></a>                else <font color="red">if </font>(<a href="expression.html#1525">FuncParser</a>.Mode == RunModeGoto)
<br><a name="1554"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(&<a href="expression.html#1525">FuncParser</a>, "couldn't find <font color="red">goto </font>label '%s'", <a href="expression.html#1525">FuncParser</a>.SearchGotoLabel);
<br><a name="1555"></a>            }
<br><a name="1556"></a>            
<br><a name="1557"></a>            <a style="color:green" href="variable.html#430">VariableStackFramePop</a>(<a href="expression.html#144">Parser</a>);
<br><a name="1558"></a>        }
<br><a name="1559"></a>        else
<br><a name="1560"></a>            <a href="expression.html#1444">FuncValue</a>->Val->FuncDef.Intrinsic(<a href="expression.html#144">Parser</a>, <a href="expression.html#1361">ReturnValue</a>, <a href="expression.html#1363">ParamArray</a>, <a href="expression.html#1364">ArgCount</a>);
<br><a name="1561"></a>
<br><a name="1562"></a>        <a style="color:green" href="heap.html#119">HeapPopStackFrame</a>(<a href="expression.html#144">Parser</a>->pc);
<br><a name="1563"></a>    }
<br><a name="1564"></a>
<br><a name="1565"></a>    <a href="expression.html#144">Parser</a>->Mode = <a href="expression.html#1449">OldMode</a>;
<br><a name="1566"></a>}
<br><a name="1567"></a>
<br><a name="1568"></a>/* parse an expression */
<br><a name="1569"></a><font color="blue">long </font>ExpressionParseInt(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="expression.html#144">Parser</a>)
<br><a name="1570"></a>{
<br><a name="1571"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217"><a href="expression.html#164">Val</a>ue</a> *<a href="expression.html#164">Val</a>;
<br><a name="1572"></a>    <font color="blue">long </font><a href="expression.html#245">Result</a> = 0;
<br><a name="1573"></a>    
<br><a name="1574"></a>    <font color="red">if </font>(!ExpressionParse(<a href="expression.html#144">Parser</a>, &Val))
<br><a name="1575"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "expression expected");
<br><a name="1576"></a>    
<br><a name="1577"></a>    <font color="red">if </font>(<a href="expression.html#144">Parser</a>->Mode == RunModeRun)
<br><a name="1578"></a>    { 
<br><a name="1579"></a>        <font color="red">if </font>(!IS_NUMERIC_COERCIBLE(<a href="expression.html#164">Val</a>))
<br><a name="1580"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="expression.html#144">Parser</a>, "integer value expected instead of %t", <a href="expression.html#164">Val</a>->Typ);
<br><a name="1581"></a>    
<br><a name="1582"></a>        <a href="expression.html#245">Result</a> = <a style="color:green" href="expression.html#164">ExpressionCoerceInteger</a>(<a href="expression.html#164">Val</a>);
<br><a name="1583"></a>        <a style="color:green" href="variable.html#386">VariableStackPop</a>(<a href="expression.html#144">Parser</a>, <a href="expression.html#164">Val</a>);
<br><a name="1584"></a>    }
<br><a name="1585"></a>    
<br><a name="1586"></a>    <font color="red">return </font><a href="expression.html#245">Result</a>;
<br><a name="1587"></a>}
<br><a name="1588"></a>
<br><a name="1589"></a></html>