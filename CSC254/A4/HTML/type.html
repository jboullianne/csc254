<html><a name="1"></a>/* picoc data type module. This manages a tree of data types and has facilities
<br><a name="2"></a> * <font color="red">for </font>parsing data types. */
<br><a name="3"></a> 
<br><a name="4"></a>#<font color="red">include </font>"interpreter.h"
<br><a name="5"></a>
<br><a name="6"></a>/* some basic types */
<br><a name="7"></a>static <font color="blue">int </font>PointerAlignBytes;
<br><a name="8"></a>static <font color="blue">int </font>IntAlignBytes;
<br><a name="9"></a>
<br><a name="10"></a>
<br><a name="11"></a>/* add a new type to the set of types we know about */
<br><a name="12"></a><font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *TypeAdd(<a href="interpreter_header.html#61">Picoc</a> *<a href="type.html#187">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *Parser, <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *ParentType, enum BaseType Base, <font color="blue">int </font><a href="type.html#452">ArraySize</a>, const <font color="blue">char </font>*Identifier, <font color="blue">int </font><a href="type.html#34">Sizeof</a>, <font color="blue">int </font><a href="type.html#35">AlignBytes</a>)
<br><a name="13"></a>{
<br><a name="14"></a>    <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *NewType = <a style="color:green" href="variable.html#68">VariableAlloc</a>(<a href="type.html#12">pc</a>, <a href="type.html#12">Parser</a>, sizeof(<font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a>), TRUE);
<br><a name="15"></a>    <a href="type.html#14">NewType</a>-><a href="type.html#12">Base</a> = <a href="type.html#12">Base</a>;
<br><a name="16"></a>    <a href="type.html#14">NewType</a>-><a href="type.html#12">ArraySize</a> = <a href="type.html#12">ArraySize</a>;
<br><a name="17"></a>    <a href="type.html#14">NewType</a>-><a href="type.html#12">Sizeof</a> = <a href="type.html#12">Sizeof</a>;
<br><a name="18"></a>    <a href="type.html#14">NewType</a>-><a href="type.html#12">AlignBytes</a> = <a href="type.html#12">AlignBytes</a>;
<br><a name="19"></a>    <a href="type.html#14">NewType</a>-><a href="type.html#12">Identifier</a> = <a href="type.html#12">Identifier</a>;
<br><a name="20"></a>    <a href="type.html#14">NewType</a>->Members = NULL;
<br><a name="21"></a>    <a href="type.html#14">NewType</a>->FromType = <a href="type.html#12">ParentType</a>;
<br><a name="22"></a>    <a href="type.html#14">NewType</a>->DerivedTypeList = NULL;
<br><a name="23"></a>    <a href="type.html#14">NewType</a>->OnHeap = TRUE;
<br><a name="24"></a>    <a href="type.html#14">NewType</a>->Next = <a href="type.html#12">ParentType</a>->DerivedTypeList;
<br><a name="25"></a>    <a href="type.html#12">ParentType</a>->DerivedTypeList = <a href="type.html#14">NewType</a>;
<br><a name="26"></a>    
<br><a name="27"></a>    <font color="red">return </font><a href="type.html#14">NewType</a>;
<br><a name="28"></a>}
<br><a name="29"></a>
<br><a name="30"></a>/* given a parent type, get a matching derived type and make one <font color="red">if </font>necessary.
<br><a name="31"></a> * <a href="type.html#12">Identifier</a> should be registered with the shared string table. */
<br><a name="32"></a><font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *TypeGetMatching(<a href="interpreter_header.html#61">Picoc</a> *<a href="type.html#12">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="type.html#12">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *<a href="type.html#12">ParentType</a>, enum <a href="type.html#12">Base</a>Type <a href="type.html#12">Base</a>, <font color="blue">int </font><a href="type.html#12">ArraySize</a>, const <font color="blue">char </font>*<a href="type.html#12">Identifier</a>, <font color="blue">int </font>AllowDuplicates)
<br><a name="33"></a>{
<br><a name="34"></a>    <font color="blue">int </font><a href="type.html#12">Sizeof</a>;
<br><a name="35"></a>    <font color="blue">int </font><a href="type.html#12">AlignBytes</a>;
<br><a name="36"></a>    <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *ThisType = <a href="type.html#12">ParentType</a>->DerivedTypeList;
<br><a name="37"></a>    <font color="red">while </font>(<a href="type.html#36">ThisType</a> != NULL && (<a href="type.html#36">ThisType</a>-><a href="type.html#12">Base</a> != <a href="type.html#12">Base</a> || <a href="type.html#36">ThisType</a>-><a href="type.html#12">ArraySize</a> != <a href="type.html#12">ArraySize</a> || <a href="type.html#36">ThisType</a>-><a href="type.html#12">Identifier</a> != <a href="type.html#12">Identifier</a>))
<br><a name="38"></a>        <a href="type.html#36">ThisType</a> = <a href="type.html#36">ThisType</a>->Next;
<br><a name="39"></a>    
<br><a name="40"></a>    <font color="red">if </font>(<a href="type.html#36">ThisType</a> != NULL)
<br><a name="41"></a>    {
<br><a name="42"></a>        <font color="red">if </font>(<a href="type.html#32">AllowDuplicates</a>)
<br><a name="43"></a>            <font color="red">return </font><a href="type.html#36">ThisType</a>;
<br><a name="44"></a>        else
<br><a name="45"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "data type '%s' is already defined", <a href="type.html#12">Identifier</a>);
<br><a name="46"></a>    }
<br><a name="47"></a>        
<br><a name="48"></a>    switch (<a href="type.html#12">Base</a>)
<br><a name="49"></a>    {
<br><a name="50"></a>        case TypePointer:   <a href="type.html#12">Sizeof</a> = sizeof(void *); <a href="type.html#12">AlignBytes</a> = Pointer<a href="type.html#12">AlignBytes</a>; break;
<br><a name="51"></a>        case TypeArray:     <a href="type.html#12">Sizeof</a> = <a href="type.html#12">ArraySize</a> * <a href="type.html#12">ParentType</a>-><a href="type.html#12">Sizeof</a>; <a href="type.html#12">AlignBytes</a> = <a href="type.html#12">ParentType</a>-><a href="type.html#12">AlignBytes</a>; break;
<br><a name="52"></a>        case TypeEnum:      <a href="type.html#12">Sizeof</a> = sizeof(int); <a href="type.html#12">AlignBytes</a> = Int<a href="type.html#12">AlignBytes</a>; break;
<br><a name="53"></a>        default:            <a href="type.html#12">Sizeof</a> = 0; <a href="type.html#12">AlignBytes</a> = 0; break;      /* structs and unions will get bigger when we add members to them */
<br><a name="54"></a>    }
<br><a name="55"></a>
<br><a name="56"></a>    <font color="red">return </font><a style="color:green" href="type.html#12">TypeAdd</a>(<a href="type.html#12">pc</a>, <a href="type.html#12">Parser</a>, <a href="type.html#12">ParentType</a>, <a href="type.html#12">Base</a>, <a href="type.html#12">ArraySize</a>, <a href="type.html#12">Identifier</a>, <a href="type.html#12">Sizeof</a>, <a href="type.html#12">AlignBytes</a>);
<br><a name="57"></a>}
<br><a name="58"></a>
<br><a name="59"></a>/* stack space used by a value */
<br><a name="60"></a><font color="blue">int </font>TypeStackSize<a href="interpreter_header.html#217">Value</a>(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Val)
<br><a name="61"></a>{
<br><a name="62"></a>    <font color="red">if </font>(<a href="type.html#60">Val</a> != NULL && <a href="type.html#60">Val</a>-><a href="type.html#60">Val</a>OnStack)
<br><a name="63"></a>        <font color="red">return </font><a style="color:green" href="type.html#69">TypeSize<a href="type.html#60">Val</a>ue</a>(<a href="type.html#60">Val</a>, FALSE);
<br><a name="64"></a>    else
<br><a name="65"></a>        <font color="red">return </font>0;
<br><a name="66"></a>}
<br><a name="67"></a>
<br><a name="68"></a>/* memory used by a value */
<br><a name="69"></a><font color="blue">int </font>TypeSize<a href="interpreter_header.html#217"><a href="type.html#60">Val</a>ue</a>(<font color="blue">struct </font><a href="interpreter_header.html#217"><a href="type.html#60">Val</a>ue</a> *<a href="type.html#60">Val</a>, <font color="blue">int </font>Compact)
<br><a name="70"></a>{
<br><a name="71"></a>    <font color="red">if </font>(IS_INTEGER_NUMERIC(<a href="type.html#60">Val</a>) && !Compact)
<br><a name="72"></a>        <font color="red">return </font>sizeof(ALIGN_TYPE);     /* allow some extra room <font color="red">for </font>type extension */
<br><a name="73"></a>    else <font color="red">if </font>(<a href="type.html#60">Val</a>->Typ->Base != TypeArray)
<br><a name="74"></a>        <font color="red">return </font><a href="type.html#60">Val</a>->Typ->Sizeof;
<br><a name="75"></a>    else
<br><a name="76"></a>        <font color="red">return </font><a href="type.html#60">Val</a>->Typ->FromType->Sizeof * <a href="type.html#60">Val</a>->Typ->ArraySize;
<br><a name="77"></a>}
<br><a name="78"></a>
<br><a name="79"></a>/* memory used by a variable given its type and array size */
<br><a name="80"></a><font color="blue">int </font><a href="type.html#274">Typ</a>eSize(<font color="blue">struct </font><a href="interpreter_header.html#160">Value<a href="type.html#274">Typ</a>e</a> *<a href="type.html#274">Typ</a>, <font color="blue">int </font><a href="type.html#12">ArraySize</a>, <font color="blue">int </font><a href="type.html#69">Compact</a>)
<br><a name="81"></a>{
<br><a name="82"></a>    <font color="red">if </font>(IS_INTEGER_NUMERIC_TYPE(<a href="type.html#80">Typ</a>) && !Compact)
<br><a name="83"></a>        <font color="red">return </font>sizeof(ALIGN_TYPE);     /* allow some extra room <font color="red">for </font>type extension */
<br><a name="84"></a>    else <font color="red">if </font>(<a href="type.html#80">Typ</a>->Base != <a href="type.html#80">Typ</a>eArray)
<br><a name="85"></a>        <font color="red">return </font><a href="type.html#80">Typ</a>->Sizeof;
<br><a name="86"></a>    else
<br><a name="87"></a>        <font color="red">return </font><a href="type.html#80">Typ</a>->From<a href="type.html#80">Typ</a>e->Sizeof * <a href="type.html#12">ArraySize</a>;
<br><a name="88"></a>}
<br><a name="89"></a>
<br><a name="90"></a>/* add a base type */
<br><a name="91"></a>void TypeAdd<a href="type.html#12">Base</a>Type(<a href="interpreter_header.html#61">Picoc</a> *<a href="type.html#12">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *TypeNode, enum <a href="type.html#12">Base</a>Type <a href="type.html#12">Base</a>, <font color="blue">int </font><a href="type.html#12">Sizeof</a>, <font color="blue">int </font><a href="type.html#12">AlignBytes</a>)
<br><a name="92"></a>{
<br><a name="93"></a>    <a href="type.html#91">TypeNode</a>-><a href="type.html#12">Base</a> = <a href="type.html#12">Base</a>;
<br><a name="94"></a>    <a href="type.html#91">TypeNode</a>->ArraySize = 0;
<br><a name="95"></a>    <a href="type.html#91">TypeNode</a>-><a href="type.html#12">Sizeof</a> = <a href="type.html#12">Sizeof</a>;
<br><a name="96"></a>    <a href="type.html#91">TypeNode</a>-><a href="type.html#12">AlignBytes</a> = <a href="type.html#12">AlignBytes</a>;
<br><a name="97"></a>    <a href="type.html#91">TypeNode</a>->Identifier = <a href="type.html#12">pc</a>->StrEmpty;
<br><a name="98"></a>    <a href="type.html#91">TypeNode</a>->Members = NULL;
<br><a name="99"></a>    <a href="type.html#91">TypeNode</a>->FromType = NULL;
<br><a name="100"></a>    <a href="type.html#91">TypeNode</a>->DerivedTypeList = NULL;
<br><a name="101"></a>    <a href="type.html#91">TypeNode</a>->OnHeap = FALSE;
<br><a name="102"></a>    <a href="type.html#91">TypeNode</a>->Next = <a href="type.html#12">pc</a>->UberType.DerivedTypeList;
<br><a name="103"></a>    <a href="type.html#12">pc</a>->UberType.DerivedTypeList = <a href="type.html#91">TypeNode</a>;
<br><a name="104"></a>}
<br><a name="105"></a>
<br><a name="106"></a>/* initialise the type system */
<br><a name="107"></a>void TypeInit(<a href="interpreter_header.html#61">Picoc</a> *<a href="type.html#12">pc</a>)
<br><a name="108"></a>{
<br><a name="109"></a>    <font color="blue">struct </font>IntAlign { <font color="blue">char </font>x; <font color="blue">int </font>y; } ia;
<br><a name="110"></a>    <font color="blue">struct </font>ShortAlign { <font color="blue">char </font>x; <font color="blue">short </font>y; } sa;
<br><a name="111"></a>    <font color="blue">struct </font>CharAlign { <font color="blue">char </font>x; <font color="blue">char </font>y; } ca;
<br><a name="112"></a>    <font color="blue">struct </font>LongAlign { <font color="blue">char </font>x; <font color="blue">long </font>y; } la;
<br><a name="113"></a>#ifndef NO_FP
<br><a name="114"></a>    <font color="blue">struct </font>DoubleAlign { <font color="blue">char </font>x; <font color="blue">double </font>y; } da;
<br><a name="115"></a>#endif
<br><a name="116"></a>    <font color="blue">struct </font>PointerAlign { <font color="blue">char </font>x; void *y; } pa;
<br><a name="117"></a>    
<br><a name="118"></a>    <a href="type.html#8">IntAlignBytes</a> = (<font color="blue">char </font>*)&ia.y - &ia.x;
<br><a name="119"></a>    <a href="type.html#7">PointerAlignBytes</a> = (<font color="blue">char </font>*)&pa.y - &pa.x;
<br><a name="120"></a>    
<br><a name="121"></a>    <a href="type.html#12">pc</a>->UberType.DerivedTypeList = NULL;
<br><a name="122"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->IntType, TypeInt, sizeof(int), <a href="type.html#8">IntAlignBytes</a>);
<br><a name="123"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->ShortType, TypeShort, sizeof(short), (<font color="blue">char </font>*)&sa.y - &sa.x);
<br><a name="124"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->CharType, TypeChar, sizeof(char), (<font color="blue">char </font>*)&ca.y - &ca.x);
<br><a name="125"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->LongType, TypeLong, sizeof(long), (<font color="blue">char </font>*)&la.y - &la.x);
<br><a name="126"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->UnsignedIntType, TypeUnsignedInt, sizeof(<font color="blue">unsigned </font>int), <a href="type.html#8">IntAlignBytes</a>);
<br><a name="127"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->UnsignedShortType, TypeUnsignedShort, sizeof(<font color="blue">unsigned </font>short), (<font color="blue">char </font>*)&sa.y - &sa.x);
<br><a name="128"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->UnsignedLongType, TypeUnsignedLong, sizeof(<font color="blue">unsigned </font>long), (<font color="blue">char </font>*)&la.y - &la.x);
<br><a name="129"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->UnsignedCharType, TypeUnsignedChar, sizeof(<font color="blue">unsigned </font>char), (<font color="blue">char </font>*)&ca.y - &ca.x);
<br><a name="130"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->VoidType, TypeVoid, 0, 1);
<br><a name="131"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->FunctionType, TypeFunction, sizeof(int), <a href="type.html#8">IntAlignBytes</a>);
<br><a name="132"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->MacroType, TypeMacro, sizeof(int), <a href="type.html#8">IntAlignBytes</a>);
<br><a name="133"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->GotoLabelType, TypeGotoLabel, 0, 1);
<br><a name="134"></a>#ifndef NO_FP
<br><a name="135"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->FPType, TypeFP, sizeof(double), (<font color="blue">char </font>*)&da.y - &da.x);
<br><a name="136"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->TypeType, Type_Type, sizeof(double), (<font color="blue">char </font>*)&da.y - &da.x);  /* must be large enough to cast to a <font color="blue">double </font>*/
<br><a name="137"></a>#else
<br><a name="138"></a>    <a style="color:green" href="type.html#91">TypeAddBaseType</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->TypeType, Type_Type, sizeof(<font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *), <a href="type.html#7">PointerAlignBytes</a>);
<br><a name="139"></a>#endif
<br><a name="140"></a>    <a href="type.html#12">pc</a>->CharArrayType = <a style="color:green" href="type.html#12">TypeAdd</a>(<a href="type.html#12">pc</a>, NULL, &<a href="type.html#12">pc</a>->CharType, TypeArray, 0, <a href="type.html#12">pc</a>->StrEmpty, sizeof(char), (<font color="blue">char </font>*)&ca.y - &ca.x);
<br><a name="141"></a>    <a href="type.html#12">pc</a>->CharPtrType = <a style="color:green" href="type.html#12">TypeAdd</a>(<a href="type.html#12">pc</a>, NULL, &<a href="type.html#12">pc</a>->CharType, TypePointer, 0, <a href="type.html#12">pc</a>->StrEmpty, sizeof(void *), <a href="type.html#7">PointerAlignBytes</a>);
<br><a name="142"></a>    <a href="type.html#12">pc</a>->CharPtrPtrType = <a style="color:green" href="type.html#12">TypeAdd</a>(<a href="type.html#12">pc</a>, NULL, <a href="type.html#12">pc</a>->CharPtrType, TypePointer, 0, <a href="type.html#12">pc</a>->StrEmpty, sizeof(void *), <a href="type.html#7">PointerAlignBytes</a>);
<br><a name="143"></a>    <a href="type.html#12">pc</a>->VoidPtrType = <a style="color:green" href="type.html#12">TypeAdd</a>(<a href="type.html#12">pc</a>, NULL, &<a href="type.html#12">pc</a>->VoidType, TypePointer, 0, <a href="type.html#12">pc</a>->StrEmpty, sizeof(void *), <a href="type.html#7">PointerAlignBytes</a>);
<br><a name="144"></a>}
<br><a name="145"></a>
<br><a name="146"></a>/* deallocate heap-allocated types */
<br><a name="147"></a>void <a href="type.html#80">Typ</a>eCleanupNode(<a href="interpreter_header.html#61">Picoc</a> *<a href="type.html#12">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">Value<a href="type.html#80">Typ</a>e</a> *<a href="type.html#80">Typ</a>)
<br><a name="148"></a>{
<br><a name="149"></a>    <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *SubType;
<br><a name="150"></a>    <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *NextSubType;
<br><a name="151"></a>    
<br><a name="152"></a>    /* clean up and free all the sub-nodes */
<br><a name="153"></a>    <font color="red">for </font>(<a href="type.html#149">Sub<a href="type.html#80">Typ</a>e</a> = <a href="type.html#80">Typ</a>->Derived<a href="type.html#80">Typ</a>eList; <a href="type.html#149">Sub<a href="type.html#80">Typ</a>e</a> != NULL; <a href="type.html#149">Sub<a href="type.html#80">Typ</a>e</a> = Next<a href="type.html#149">Sub<a href="type.html#80">Typ</a>e</a>)
<br><a name="154"></a>    {
<br><a name="155"></a>        <a href="type.html#150">Next<a href="type.html#149">SubType</a></a> = <a href="type.html#149">SubType</a>->Next;
<br><a name="156"></a>        <a style="color:green" href="type.html#147">TypeCleanupNode</a>(<a href="type.html#12">pc</a>, <a href="type.html#149">SubType</a>);
<br><a name="157"></a>        <font color="red">if </font>(<a href="type.html#149">SubType</a>->OnHeap)
<br><a name="158"></a>        {
<br><a name="159"></a>            /* <font color="red">if </font>it's a <font color="blue">struct </font>or union deallocate all the member values */
<br><a name="160"></a>            <font color="red">if </font>(<a href="type.html#149">SubType</a>->Members != NULL)
<br><a name="161"></a>            {
<br><a name="162"></a>                <a style="color:green" href="variable.html#42">VariableTableCleanup</a>(<a href="type.html#12">pc</a>, <a href="type.html#149">SubType</a>->Members);
<br><a name="163"></a>                <a style="color:green" href="heap.html#226">HeapFreeMem</a>(<a href="type.html#12">pc</a>, <a href="type.html#149">SubType</a>->Members);
<br><a name="164"></a>            }
<br><a name="165"></a>
<br><a name="166"></a>            /* free this node */
<br><a name="167"></a>            <a style="color:green" href="heap.html#226">HeapFreeMem</a>(<a href="type.html#12">pc</a>, <a href="type.html#149">SubType</a>);
<br><a name="168"></a>        }
<br><a name="169"></a>    }
<br><a name="170"></a>}
<br><a name="171"></a>
<br><a name="172"></a>void TypeCleanup(<a href="interpreter_header.html#61">Picoc</a> *<a href="type.html#12">pc</a>)
<br><a name="173"></a>{
<br><a name="174"></a>    <a style="color:green" href="type.html#147">TypeCleanupNode</a>(<a href="type.html#12">pc</a>, &<a href="type.html#12">pc</a>->UberType);
<br><a name="175"></a>}
<br><a name="176"></a>
<br><a name="177"></a>/* parse a <font color="blue">struct </font>or union declaration */
<br><a name="178"></a>void <a href="type.html#80">Typ</a>eParseStruct(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="type.html#12">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">Value<a href="type.html#80">Typ</a>e</a> **<a href="type.html#80">Typ</a>, <font color="blue">int </font>IsStruct)
<br><a name="179"></a>{
<br><a name="180"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Lex<a href="interpreter_header.html#217">Value</a>;
<br><a name="181"></a>    <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *MemberType;
<br><a name="182"></a>    <font color="blue">char </font>*MemberIdentifier;
<br><a name="183"></a>    <font color="blue">char </font>*StructIdentifier;
<br><a name="184"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Member<a href="interpreter_header.html#217">Value</a>;
<br><a name="185"></a>    enum Lex<a href="type.html#290">Token</a> <a href="type.html#290">Token</a>;
<br><a name="186"></a>    <font color="blue">int </font>AlignBoundary;
<br><a name="187"></a>    <a href="interpreter_header.html#61">Picoc</a> *<a href="type.html#12">pc</a> = <a href="type.html#12">Parser</a>-><a href="type.html#12">pc</a>;
<br><a name="188"></a>    
<br><a name="189"></a>    <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, &LexValue, FALSE);
<br><a name="190"></a>    <font color="red">if </font>(<a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>Identifier)
<br><a name="191"></a>    {
<br><a name="192"></a>        <a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, &LexValue, TRUE);
<br><a name="193"></a>        <a href="type.html#183">StructIdentifier</a> = <a href="type.html#180">LexValue</a>->Val->Identifier;
<br><a name="194"></a>        <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, NULL, FALSE);
<br><a name="195"></a>    }
<br><a name="196"></a>    else
<br><a name="197"></a>    {
<br><a name="198"></a>        static <font color="blue">char </font>TempNameBuf<font color="red">[</font>7<font color="red">]</font> = "^s0000";
<br><a name="199"></a>        <a href="type.html#183">StructIdentifier</a> = <a style="color:green" href="platform.html#230">PlatformMakeTempName</a>(<a href="type.html#12">pc</a>, <a href="type.html#198">TempNameBuf</a>);
<br><a name="200"></a>    }
<br><a name="201"></a>
<br><a name="202"></a>    *<a href="type.html#80">Typ</a> = <a href="type.html#80">Typ</a>eGetMatching(<a href="type.html#12">pc</a>, <a href="type.html#12">Parser</a>, &<a href="type.html#12">Parser</a>-><a href="type.html#12">pc</a>->Uber<a href="type.html#80">Typ</a>e, <a href="type.html#178">IsStruct</a> ? <a href="type.html#80">Typ</a>eStruct : <a href="type.html#80">Typ</a>eUnion, 0, <a href="type.html#183">StructIdentifier</a>, TRUE);
<br><a name="203"></a>    <font color="red">if </font>(<a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>LeftBrace && (*<a href="type.html#80">Typ</a>)->Members != NULL)
<br><a name="204"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "data type '%t' is already defined", *<a href="type.html#80">Typ</a>);
<br><a name="205"></a>
<br><a name="206"></a>    <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, NULL, FALSE);
<br><a name="207"></a>    <font color="red">if </font>(<a href="type.html#185">Token</a> != <a href="type.html#185">Token</a>LeftBrace)
<br><a name="208"></a>    { 
<br><a name="209"></a>        /* use the already defined structure */
<br><a name="210"></a>#<font color="red">if </font>0
<br><a name="211"></a>        <font color="red">if </font>((*<a href="type.html#80">Typ</a>)->Members == NULL)
<br><a name="212"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "structure '%s' isn't defined", <a href="type.html#180">LexValue</a>->Val->Identifier);
<br><a name="213"></a>#end<font color="red">if </font>           
<br><a name="214"></a>        return;
<br><a name="215"></a>    }
<br><a name="216"></a>    
<br><a name="217"></a>    <font color="red">if </font>(<a href="type.html#12">pc</a>->TopStackFrame != NULL)
<br><a name="218"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "struct/union definitions can only be globals");
<br><a name="219"></a>        
<br><a name="220"></a>    <a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, TRUE);    
<br><a name="221"></a>    (*<a href="type.html#80">Typ</a>)->Members = <a style="color:green" href="variable.html#68">VariableAlloc</a>(<a href="type.html#12">pc</a>, <a href="type.html#12">Parser</a>, sizeof(<font color="blue">struct </font><a href="interpreter_header.html#258">Table</a>) + STRUCT_TABLE_SIZE * sizeof(<font color="blue">struct </font><a href="interpreter_header.html#258">Table</a>Entry), TRUE);
<br><a name="222"></a>    (*<a href="type.html#80">Typ</a>)->Members->Hash<a href="interpreter_header.html#258">Table</a> = (<font color="blue">struct </font><a href="interpreter_header.html#231"><a href="interpreter_header.html#258">Table</a>Entry</a> **)((<font color="blue">char </font>*)(*<a href="type.html#80">Typ</a>)->Members + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#258">Table</a>));
<br><a name="223"></a>    <a style="color:green" href="table.html#32"><a href="interpreter_header.html#258">Table</a>Init<a href="interpreter_header.html#258">Table</a></a>((*<a href="type.html#80">Typ</a>)->Members, (<font color="blue">struct </font><a href="interpreter_header.html#231"><a href="interpreter_header.html#258">Table</a>Entry</a> **)((<font color="blue">char </font>*)(*<a href="type.html#80">Typ</a>)->Members + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#258">Table</a>)), STRUCT_TABLE_SIZE, TRUE);
<br><a name="224"></a>    
<br><a name="225"></a>    do {
<br><a name="226"></a>        <a style="color:green" href="type.html#526">TypeParse</a>(<a href="type.html#12">Parser</a>, &MemberType, &MemberIdentifier, NULL);
<br><a name="227"></a>        <font color="red">if </font>(<a href="type.html#181">MemberType</a> == NULL || <a href="type.html#182">MemberIdentifier</a> == NULL)
<br><a name="228"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "invalid type in struct");
<br><a name="229"></a>        
<br><a name="230"></a>        <a href="type.html#184">MemberValue</a> = <a style="color:green" href="variable.html#89">VariableAllocValueAndData</a>(<a href="type.html#12">pc</a>, <a href="type.html#12">Parser</a>, sizeof(int), FALSE, NULL, TRUE);
<br><a name="231"></a>        <a href="type.html#184">MemberValue</a>->Typ = <a href="type.html#181">MemberType</a>;
<br><a name="232"></a>        <font color="red">if </font>(<a href="type.html#178">IsStruct</a>)
<br><a name="233"></a>        { 
<br><a name="234"></a>            /* allocate this member's location in the <font color="blue">struct </font>*/
<br><a name="235"></a>            <a href="type.html#186">AlignBoundary</a> = <a href="type.html#184">MemberValue</a>->Typ->AlignBytes;
<br><a name="236"></a>            <font color="red">if </font>(((*<a href="type.html#80">Typ</a>)->Sizeof & (<a href="type.html#186">AlignBoundary</a>-1)) != 0)
<br><a name="237"></a>                (*<a href="type.html#80">Typ</a>)->Sizeof += <a href="type.html#186">AlignBoundary</a> - ((*<a href="type.html#80">Typ</a>)->Sizeof & (<a href="type.html#186">AlignBoundary</a>-1));
<br><a name="238"></a>                
<br><a name="239"></a>            <a href="type.html#184">MemberValue</a>->Val->Integer = (*<a href="type.html#80">Typ</a>)->Sizeof;
<br><a name="240"></a>            (*<a href="type.html#80">Typ</a>)->Sizeof += <a href="type.html#80">Typ</a>eSizeValue(<a href="type.html#184">MemberValue</a>, TRUE);
<br><a name="241"></a>        }
<br><a name="242"></a>        else
<br><a name="243"></a>        { 
<br><a name="244"></a>            /* union members always start at 0, make sure it's big enough to hold the largest member */
<br><a name="245"></a>            <a href="type.html#184">MemberValue</a>->Val->Integer = 0;
<br><a name="246"></a>            <font color="red">if </font>(<a href="type.html#184">MemberValue</a>-><a href="type.html#80">Typ</a>->Sizeof > (*<a href="type.html#80">Typ</a>)->Sizeof)
<br><a name="247"></a>                (*<a href="type.html#80">Typ</a>)->Sizeof = <a href="type.html#80">Typ</a>eSizeValue(<a href="type.html#184">MemberValue</a>, TRUE);
<br><a name="248"></a>        }
<br><a name="249"></a>
<br><a name="250"></a>        /* make sure to align to the size of the largest member's alignment */
<br><a name="251"></a>        <font color="red">if </font>((*<a href="type.html#80">Typ</a>)-&gt;AlignBytes &lt; <a href="type.html#184">MemberValue</a>-&gt;<a href="type.html#80">Typ</a>-&gt;AlignBytes)
<br><a name="252"></a>            (*<a href="type.html#80">Typ</a>)->AlignBytes = <a href="type.html#184">MemberValue</a>-><a href="type.html#80">Typ</a>->AlignBytes;
<br><a name="253"></a>        
<br><a name="254"></a>        /* define it */
<br><a name="255"></a>        <font color="red">if </font>(!TableSet(<a href="type.html#12">pc</a>, (*<a href="type.html#80">Typ</a>)->Members, <a href="type.html#182">MemberIdentifier</a>, <a href="type.html#184">MemberValue</a>, <a href="type.html#12">Parser</a>->FileName, <a href="type.html#12">Parser</a>->Line, <a href="type.html#12">Parser</a>->CharacterPos))
<br><a name="256"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "member '%s' already defined", &MemberIdentifier);
<br><a name="257"></a>            
<br><a name="258"></a>        <font color="red">if </font>(<a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, TRUE) != TokenSemicolon)
<br><a name="259"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "semicolon expected");
<br><a name="260"></a>                    
<br><a name="261"></a>    } <font color="red">while </font>(<a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, FALSE) != TokenRightBrace);
<br><a name="262"></a>    
<br><a name="263"></a>    /* now align the structure to the size of its largest member's alignment */
<br><a name="264"></a>    <a href="type.html#186">AlignBoundary</a> = (*<a href="type.html#80">Typ</a>)->AlignBytes;
<br><a name="265"></a>    <font color="red">if </font>(((*<a href="type.html#80">Typ</a>)->Sizeof & (<a href="type.html#186">AlignBoundary</a>-1)) != 0)
<br><a name="266"></a>        (*<a href="type.html#80">Typ</a>)->Sizeof += <a href="type.html#186">AlignBoundary</a> - ((*<a href="type.html#80">Typ</a>)->Sizeof & (<a href="type.html#186">AlignBoundary</a>-1));
<br><a name="267"></a>    
<br><a name="268"></a>    <a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, TRUE);
<br><a name="269"></a>}
<br><a name="270"></a>
<br><a name="271"></a>/* create a system <font color="blue">struct </font>which has no user-visible members */
<br><a name="272"></a><font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *TypeCreateOpaqueStruct(<a href="interpreter_header.html#61">Picoc</a> *<a href="type.html#12">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="type.html#12">Parser</a>, const <font color="blue">char </font>*StructName, <font color="blue">int </font>Size)
<br><a name="273"></a>{
<br><a name="274"></a>    <font color="blue">struct </font><a href="interpreter_header.html#160">Value<a href="type.html#80">Typ</a>e</a> *<a href="type.html#80">Typ</a> = <a href="type.html#80">Typ</a>eGetMatching(<a href="type.html#12">pc</a>, <a href="type.html#12">Parser</a>, &<a href="type.html#12">pc</a>->Uber<a href="type.html#80">Typ</a>e, <a href="type.html#80">Typ</a>eStruct, 0, <a href="type.html#272">StructName</a>, FALSE);
<br><a name="275"></a>    
<br><a name="276"></a>    /* create the (empty) table */
<br><a name="277"></a>    <a href="type.html#80">Typ</a>->Members = <a style="color:green" href="variable.html#68">VariableAlloc</a>(<a href="type.html#12">pc</a>, <a href="type.html#12">Parser</a>, sizeof(<font color="blue">struct </font><a href="interpreter_header.html#258">Table</a>) + STRUCT_TABLE_SIZE * sizeof(<font color="blue">struct </font><a href="interpreter_header.html#258">Table</a>Entry), TRUE);
<br><a name="278"></a>    <a href="type.html#80">Typ</a>->Members->Hash<a href="interpreter_header.html#258">Table</a> = (<font color="blue">struct </font><a href="interpreter_header.html#231"><a href="interpreter_header.html#258">Table</a>Entry</a> **)((<font color="blue">char </font>*)<a href="type.html#80">Typ</a>->Members + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#258">Table</a>));
<br><a name="279"></a>    <a style="color:green" href="table.html#32"><a href="interpreter_header.html#258">Table</a>Init<a href="interpreter_header.html#258">Table</a></a>(<a href="type.html#80">Typ</a>->Members, (<font color="blue">struct </font><a href="interpreter_header.html#231"><a href="interpreter_header.html#258">Table</a>Entry</a> **)((<font color="blue">char </font>*)<a href="type.html#80">Typ</a>->Members + sizeof(<font color="blue">struct </font><a href="interpreter_header.html#258">Table</a>)), STRUCT_TABLE_SIZE, TRUE);
<br><a name="280"></a>    <a href="type.html#80">Typ</a>-><a href="type.html#272">Size</a>of = <a href="type.html#272">Size</a>;
<br><a name="281"></a>    
<br><a name="282"></a>    <font color="red">return </font><a href="type.html#80">Typ</a>;
<br><a name="283"></a>}
<br><a name="284"></a>
<br><a name="285"></a>/* parse an enum declaration */
<br><a name="286"></a>void <a href="type.html#80">Typ</a>eParseEnum(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="type.html#12">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">Value<a href="type.html#80">Typ</a>e</a> **<a href="type.html#80">Typ</a>)
<br><a name="287"></a>{
<br><a name="288"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Lex<a href="interpreter_header.html#217">Value</a>;
<br><a name="289"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> Init<a href="interpreter_header.html#217">Value</a>;
<br><a name="290"></a>    enum Lex<a href="type.html#185">Token</a> <a href="type.html#185">Token</a>;
<br><a name="291"></a>    <font color="blue">int </font>EnumValue = 0;
<br><a name="292"></a>    <font color="blue">char </font>*EnumIdentifier;
<br><a name="293"></a>    <a href="interpreter_header.html#61">Picoc</a> *<a href="type.html#12">pc</a> = <a href="type.html#12">Parser</a>-><a href="type.html#12">pc</a>;
<br><a name="294"></a>    
<br><a name="295"></a>    <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, &LexValue, FALSE);
<br><a name="296"></a>    <font color="red">if </font>(<a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>Identifier)
<br><a name="297"></a>    {
<br><a name="298"></a>        <a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, &LexValue, TRUE);
<br><a name="299"></a>        <a href="type.html#292">EnumIdentifier</a> = <a href="type.html#180">LexValue</a>->Val->Identifier;
<br><a name="300"></a>        <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, NULL, FALSE);
<br><a name="301"></a>    }
<br><a name="302"></a>    else
<br><a name="303"></a>    {
<br><a name="304"></a>        static <font color="blue">char </font>TempNameBuf<font color="red">[</font>7<font color="red">]</font> = "^e0000";
<br><a name="305"></a>        <a href="type.html#292">EnumIdentifier</a> = <a style="color:green" href="platform.html#230">PlatformMakeTempName</a>(<a href="type.html#12">pc</a>, <a href="type.html#198">TempNameBuf</a>);
<br><a name="306"></a>    }
<br><a name="307"></a>
<br><a name="308"></a>    <a style="color:green" href="type.html#32">TypeGetMatching</a>(<a href="type.html#12">pc</a>, <a href="type.html#12">Parser</a>, &<a href="type.html#12">pc</a>->UberType, TypeEnum, 0, <a href="type.html#292">EnumIdentifier</a>, <a href="type.html#185">Token</a> != <a href="type.html#185">Token</a>LeftBrace);
<br><a name="309"></a>    *<a href="type.html#80">Typ</a> = &pc->Int<a href="type.html#80">Typ</a>e;
<br><a name="310"></a>    <font color="red">if </font>(<a href="type.html#185">Token</a> != <a href="type.html#185">Token</a>LeftBrace)
<br><a name="311"></a>    { 
<br><a name="312"></a>        /* use the already defined enum */
<br><a name="313"></a>        <font color="red">if </font>((*<a href="type.html#80">Typ</a>)->Members == NULL)
<br><a name="314"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "enum '%s' isn't defined", <a href="type.html#292">EnumIdentifier</a>);
<br><a name="315"></a>            
<br><a name="316"></a>        return;
<br><a name="317"></a>    }
<br><a name="318"></a>    
<br><a name="319"></a>    <font color="red">if </font>(<a href="type.html#12">pc</a>->TopStackFrame != NULL)
<br><a name="320"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "enum definitions can only be globals");
<br><a name="321"></a>        
<br><a name="322"></a>    <a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, TRUE);    
<br><a name="323"></a>    (*<a href="type.html#80">Typ</a>)->Members = &pc->GlobalTable;
<br><a name="324"></a>    memset((void *)&Init<a href="interpreter_header.html#217">Value</a>, '\0', sizeof(<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a>));
<br><a name="325"></a>    <a href="type.html#289">InitValue</a>.Typ = &pc->IntType;
<br><a name="326"></a>    <a href="type.html#289">InitValue</a>.Val = (union <a href="interpreter_header.html#196">AnyValue</a> *)&EnumValue;
<br><a name="327"></a>    do {
<br><a name="328"></a>        <font color="red">if </font>(<a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, &LexValue, TRUE) != TokenIdentifier)
<br><a name="329"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "identifier expected");
<br><a name="330"></a>        
<br><a name="331"></a>        <a href="type.html#292">EnumIdentifier</a> = <a href="type.html#180">LexValue</a>->Val->Identifier;
<br><a name="332"></a>        <font color="red">if </font>(<a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, FALSE) == TokenAssign)
<br><a name="333"></a>        {
<br><a name="334"></a>            <a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, TRUE);
<br><a name="335"></a>            <a href="type.html#291">EnumValue</a> = <a style="color:green" href="expression.html#1569">ExpressionParseInt</a>(<a href="type.html#12">Parser</a>);
<br><a name="336"></a>        }
<br><a name="337"></a>        
<br><a name="338"></a>        <a style="color:green" href="variable.html#259">VariableDefine</a>(<a href="type.html#12">pc</a>, <a href="type.html#12">Parser</a>, <a href="type.html#292">EnumIdentifier</a>, &InitValue, NULL, FALSE);
<br><a name="339"></a>            
<br><a name="340"></a>        <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, NULL, TRUE);
<br><a name="341"></a>        <font color="red">if </font>(<a href="type.html#185">Token</a> != <a href="type.html#185">Token</a>Comma && <a href="type.html#185">Token</a> != <a href="type.html#185">Token</a>RightBrace)
<br><a name="342"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "comma expected");
<br><a name="343"></a>        
<br><a name="344"></a>        <a href="type.html#291">EnumValue</a>++;
<br><a name="345"></a>                    
<br><a name="346"></a>    } <font color="red">while </font>(<a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>Comma);
<br><a name="347"></a>}
<br><a name="348"></a>
<br><a name="349"></a>/* parse a type - just the basic type */
<br><a name="350"></a><font color="blue">int </font><a href="type.html#80">Typ</a>eParseFront(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="type.html#12">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">Value<a href="type.html#80">Typ</a>e</a> **<a href="type.html#80">Typ</a>, <font color="blue">int </font>*IsStatic)
<br><a name="351"></a>{
<br><a name="352"></a>    <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> <a href="type.html#435">Before</a>;
<br><a name="353"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Lexer<a href="interpreter_header.html#217">Value</a>;
<br><a name="354"></a>    enum Lex<a href="type.html#185">Token</a> <a href="type.html#185">Token</a>;
<br><a name="355"></a>    <font color="blue">int </font>Unsigned = FALSE;
<br><a name="356"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Var<a href="interpreter_header.html#217">Value</a>;
<br><a name="357"></a>    <font color="blue">int </font>StaticQualifier = FALSE;
<br><a name="358"></a>    <a href="interpreter_header.html#61">Picoc</a> *<a href="type.html#12">pc</a> = <a href="type.html#12">Parser</a>-><a href="type.html#12">pc</a>;
<br><a name="359"></a>    *<a href="type.html#80">Typ</a> = NULL;
<br><a name="360"></a>
<br><a name="361"></a>    /* ignore leading type qualifiers */
<br><a name="362"></a>    <a style="color:green" href="parse.html#429"><a href="type.html#12">Parser</a>Copy</a>(&Before, <a href="type.html#12">Parser</a>);
<br><a name="363"></a>    <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, &LexerValue, TRUE);
<br><a name="364"></a>    <font color="red">while </font>(<a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>StaticType || <a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>AutoType || <a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>RegisterType || <a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>ExternType)
<br><a name="365"></a>    {
<br><a name="366"></a>        <font color="red">if </font>(<a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>StaticType)
<br><a name="367"></a>            <a href="type.html#357">StaticQualifier</a> = TRUE;
<br><a name="368"></a>            
<br><a name="369"></a>        <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, &LexerValue, TRUE);
<br><a name="370"></a>    }
<br><a name="371"></a>    
<br><a name="372"></a>    <font color="red">if </font>(<a href="type.html#350">IsStatic</a> != NULL)
<br><a name="373"></a>        *<a href="type.html#350">IsStatic</a> = <a href="type.html#357">StaticQualifier</a>;
<br><a name="374"></a>        
<br><a name="375"></a>    /* handle signed/<font color="blue">unsigned </font>with no trailing type */
<br><a name="376"></a>    <font color="red">if </font>(<a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>SignedType || <a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>UnsignedType)
<br><a name="377"></a>    {
<br><a name="378"></a>        enum LexToken FollowToken = <a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, &LexerValue, FALSE);
<br><a name="379"></a>        <a href="type.html#355">Unsigned</a> = (<a href="type.html#185">Token</a> == <a href="type.html#185">Token</a><a href="type.html#355">Unsigned</a>Type);
<br><a name="380"></a>        
<br><a name="381"></a>        <font color="red">if </font>(<a href="type.html#378">FollowToken</a> != TokenIntType && <a href="type.html#378">FollowToken</a> != TokenLongType && <a href="type.html#378">FollowToken</a> != TokenShortType && <a href="type.html#378">FollowToken</a> != TokenCharType)
<br><a name="382"></a>        {
<br><a name="383"></a>            <font color="red">if </font>(<a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>UnsignedType)
<br><a name="384"></a>                *<a href="type.html#80">Typ</a> = &pc->UnsignedInt<a href="type.html#80">Typ</a>e;
<br><a name="385"></a>            else
<br><a name="386"></a>                *<a href="type.html#80">Typ</a> = &pc->Int<a href="type.html#80">Typ</a>e;
<br><a name="387"></a>            
<br><a name="388"></a>            <font color="red">return </font>TRUE;
<br><a name="389"></a>        }
<br><a name="390"></a>        
<br><a name="391"></a>        <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, &LexerValue, TRUE);
<br><a name="392"></a>    }
<br><a name="393"></a>    
<br><a name="394"></a>    switch (<a href="type.html#185">Token</a>)
<br><a name="395"></a>    {
<br><a name="396"></a>        case TokenInt<a href="type.html#80">Typ</a>e: *<a href="type.html#80">Typ</a> = <a href="type.html#355">Unsigned</a> ? &pc-><a href="type.html#355">Unsigned</a>Int<a href="type.html#80">Typ</a>e : &pc->Int<a href="type.html#80">Typ</a>e; break;
<br><a name="397"></a>        case TokenShort<a href="type.html#80">Typ</a>e: *<a href="type.html#80">Typ</a> = <a href="type.html#355">Unsigned</a> ? &pc-><a href="type.html#355">Unsigned</a>Short<a href="type.html#80">Typ</a>e : &pc->Short<a href="type.html#80">Typ</a>e; break;
<br><a name="398"></a>        case TokenChar<a href="type.html#80">Typ</a>e: *<a href="type.html#80">Typ</a> = <a href="type.html#355">Unsigned</a> ? &pc-><a href="type.html#355">Unsigned</a>Char<a href="type.html#80">Typ</a>e : &pc->Char<a href="type.html#80">Typ</a>e; break;
<br><a name="399"></a>        case TokenLong<a href="type.html#80">Typ</a>e: *<a href="type.html#80">Typ</a> = <a href="type.html#355">Unsigned</a> ? &pc-><a href="type.html#355">Unsigned</a>Long<a href="type.html#80">Typ</a>e : &pc->Long<a href="type.html#80">Typ</a>e; break;
<br><a name="400"></a>#ifndef NO_FP
<br><a name="401"></a>        case TokenFloat<a href="type.html#80">Typ</a>e: case TokenDouble<a href="type.html#80">Typ</a>e: *<a href="type.html#80">Typ</a> = &pc->FP<a href="type.html#80">Typ</a>e; break;
<br><a name="402"></a>#endif
<br><a name="403"></a>        case TokenVoid<a href="type.html#80">Typ</a>e: *<a href="type.html#80">Typ</a> = &pc->Void<a href="type.html#80">Typ</a>e; break;
<br><a name="404"></a>        
<br><a name="405"></a>        case TokenStructType: case TokenUnionType: 
<br><a name="406"></a>            <font color="red">if </font>(*<a href="type.html#80">Typ</a> != NULL)
<br><a name="407"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "bad type declaration");
<br><a name="408"></a>                
<br><a name="409"></a>            <a style="color:green" href="type.html#178"><a href="type.html#80">Typ</a>eParseStruct</a>(<a href="type.html#12">Parser</a>, <a href="type.html#80">Typ</a>, <a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>Struct<a href="type.html#80">Typ</a>e);
<br><a name="410"></a>            break;
<br><a name="411"></a>
<br><a name="412"></a>        case TokenEnumType:
<br><a name="413"></a>            <font color="red">if </font>(*<a href="type.html#80">Typ</a> != NULL)
<br><a name="414"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "bad type declaration");
<br><a name="415"></a>                
<br><a name="416"></a>            <a style="color:green" href="type.html#286"><a href="type.html#80">Typ</a>eParseEnum</a>(<a href="type.html#12">Parser</a>, <a href="type.html#80">Typ</a>);
<br><a name="417"></a>            break;
<br><a name="418"></a>        
<br><a name="419"></a>        case TokenIdentifier:
<br><a name="420"></a>            /* we already know it's a typedef-defined type because we got here */
<br><a name="421"></a>            <a style="color:green" href="variable.html#360">VariableGet</a>(<a href="type.html#12">pc</a>, <a href="type.html#12">Parser</a>, <a href="type.html#353">LexerValue</a>->Val->Identifier, &VarValue);
<br><a name="422"></a>            *<a href="type.html#80">Typ</a> = <a href="type.html#356">VarValue</a>->Val-><a href="type.html#80">Typ</a>;
<br><a name="423"></a>            break;
<br><a name="424"></a>
<br><a name="425"></a>        default: <a style="color:green" href="parse.html#429"><a href="type.html#12">Parser</a>Copy</a>(<a href="type.html#12">Parser</a>, &Before); <font color="red">return </font>FALSE;
<br><a name="426"></a>    }
<br><a name="427"></a>    
<br><a name="428"></a>    <font color="red">return </font>TRUE;
<br><a name="429"></a>}
<br><a name="430"></a>
<br><a name="431"></a>/* parse a type - the part at the end after the identifier. eg. array specifications etc. */
<br><a name="432"></a><font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *TypeParseBack(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="type.html#12">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *FromType)
<br><a name="433"></a>{
<br><a name="434"></a>    enum Lex<a href="type.html#185">Token</a> <a href="type.html#185">Token</a>;
<br><a name="435"></a>    <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> <a href="type.html#352">Before</a>;
<br><a name="436"></a>
<br><a name="437"></a>    <a style="color:green" href="parse.html#429"><a href="type.html#12">Parser</a>Copy</a>(&Before, <a href="type.html#12">Parser</a>);
<br><a name="438"></a>    <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, NULL, TRUE);
<br><a name="439"></a>    <font color="red">if </font>(<a href="type.html#185">Token</a> == <a href="type.html#185">Token</a>LeftSquareBracket)
<br><a name="440"></a>    {
<br><a name="441"></a>        /* add another array bound */
<br><a name="442"></a>        <font color="red">if </font>(<a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, FALSE) == TokenRightSquareBracket)
<br><a name="443"></a>        {
<br><a name="444"></a>            /* an unsized array */
<br><a name="445"></a>            <a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, TRUE);
<br><a name="446"></a>            <font color="red">return </font><a style="color:green" href="type.html#32">TypeGetMatching</a>(<a href="type.html#12">Parser</a>->pc, <a href="type.html#12">Parser</a>, <a style="color:green" href="type.html#432">TypeParseBack</a>(<a href="type.html#12">Parser</a>, <a href="type.html#432">FromType</a>), TypeArray, 0, <a href="type.html#12">Parser</a>->pc->StrEmpty, TRUE);
<br><a name="447"></a>        }
<br><a name="448"></a>        else
<br><a name="449"></a>        {
<br><a name="450"></a>            /* get a numeric array size */
<br><a name="451"></a>            enum RunMode OldMode = <a href="type.html#12">Parser</a>->Mode;
<br><a name="452"></a>            <font color="blue">int </font><a href="type.html#12">ArraySize</a>;
<br><a name="453"></a>            <a href="type.html#12">Parser</a>->Mode = RunModeRun;
<br><a name="454"></a>            <a href="type.html#12">ArraySize</a> = <a style="color:green" href="expression.html#1569">ExpressionParseInt</a>(<a href="type.html#12">Parser</a>);
<br><a name="455"></a>            <a href="type.html#12">Parser</a>->Mode = <a href="type.html#451">OldMode</a>;
<br><a name="456"></a>            
<br><a name="457"></a>            <font color="red">if </font>(<a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, TRUE) != TokenRightSquareBracket)
<br><a name="458"></a>                <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "'<font color="red">]</font>' expected");
<br><a name="459"></a>            
<br><a name="460"></a>            <font color="red">return </font><a style="color:green" href="type.html#32">TypeGetMatching</a>(<a href="type.html#12">Parser</a>->pc, <a href="type.html#12">Parser</a>, <a style="color:green" href="type.html#432">TypeParseBack</a>(<a href="type.html#12">Parser</a>, <a href="type.html#432">FromType</a>), TypeArray, <a href="type.html#12">ArraySize</a>, <a href="type.html#12">Parser</a>->pc->StrEmpty, TRUE);
<br><a name="461"></a>        }
<br><a name="462"></a>    }
<br><a name="463"></a>    else
<br><a name="464"></a>    {
<br><a name="465"></a>        /* the type specification has finished */
<br><a name="466"></a>        <a style="color:green" href="parse.html#429"><a href="type.html#12">Parser</a>Copy</a>(<a href="type.html#12">Parser</a>, &Before);
<br><a name="467"></a>        <font color="red">return </font><a href="type.html#432">FromType</a>;
<br><a name="468"></a>    }
<br><a name="469"></a>}
<br><a name="470"></a>
<br><a name="471"></a>/* parse a type - the part which is repeated with each identifier in a declaration list */
<br><a name="472"></a>void <a href="type.html#80">Typ</a>eParseIdentPart(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="type.html#12">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">Value<a href="type.html#80">Typ</a>e</a> *Basic<a href="type.html#80">Typ</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">Value<a href="type.html#80">Typ</a>e</a> **<a href="type.html#80">Typ</a>, <font color="blue">char </font>**<a href="type.html#12">Identifier</a>)
<br><a name="473"></a>{
<br><a name="474"></a>    <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> <a href="type.html#352">Before</a>;
<br><a name="475"></a>    enum Lex<a href="type.html#185">Token</a> <a href="type.html#185">Token</a>;
<br><a name="476"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Lex<a href="interpreter_header.html#217">Value</a>;
<br><a name="477"></a>    <font color="blue">int </font>Done = FALSE;
<br><a name="478"></a>    *<a href="type.html#80">Typ</a> = Basic<a href="type.html#80">Typ</a>;
<br><a name="479"></a>    *<a href="type.html#12">Identifier</a> = <a href="type.html#12">Parser</a>->pc->StrEmpty;
<br><a name="480"></a>    
<br><a name="481"></a>    <font color="red">while </font>(!Done)
<br><a name="482"></a>    {
<br><a name="483"></a>        <a style="color:green" href="parse.html#429"><a href="type.html#12">Parser</a>Copy</a>(&Before, <a href="type.html#12">Parser</a>);
<br><a name="484"></a>        <a href="type.html#185">Token</a> = LexGet<a href="type.html#185">Token</a>(<a href="type.html#12">Parser</a>, &LexValue, TRUE);
<br><a name="485"></a>        switch (<a href="type.html#185">Token</a>)
<br><a name="486"></a>        {
<br><a name="487"></a>            case TokenOpenBracket:
<br><a name="488"></a>                <font color="red">if </font>(*<a href="type.html#80">Typ</a> != NULL)
<br><a name="489"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "bad type declaration");
<br><a name="490"></a>                
<br><a name="491"></a>                <a style="color:green" href="type.html#526"><a href="type.html#80">Typ</a>eParse</a>(<a href="type.html#12">Parser</a>, <a href="type.html#80">Typ</a>, <a href="type.html#12">Identifier</a>, NULL);
<br><a name="492"></a>                <font color="red">if </font>(<a style="color:green" href="lex.html#883">LexGetToken</a>(<a href="type.html#12">Parser</a>, NULL, TRUE) != TokenCloseBracket)
<br><a name="493"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "')' expected");
<br><a name="494"></a>                break;
<br><a name="495"></a>                
<br><a name="496"></a>            case TokenAsterisk:
<br><a name="497"></a>                <font color="red">if </font>(*<a href="type.html#80">Typ</a> == NULL)
<br><a name="498"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "bad type declaration");
<br><a name="499"></a>
<br><a name="500"></a>                *<a href="type.html#80">Typ</a> = <a href="type.html#80">Typ</a>eGetMatching(<a href="type.html#12">Parser</a>->pc, <a href="type.html#12">Parser</a>, *<a href="type.html#80">Typ</a>, <a href="type.html#80">Typ</a>ePointer, 0, <a href="type.html#12">Parser</a>->pc->StrEmpty, TRUE);
<br><a name="501"></a>                break;
<br><a name="502"></a>            
<br><a name="503"></a>            case TokenIdentifier:
<br><a name="504"></a>                <font color="red">if </font>(*<a href="type.html#80">Typ</a> == NULL || *<a href="type.html#12">Identifier</a> != <a href="type.html#12">Parser</a>->pc->StrEmpty)
<br><a name="505"></a>                    <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "bad type declaration");
<br><a name="506"></a>                
<br><a name="507"></a>                *<a href="type.html#12">Identifier</a> = <a href="type.html#180">LexValue</a>->Val-><a href="type.html#12">Identifier</a>;
<br><a name="508"></a>                <a href="type.html#477">Done</a> = TRUE;
<br><a name="509"></a>                break;
<br><a name="510"></a>                
<br><a name="511"></a>            default: <a style="color:green" href="parse.html#429"><a href="type.html#12">Parser</a>Copy</a>(<a href="type.html#12">Parser</a>, &Before); <a href="type.html#477">Done</a> = TRUE; break;
<br><a name="512"></a>        }
<br><a name="513"></a>    }
<br><a name="514"></a>    
<br><a name="515"></a>    <font color="red">if </font>(*<a href="type.html#80">Typ</a> == NULL)
<br><a name="516"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="type.html#12">Parser</a>, "bad type declaration");
<br><a name="517"></a>
<br><a name="518"></a>    <font color="red">if </font>(*<a href="type.html#12">Identifier</a> != <a href="type.html#12">Parser</a>->pc->StrEmpty)
<br><a name="519"></a>    { 
<br><a name="520"></a>        /* parse stuff after the identifier */
<br><a name="521"></a>        *<a href="type.html#80">Typ</a> = <a href="type.html#80">Typ</a>eParseBack(<a href="type.html#12">Parser</a>, *<a href="type.html#80">Typ</a>);
<br><a name="522"></a>    }
<br><a name="523"></a>}
<br><a name="524"></a>
<br><a name="525"></a>/* parse a type - a complete declaration including identifier */
<br><a name="526"></a>void <a href="type.html#80">Typ</a>eParse(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="type.html#12">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">Value<a href="type.html#80">Typ</a>e</a> **<a href="type.html#80">Typ</a>, <font color="blue">char </font>**<a href="type.html#12">Identifier</a>, <font color="blue">int </font>*<a href="type.html#350">IsStatic</a>)
<br><a name="527"></a>{
<br><a name="528"></a>    <font color="blue">struct </font><a href="interpreter_header.html#160">ValueType</a> *BasicType;
<br><a name="529"></a>    
<br><a name="530"></a>    <a style="color:green" href="type.html#350">TypeParseFront</a>(<a href="type.html#12">Parser</a>, &BasicType, <a href="type.html#350">IsStatic</a>);
<br><a name="531"></a>    <a style="color:green" href="type.html#472"><a href="type.html#80">Typ</a>eParseIdentPart</a>(<a href="type.html#12">Parser</a>, <a href="type.html#528">Basic<a href="type.html#80">Typ</a>e</a>, <a href="type.html#80">Typ</a>, <a href="type.html#12">Identifier</a>);
<br><a name="532"></a>}
<br><a name="533"></a>
<br><a name="534"></a>/* check <font color="red">if </font>a type has been fully defined - otherwise it's just a forward declaration */
<br><a name="535"></a><font color="blue">int </font><a href="type.html#80">Typ</a>eIsForwardDeclared(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="type.html#12">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#160">Value<a href="type.html#80">Typ</a>e</a> *<a href="type.html#80">Typ</a>)
<br><a name="536"></a>{
<br><a name="537"></a>    <font color="red">if </font>(<a href="type.html#80">Typ</a>->Base == <a href="type.html#80">Typ</a>eArray)
<br><a name="538"></a>        <font color="red">return </font><a style="color:green" href="type.html#535"><a href="type.html#80">Typ</a>eIsForwardDeclared</a>(<a href="type.html#12">Parser</a>, <a href="type.html#80">Typ</a>->From<a href="type.html#80">Typ</a>e);
<br><a name="539"></a>    
<br><a name="540"></a>    <font color="red">if </font>( (<a href="type.html#80">Typ</a>->Base == <a href="type.html#80">Typ</a>eStruct || <a href="type.html#80">Typ</a>->Base == <a href="type.html#80">Typ</a>eUnion) && <a href="type.html#80">Typ</a>->Members == NULL)
<br><a name="541"></a>        <font color="red">return </font>TRUE;
<br><a name="542"></a>        
<br><a name="543"></a>    <font color="red">return </font>FALSE;
<br><a name="544"></a>}
<br><a name="545"></a></html>