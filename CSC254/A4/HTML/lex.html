<html><a name="1"></a>/* picoc lexer - converts source text into a tokenised form */ 
<br><a name="2"></a>
<br><a name="3"></a>#<font color="red">include </font>"interpreter.h"
<br><a name="4"></a>
<br><a name="5"></a>#ifdef NO_CTYPE
<br><a name="6"></a>#define isalpha(c) (((c) &gt;= 'a' && (c) &lt;= 'z') || ((c) &gt;= 'A' && (c) &lt;= 'Z'))
<br><a name="7"></a>#define isdigit(c) ((c) >= '0' && (c) <= '9')
<br><a name="8"></a>#define isalnum(c) (isalpha(c) || isdigit(c))
<br><a name="9"></a>#define isspace(c) ((c) == ' ' || (c) == '\t' || (c) == '\r' || (c) == '\n')
<br><a name="10"></a>#endif
<br><a name="11"></a>#define isCidstart(c) (isalpha(c) || (c)=='_' || (c)=='#')
<br><a name="12"></a>#define isCident(c) (isalnum(c) || (c)=='_')
<br><a name="13"></a>
<br><a name="14"></a>#define IS_HEX_ALPHA_DIGIT(c) (((c) &gt;= 'a' && (c) &lt;= 'f') || ((c) &gt;= 'A' && (c) &lt;= 'F'))
<br><a name="15"></a>#define IS_BASE_DIGIT(c,b) (((c) &gt;= '0' && (c) &lt; '0' + (((b)&lt;10)?(b):10)) || (((b) &gt; 10) ? IS_HEX_ALPHA_DIGIT(c) : FALSE))
<br><a name="16"></a>#define GET_BASE_DIGIT(c) (((c) <= '9') ? ((c) - '0') : (((c) <= 'F') ? ((c) - 'A' + 10) : ((c) - 'a' + 10)))
<br><a name="17"></a>
<br><a name="18"></a>#define NEXTIS(c,x,y) { <font color="red">if </font>(NextChar == (c)) { LEXER_INC(Lexer); GotToken = (x); } else GotToken = (y); }
<br><a name="19"></a>#define NEXTIS3(c,x,d,y,z) { <font color="red">if </font>(NextChar == (c)) { LEXER_INC(Lexer); GotToken = (x); } else NEXTIS(d,y,z) }
<br><a name="20"></a>#define NEXTIS4(c,x,d,y,e,z,a) { <font color="red">if </font>(NextChar == (c)) { LEXER_INC(Lexer); GotToken = (x); } else NEXTIS3(d,y,e,z,a) }
<br><a name="21"></a>#define NEXTIS3PLUS(c,x,d,y,e,z,a) { <font color="red">if </font>(NextChar == (c)) { LEXER_INC(Lexer); GotToken = (x); } else <font color="red">if </font>(NextChar == (d)) { <font color="red">if </font>(Lexer->Pos<font color="red">[</font>1<font color="red">]</font> == (e)) { LEXER_INCN(Lexer, 2); GotToken = (z); } else { LEXER_INC(Lexer); GotToken = (y); } } else GotToken = (a); }
<br><a name="22"></a>#define NEXTISEXACTLY3(c,d,y,z) { <font color="red">if </font>(NextChar == (c) && Lexer->Pos<font color="red">[</font>1<font color="red">]</font> == (d)) { LEXER_INCN(Lexer, 2); GotToken = (y); } else GotToken = (z); }
<br><a name="23"></a>
<br><a name="24"></a>#define LEXER_INC(l) ( (l)->Pos++, (l)->CharacterPos++ )
<br><a name="25"></a>#define LEXER_INCN(l, n) ( (l)->Pos+=(n), (l)->CharacterPos+=(n) )
<br><a name="26"></a>#define TOKEN_DATA_OFFSET 2
<br><a name="27"></a>
<br><a name="28"></a>#define MAX_CHAR_VALUE 255      /* maximum value which can be represented by a "char" data type */
<br><a name="29"></a>
<br><a name="30"></a>
<br><a name="31"></a><font color="blue">struct </font>ReservedWord
<br><a name="32"></a>{
<br><a name="33"></a>    const <font color="blue">char </font>*Word;
<br><a name="34"></a>    enum LexToken Token;
<br><a name="35"></a>};
<br><a name="36"></a>
<br><a name="37"></a>static <font color="blue">struct </font><a href="lex.html#31">ReservedWord</a> <a href="lex.html#31">ReservedWord</a>s<font color="red">[</font><font color="red">]</font> =
<br><a name="38"></a>{
<br><a name="39"></a>    { "#define", TokenHashDefine },
<br><a name="40"></a>    { "#else", TokenHashElse },
<br><a name="41"></a>    { "#endif", TokenHashEnd<font color="red">if </font>},
<br><a name="42"></a>    { "#if", TokenHashIf },
<br><a name="43"></a>    { "#ifdef", TokenHashIfdef },
<br><a name="44"></a>    { "#ifndef", TokenHashIfndef },
<br><a name="45"></a>    { "#include", TokenHashInclude },
<br><a name="46"></a>    { "auto", TokenAutoType },
<br><a name="47"></a>    { "break", TokenBreak },
<br><a name="48"></a>    { "case", TokenCase },
<br><a name="49"></a>    { "char", TokenCharType },
<br><a name="50"></a>    { "continue", TokenContinue },
<br><a name="51"></a>    { "default", TokenDefault },
<br><a name="52"></a>    { "delete", TokenDelete },
<br><a name="53"></a>    { "do", TokenDo },
<br><a name="54"></a>#ifndef NO_FP
<br><a name="55"></a>    { "double", TokenDoubleType },
<br><a name="56"></a>#endif
<br><a name="57"></a>    { "else", TokenElse },
<br><a name="58"></a>    { "enum", TokenEnumType },
<br><a name="59"></a>    { "extern", TokenExternType },
<br><a name="60"></a>#ifndef NO_FP
<br><a name="61"></a>    { "float", TokenFloatType },
<br><a name="62"></a>#endif
<br><a name="63"></a>    { "for", TokenFor },
<br><a name="64"></a>    { "goto", TokenGoto },
<br><a name="65"></a>    { "if", TokenIf },
<br><a name="66"></a>    { "int", TokenIntType },
<br><a name="67"></a>    { "long", TokenLongType },
<br><a name="68"></a>    { "new", TokenNew },
<br><a name="69"></a>    { "register", TokenRegisterType },
<br><a name="70"></a>    { "return", TokenReturn },
<br><a name="71"></a>    { "short", TokenShortType },
<br><a name="72"></a>    { "signed", TokenSignedType },
<br><a name="73"></a>    { "sizeof", TokenSizeof },
<br><a name="74"></a>    { "static", TokenStaticType },
<br><a name="75"></a>    { "struct", TokenStructType },
<br><a name="76"></a>    { "switch", TokenSwitch },
<br><a name="77"></a>    { "typedef", TokenTypedef },
<br><a name="78"></a>    { "union", TokenUnionType },
<br><a name="79"></a>    { "unsigned", TokenUnsignedType },
<br><a name="80"></a>    { "void", TokenVoidType },
<br><a name="81"></a>    { "while", TokenWhile }
<br><a name="82"></a>};
<br><a name="83"></a>
<br><a name="84"></a>
<br><a name="85"></a>
<br><a name="86"></a>/* initialise the lexer */
<br><a name="87"></a>void LexInit(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#631">pc</a>)
<br><a name="88"></a>{
<br><a name="89"></a>    <font color="blue">int </font><a href="lex.html#110">Count</a>;
<br><a name="90"></a>    
<br><a name="91"></a>    <a style="color:green" href="table.html#32">TableInitTable</a>(&pc-><a href="lex.html#31">ReservedWord</a>Table, &pc-><a href="lex.html#31">ReservedWord</a>HashTable<font color="red">[</font>0<font color="red">]</font>, sizeof(<a href="lex.html#37"><a href="lex.html#31">ReservedWord</a>s</a>) / sizeof(<font color="blue">struct </font><a href="lex.html#31">ReservedWord</a>) * 2, TRUE);
<br><a name="92"></a>
<br><a name="93"></a>    <font color="red">for </font>(<a href="lex.html#89">Count</a> = 0; <a href="lex.html#89">Count</a> < sizeof(<a href="lex.html#37"><a href="lex.html#31">ReservedWord</a>s</a>) / sizeof(<font color="blue">struct </font><a href="lex.html#31">ReservedWord</a>); <a href="lex.html#89">Count</a>++)
<br><a name="94"></a>    {
<br><a name="95"></a>        <a style="color:green" href="table.html#58">TableSet</a>(<a href="lex.html#87">pc</a>, &<a href="lex.html#87">pc</a>->ReservedWordTable, <a style="color:green" href="table.html#166">TableStrRegister</a>(<a href="lex.html#87">pc</a>, ReservedWords<font color="red">[</font>Count<font color="red">]</font>.Word), (<font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *)&ReservedWords<font color="red">[</font>Count<font color="red">]</font>, NULL, 0, 0);
<br><a name="96"></a>    }
<br><a name="97"></a>    
<br><a name="98"></a>    <a href="lex.html#87">pc</a>->LexValue.Typ = NULL;
<br><a name="99"></a>    <a href="lex.html#87">pc</a>->LexValue.Val = &<a href="lex.html#87">pc</a>->LexAnyValue;
<br><a name="100"></a>    <a href="lex.html#87">pc</a>->LexValue.LValueFrom = FALSE;
<br><a name="101"></a>    <a href="lex.html#87">pc</a>->LexValue.ValOnHeap = FALSE;
<br><a name="102"></a>    <a href="lex.html#87">pc</a>->LexValue.ValOnStack = FALSE;
<br><a name="103"></a>    <a href="lex.html#87">pc</a>->LexValue.AnyValOnHeap = FALSE;
<br><a name="104"></a>    <a href="lex.html#87">pc</a>->LexValue.IsLValue = FALSE;
<br><a name="105"></a>}
<br><a name="106"></a>
<br><a name="107"></a>/* deallocate */
<br><a name="108"></a>void LexCleanup(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>)
<br><a name="109"></a>{
<br><a name="110"></a>    <font color="blue">int </font><a href="lex.html#89">Count</a>;
<br><a name="111"></a>
<br><a name="112"></a>    <a style="color:green" href="lex.html#995">LexInteractiveClear</a>(<a href="lex.html#87">pc</a>, NULL);
<br><a name="113"></a>
<br><a name="114"></a>    <font color="red">for </font>(<a href="lex.html#89">Count</a> = 0; <a href="lex.html#89">Count</a> < sizeof(<a href="lex.html#37"><a href="lex.html#31">ReservedWord</a>s</a>) / sizeof(<font color="blue">struct </font><a href="lex.html#31">ReservedWord</a>); <a href="lex.html#89">Count</a>++)
<br><a name="115"></a>        <a style="color:green" href="table.html#101">TableDelete</a>(<a href="lex.html#87">pc</a>, &<a href="lex.html#87">pc</a>->ReservedWordTable, <a style="color:green" href="table.html#166">TableStrRegister</a>(<a href="lex.html#87">pc</a>, ReservedWords<font color="red">[</font>Count<font color="red">]</font>.Word));
<br><a name="116"></a>}
<br><a name="117"></a>
<br><a name="118"></a>/* check <font color="red">if </font>a word is a reserved word - used <font color="red">while </font>scanning */
<br><a name="119"></a>enum LexToken LexCheckReservedWord(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, const <font color="blue">char </font>*Word)
<br><a name="120"></a>{
<br><a name="121"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *val;
<br><a name="122"></a>    
<br><a name="123"></a>    <font color="red">if </font>(<a style="color:green" href="table.html#81">TableGet</a>(&pc->Reserved<a href="lex.html#119">Word</a>Table, <a href="lex.html#119">Word</a>, &val, NULL, NULL, NULL))
<br><a name="124"></a>        <font color="red">return </font>((<font color="blue">struct </font><a href="lex.html#31">ReservedWord</a> *)<a href="lex.html#121">val</a>)->Token;
<br><a name="125"></a>    else
<br><a name="126"></a>        <font color="red">return </font>TokenNone;
<br><a name="127"></a>}
<br><a name="128"></a>
<br><a name="129"></a>/* get a numeric literal - used <font color="red">while </font>scanning */
<br><a name="130"></a>enum LexToken LexGetNumber(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#288">LexState</a> *<a href="lex.html#595">Lexer</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>)
<br><a name="131"></a>{
<br><a name="132"></a>    <font color="blue">long </font>Result = 0;
<br><a name="133"></a>    <font color="blue">long </font>Base = 10;
<br><a name="134"></a>    enum LexToken ResultToken;
<br><a name="135"></a>#ifndef NO_FP
<br><a name="136"></a>    <font color="blue">double </font>FPResult;
<br><a name="137"></a>    <font color="blue">double </font>FPDiv;
<br><a name="138"></a>#endif
<br><a name="139"></a>    /* long/<font color="blue">unsigned </font>flags */
<br><a name="140"></a>#<font color="red">if </font>0 /* unused <font color="red">for </font>now */
<br><a name="141"></a>    <font color="blue">char </font>IsLong = 0;
<br><a name="142"></a>    <font color="blue">char </font>IsUnsigned = 0;
<br><a name="143"></a>#endif
<br><a name="144"></a>    
<br><a name="145"></a>    <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == '0')
<br><a name="146"></a>    { 
<br><a name="147"></a>        /* a binary, octal or hex literal */
<br><a name="148"></a>        LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="149"></a>        <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End)
<br><a name="150"></a>        {
<br><a name="151"></a>            <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == 'x' || *<a href="lex.html#130">Lexer</a>->Pos == 'X')
<br><a name="152"></a>                { <a href="lex.html#133">Base</a> = 16; LEXER_INC(<a href="lex.html#130">Lexer</a>); }
<br><a name="153"></a>            else <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == 'b' || *<a href="lex.html#130">Lexer</a>->Pos == 'B')
<br><a name="154"></a>                { <a href="lex.html#133">Base</a> = 2; LEXER_INC(<a href="lex.html#130">Lexer</a>); }
<br><a name="155"></a>            else <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos != '.')
<br><a name="156"></a>                <a href="lex.html#133">Base</a> = 8;
<br><a name="157"></a>        }
<br><a name="158"></a>    }
<br><a name="159"></a>
<br><a name="160"></a>    /* get the value */
<br><a name="161"></a>    <font color="red">for </font>(; <a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && IS_BASE_DIGIT(*<a href="lex.html#130">Lexer</a>->Pos, <a href="lex.html#133">Base</a>); LEXER_INC(<a href="lex.html#130">Lexer</a>))
<br><a name="162"></a>        <a href="lex.html#132">Result</a> = <a href="lex.html#132">Result</a> * <a href="lex.html#133">Base</a> + GET_BASE_DIGIT(*<a href="lex.html#130">Lexer</a>->Pos);
<br><a name="163"></a>
<br><a name="164"></a>    <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == 'u' || *<a href="lex.html#130">Lexer</a>->Pos == 'U')
<br><a name="165"></a>    {
<br><a name="166"></a>        LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="167"></a>        /* IsUnsigned = 1; */
<br><a name="168"></a>    }
<br><a name="169"></a>    <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == 'l' || *<a href="lex.html#130">Lexer</a>->Pos == 'L')
<br><a name="170"></a>    {
<br><a name="171"></a>        LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="172"></a>        /* IsLong = 1; */
<br><a name="173"></a>    }
<br><a name="174"></a>    
<br><a name="175"></a>    <a href="interpreter_header.html#217">Value</a>->Typ = &pc->LongType; /* ignored? */
<br><a name="176"></a>    <a href="interpreter_header.html#217">Value</a>->Val->LongInteger = <a href="lex.html#132">Result</a>;
<br><a name="177"></a>
<br><a name="178"></a>    <a href="lex.html#134">ResultToken</a> = TokenIntegerConstant;
<br><a name="179"></a>    
<br><a name="180"></a>    <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Pos == <a href="lex.html#130">Lexer</a>->End)
<br><a name="181"></a>        <font color="red">return </font><a href="lex.html#134">ResultToken</a>;
<br><a name="182"></a>        
<br><a name="183"></a>#ifndef NO_FP
<br><a name="184"></a>    <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Pos == <a href="lex.html#130">Lexer</a>->End)
<br><a name="185"></a>    {
<br><a name="186"></a>        <font color="red">return </font><a href="lex.html#134">ResultToken</a>;
<br><a name="187"></a>    }
<br><a name="188"></a>    
<br><a name="189"></a>    <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos != '.' && *<a href="lex.html#130">Lexer</a>->Pos != 'e' && *<a href="lex.html#130">Lexer</a>->Pos != 'E')
<br><a name="190"></a>    {
<br><a name="191"></a>        <font color="red">return </font><a href="lex.html#134">ResultToken</a>;
<br><a name="192"></a>    }
<br><a name="193"></a>    
<br><a name="194"></a>    <a href="interpreter_header.html#217">Value</a>->Typ = &pc->FPType;
<br><a name="195"></a>    <a href="lex.html#136">FP<a href="lex.html#132">Result</a></a> = (double)<a href="lex.html#132">Result</a>;
<br><a name="196"></a>    
<br><a name="197"></a>    <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == '.')
<br><a name="198"></a>    {
<br><a name="199"></a>        LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="200"></a>        <font color="red">for </font>(<a href="lex.html#137">FPDiv</a> = 1.0/<a href="lex.html#133">Base</a>; <a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && IS_BASE_DIGIT(*<a href="lex.html#130">Lexer</a>->Pos, <a href="lex.html#133">Base</a>); LEXER_INC(<a href="lex.html#130">Lexer</a>), <a href="lex.html#137">FPDiv</a> /= (double)<a href="lex.html#133">Base</a>)
<br><a name="201"></a>        {
<br><a name="202"></a>            <a href="lex.html#136">FPResult</a> += GET_BASE_DIGIT(*<a href="lex.html#130">Lexer</a>->Pos) * <a href="lex.html#137">FPDiv</a>;
<br><a name="203"></a>        }
<br><a name="204"></a>    }
<br><a name="205"></a>
<br><a name="206"></a>    <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && (*<a href="lex.html#130">Lexer</a>->Pos == 'e' || *<a href="lex.html#130">Lexer</a>->Pos == 'E'))
<br><a name="207"></a>    {
<br><a name="208"></a>        <font color="blue">int </font>ExponentSign = 1;
<br><a name="209"></a>        
<br><a name="210"></a>        LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="211"></a>        <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && *<a href="lex.html#130">Lexer</a>->Pos == '-')
<br><a name="212"></a>        {
<br><a name="213"></a>            <a href="lex.html#208">ExponentSign</a> = -1;
<br><a name="214"></a>            LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="215"></a>        }
<br><a name="216"></a>        
<br><a name="217"></a>        <a href="lex.html#132">Result</a> = 0;
<br><a name="218"></a>        <font color="red">while </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && IS_BASE_DIGIT(*<a href="lex.html#130">Lexer</a>->Pos, <a href="lex.html#133">Base</a>))
<br><a name="219"></a>        {
<br><a name="220"></a>            <a href="lex.html#132">Result</a> = <a href="lex.html#132">Result</a> * <a href="lex.html#133">Base</a> + GET_BASE_DIGIT(*<a href="lex.html#130">Lexer</a>->Pos);
<br><a name="221"></a>            LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="222"></a>        }
<br><a name="223"></a>
<br><a name="224"></a>        <a href="lex.html#136">FP<a href="lex.html#132">Result</a></a> *= pow((double)<a href="lex.html#133">Base</a>, (double)<a href="lex.html#132">Result</a> * <a href="lex.html#208">ExponentSign</a>);
<br><a name="225"></a>    }
<br><a name="226"></a>    
<br><a name="227"></a>    <a href="interpreter_header.html#217">Value</a>->Val->FP = <a href="lex.html#136">FPResult</a>;
<br><a name="228"></a>
<br><a name="229"></a>    <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == 'f' || *<a href="lex.html#130">Lexer</a>->Pos == 'F')
<br><a name="230"></a>        LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="231"></a>
<br><a name="232"></a>    <font color="red">return </font>TokenFPConstant;
<br><a name="233"></a>#else
<br><a name="234"></a>    <font color="red">return </font><a href="lex.html#134">ResultToken</a>;
<br><a name="235"></a>#endif
<br><a name="236"></a>}
<br><a name="237"></a>
<br><a name="238"></a>/* get a reserved word or identifier - used <font color="red">while </font>scanning */
<br><a name="239"></a>enum LexToken LexGetWord(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#288">LexState</a> *<a href="lex.html#130">Lexer</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>)
<br><a name="240"></a>{
<br><a name="241"></a>    const <font color="blue">char </font>*<a href="lex.html#328">StartPos</a> = <a href="lex.html#130">Lexer</a>->Pos;
<br><a name="242"></a>    enum Lex<a href="lex.html#528">Token</a> <a href="lex.html#528">Token</a>;
<br><a name="243"></a>    
<br><a name="244"></a>    do {
<br><a name="245"></a>        LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="246"></a>    } <font color="red">while </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && isCident((int)*<a href="lex.html#130">Lexer</a>->Pos));
<br><a name="247"></a>    
<br><a name="248"></a>    <a href="interpreter_header.html#217">Value</a>->Typ = NULL;
<br><a name="249"></a>    <a href="interpreter_header.html#217">Value</a>->Val->Identifier = <a style="color:green" href="table.html#161">TableStrRegister2</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#241">StartPos</a>, <a href="lex.html#130">Lexer</a>->Pos - <a href="lex.html#241">StartPos</a>);
<br><a name="250"></a>    
<br><a name="251"></a>    <a href="lex.html#242">Token</a> = <a style="color:green" href="lex.html#119">LexCheckReservedWord</a>(<a href="lex.html#87">pc</a>, <a href="interpreter_header.html#217">Value</a>->Val->Identifier);
<br><a name="252"></a>    switch (<a href="lex.html#242">Token</a>)
<br><a name="253"></a>    {
<br><a name="254"></a>        case TokenHashInclude: <a href="lex.html#130">Lexer</a>->Mode = LexModeHashInclude; break;
<br><a name="255"></a>        case TokenHashDefine: <a href="lex.html#130">Lexer</a>->Mode = LexModeHashDefine; break;
<br><a name="256"></a>        default: break;
<br><a name="257"></a>    }
<br><a name="258"></a>        
<br><a name="259"></a>    <font color="red">if </font>(<a href="lex.html#242">Token</a> != <a href="lex.html#242">Token</a>None)
<br><a name="260"></a>        <font color="red">return </font><a href="lex.html#242">Token</a>;
<br><a name="261"></a>    
<br><a name="262"></a>    <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Mode == LexModeHashDefineSpace)
<br><a name="263"></a>        <a href="lex.html#130">Lexer</a>->Mode = LexModeHashDefineSpaceIdent;
<br><a name="264"></a>    
<br><a name="265"></a>    <font color="red">return </font>TokenIdentifier;
<br><a name="266"></a>}
<br><a name="267"></a>
<br><a name="268"></a>/* unescape a character from an octal character constant */
<br><a name="269"></a><font color="blue">unsigned </font><font color="blue">char </font>LexUnEscapeCharacterConstant(const <font color="blue">char </font>**From, const <font color="blue">char </font>*End, <font color="blue">unsigned </font><font color="blue">char </font>FirstChar, <font color="blue">int </font><a href="lex.html#133">Base</a>)
<br><a name="270"></a>{
<br><a name="271"></a>    <font color="blue">unsigned </font><font color="blue">char </font>Total = GET_BASE_DIGIT(<a href="lex.html#269">FirstChar</a>);
<br><a name="272"></a>    <font color="blue">int </font>CCount;
<br><a name="273"></a>    <font color="red">for </font>(<a href="lex.html#272">CCount</a> = 0; IS_BASE_DIGIT(**<a href="lex.html#269">From</a>, <a href="lex.html#133">Base</a>) && <a href="lex.html#272">CCount</a> < 2; <a href="lex.html#272">CCount</a>++, (*<a href="lex.html#269">From</a>)++)
<br><a name="274"></a>        <a href="lex.html#271">Total</a> = <a href="lex.html#271">Total</a> * <a href="lex.html#133">Base</a> + GET_BASE_DIGIT(**<a href="lex.html#269">From</a>);
<br><a name="275"></a>    
<br><a name="276"></a>    <font color="red">return </font><a href="lex.html#271">Total</a>;
<br><a name="277"></a>}
<br><a name="278"></a>
<br><a name="279"></a>/* unescape a character from a string or character constant */
<br><a name="280"></a><font color="blue">unsigned </font><font color="blue">char </font>LexUnEscapeCharacter(const <font color="blue">char </font>**<a href="lex.html#269">From</a>, const <font color="blue">char </font>*<a href="lex.html#269">End</a>)
<br><a name="281"></a>{
<br><a name="282"></a>    <font color="blue">unsigned </font><font color="blue">char </font><a href="lex.html#431">ThisChar</a>;
<br><a name="283"></a>    
<br><a name="284"></a>    <font color="red">while </font>( *<a href="lex.html#269">From</a> != <a href="lex.html#269">End</a> && **<a href="lex.html#269">From</a> == '\\' && 
<br><a name="285"></a>            &(*<a href="lex.html#269">From</a>)<font color="red">[</font>1<font color="red">]</font> != <a href="lex.html#269">End</a> && (*<a href="lex.html#269">From</a>)<font color="red">[</font>1<font color="red">]</font> == '\n' )
<br><a name="286"></a>        (*<a href="lex.html#269">From</a>) += 2;       /* skip escaped end of lines with LF line termination */
<br><a name="287"></a>    
<br><a name="288"></a>    <font color="red">while </font>( *<a href="lex.html#269">From</a> != <a href="lex.html#269">End</a> && **<a href="lex.html#269">From</a> == '\\' && 
<br><a name="289"></a>            &(*<a href="lex.html#269">From</a>)<font color="red">[</font>1<font color="red">]</font> != <a href="lex.html#269">End</a> && &(*<a href="lex.html#269">From</a>)<font color="red">[</font>2<font color="red">]</font> != <a href="lex.html#269">End</a> && (*<a href="lex.html#269">From</a>)<font color="red">[</font>1<font color="red">]</font> == '\r' && (*<a href="lex.html#269">From</a>)<font color="red">[</font>2<font color="red">]</font> == '\n')
<br><a name="290"></a>        (*<a href="lex.html#269">From</a>) += 3;       /* skip escaped end of lines with CR/LF line termination */
<br><a name="291"></a>    
<br><a name="292"></a>    <font color="red">if </font>(*<a href="lex.html#269">From</a> == <a href="lex.html#269">End</a>)
<br><a name="293"></a>        <font color="red">return </font>'\\';
<br><a name="294"></a>    
<br><a name="295"></a>    <font color="red">if </font>(**<a href="lex.html#269">From</a> == '\\')
<br><a name="296"></a>    { 
<br><a name="297"></a>        /* it's escaped */
<br><a name="298"></a>        (*<a href="lex.html#269">From</a>)++;
<br><a name="299"></a>        <font color="red">if </font>(*<a href="lex.html#269">From</a> == <a href="lex.html#269">End</a>)
<br><a name="300"></a>            <font color="red">return </font>'\\';
<br><a name="301"></a>        
<br><a name="302"></a>        <a href="lex.html#282">ThisChar</a> = *(*<a href="lex.html#269">From</a>)++;
<br><a name="303"></a>        switch (<a href="lex.html#282">ThisChar</a>)
<br><a name="304"></a>        {
<br><a name="305"></a>            case '\\': <font color="red">return </font>'\\'; 
<br><a name="306"></a>            case '\'': <font color="red">return </font>'\'';
<br><a name="307"></a>            case '"':  <font color="red">return </font>'"';
<br><a name="308"></a>            case 'a':  <font color="red">return </font>'\a';
<br><a name="309"></a>            case 'b':  <font color="red">return </font>'\b';
<br><a name="310"></a>            case 'f':  <font color="red">return </font>'\f';
<br><a name="311"></a>            case 'n':  <font color="red">return </font>'\n';
<br><a name="312"></a>            case 'r':  <font color="red">return </font>'\r';
<br><a name="313"></a>            case 't':  <font color="red">return </font>'\t';
<br><a name="314"></a>            case 'v':  <font color="red">return </font>'\v';
<br><a name="315"></a>            case '0': case '1': case '2': case '3': <font color="red">return </font><a style="color:green" href="lex.html#269">LexUnEscapeCharacterConstant</a>(<a href="lex.html#269">From</a>, <a href="lex.html#269">End</a>, <a href="lex.html#282">ThisChar</a>, 8);
<br><a name="316"></a>            case 'x': <font color="red">return </font><a style="color:green" href="lex.html#269">LexUnEscapeCharacterConstant</a>(<a href="lex.html#269">From</a>, <a href="lex.html#269">End</a>, '0', 16);
<br><a name="317"></a>            default:   <font color="red">return </font><a href="lex.html#282">ThisChar</a>;
<br><a name="318"></a>        }
<br><a name="319"></a>    }
<br><a name="320"></a>    else
<br><a name="321"></a>        <font color="red">return </font>*(*<a href="lex.html#269">From</a>)++;
<br><a name="322"></a>}
<br><a name="323"></a>
<br><a name="324"></a>/* get a string constant - used <font color="red">while </font>scanning */
<br><a name="325"></a>enum LexToken LexGetStringConstant(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#288">LexState</a> *<a href="lex.html#130">Lexer</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>, <font color="blue">char </font>EndChar)
<br><a name="326"></a>{
<br><a name="327"></a>    <font color="blue">int </font>Escape = FALSE;
<br><a name="328"></a>    const <font color="blue">char </font>*<a href="lex.html#241">StartPos</a> = <a href="lex.html#130">Lexer</a>->Pos;
<br><a name="329"></a>    const <font color="blue">char </font>*EndPos;
<br><a name="330"></a>    <font color="blue">char </font>*EscBuf;
<br><a name="331"></a>    <font color="blue">char </font>*EscBufPos;
<br><a name="332"></a>    <font color="blue">char </font>*RegString;
<br><a name="333"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Array<a href="interpreter_header.html#217">Value</a>;
<br><a name="334"></a>    
<br><a name="335"></a>    <font color="red">while </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && (*<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#325">EndChar</a> || <a href="lex.html#327">Escape</a>))
<br><a name="336"></a>    { 
<br><a name="337"></a>        /* find the end */
<br><a name="338"></a>        <font color="red">if </font>(<a href="lex.html#327">Escape</a>)
<br><a name="339"></a>        {
<br><a name="340"></a>            <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == '\r' && <a href="lex.html#130">Lexer</a>->Pos+1 != <a href="lex.html#130">Lexer</a>->End)
<br><a name="341"></a>                <a href="lex.html#130">Lexer</a>->Pos++;
<br><a name="342"></a>            
<br><a name="343"></a>            <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == '\n' && <a href="lex.html#130">Lexer</a>->Pos+1 != <a href="lex.html#130">Lexer</a>->End)
<br><a name="344"></a>            {
<br><a name="345"></a>                <a href="lex.html#130">Lexer</a>->Line++;
<br><a name="346"></a>                <a href="lex.html#130">Lexer</a>->Pos++;
<br><a name="347"></a>                <a href="lex.html#130">Lexer</a>->CharacterPos = 0;
<br><a name="348"></a>                <a href="lex.html#130">Lexer</a>->EmitExtraNewlines++;
<br><a name="349"></a>            }
<br><a name="350"></a>            
<br><a name="351"></a>            <a href="lex.html#327">Escape</a> = FALSE;
<br><a name="352"></a>        }
<br><a name="353"></a>        else <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == '\\')
<br><a name="354"></a>            <a href="lex.html#327">Escape</a> = TRUE;
<br><a name="355"></a>            
<br><a name="356"></a>        LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="357"></a>    }
<br><a name="358"></a>    <a href="lex.html#329">EndPos</a> = <a href="lex.html#130">Lexer</a>->Pos;
<br><a name="359"></a>    
<br><a name="360"></a>    <a href="lex.html#330">EscBuf</a> = <a style="color:green" href="heap.html#67">HeapAllocStack</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#329">EndPos</a> - <a href="lex.html#241">StartPos</a>);
<br><a name="361"></a>    <font color="red">if </font>(<a href="lex.html#330">EscBuf</a> == NULL)
<br><a name="362"></a>        <a style="color:green" href="platform.html#179">LexFail</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, "out of memory");
<br><a name="363"></a>    
<br><a name="364"></a>    <font color="red">for </font>(<a href="lex.html#331"><a href="lex.html#330">EscBuf</a>Pos</a> = <a href="lex.html#330">EscBuf</a>, <a href="lex.html#130">Lexer</a>->Pos = <a href="lex.html#241">StartPos</a>; <a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#329">EndPos</a>;)
<br><a name="365"></a>        *<a href="lex.html#331">EscBufPos</a>++ = <a style="color:green" href="lex.html#280">LexUnEscapeCharacter</a>(&Lexer->Pos, <a href="lex.html#329">EndPos</a>);
<br><a name="366"></a>    
<br><a name="367"></a>    /* try to find an existing copy of this string literal */
<br><a name="368"></a>    Reg<font color="blue">String </font>= <a style="color:green" href="table.html#161">TableStrRegister2</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#330">EscBuf</a>, <a href="lex.html#330">EscBuf</a>Pos - <a href="lex.html#330">EscBuf</a>);
<br><a name="369"></a>    <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#330">EscBuf</a>, <a href="lex.html#329">EndPos</a> - <a href="lex.html#241">StartPos</a>);
<br><a name="370"></a>    <a href="lex.html#333">ArrayValue</a> = <a style="color:green" href="variable.html#441">VariableStringLiteralGet</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#332">RegString</a>);
<br><a name="371"></a>    <font color="red">if </font>(<a href="lex.html#333">ArrayValue</a> == NULL)
<br><a name="372"></a>    {
<br><a name="373"></a>        /* create and store this string literal */
<br><a name="374"></a>        <a href="lex.html#333">ArrayValue</a> = <a style="color:green" href="variable.html#89">VariableAllocValueAndData</a>(<a href="lex.html#87">pc</a>, NULL, 0, FALSE, NULL, TRUE);
<br><a name="375"></a>        <a href="lex.html#333">ArrayValue</a>->Typ = <a href="lex.html#87">pc</a>->CharArrayType;
<br><a name="376"></a>        <a href="lex.html#333">ArrayValue</a>->Val = (union <a href="interpreter_header.html#196">AnyValue</a> *)<a href="lex.html#332">RegString</a>;
<br><a name="377"></a>        <a style="color:green" href="variable.html#452">VariableStringLiteralDefine</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#332">RegString</a>, <a href="lex.html#333">ArrayValue</a>);
<br><a name="378"></a>    }
<br><a name="379"></a>
<br><a name="380"></a>    /* create the the pointer <font color="red">for </font>this char* */
<br><a name="381"></a>    <a href="interpreter_header.html#217">Value</a>->Typ = <a href="lex.html#87">pc</a>->CharPtrType;
<br><a name="382"></a>    <a href="interpreter_header.html#217">Value</a>->Val->Pointer = <a href="lex.html#332">RegString</a>;
<br><a name="383"></a>    <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == <a href="lex.html#325">EndChar</a>)
<br><a name="384"></a>        LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="385"></a>    
<br><a name="386"></a>    <font color="red">return </font>TokenStringConstant;
<br><a name="387"></a>}
<br><a name="388"></a>
<br><a name="389"></a>/* get a character constant - used <font color="red">while </font>scanning */
<br><a name="390"></a>enum LexToken LexGetCharacterConstant(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#288">LexState</a> *<a href="lex.html#130">Lexer</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *<a href="interpreter_header.html#217">Value</a>)
<br><a name="391"></a>{
<br><a name="392"></a>    <a href="interpreter_header.html#217">Value</a>->Typ = &pc->CharType;
<br><a name="393"></a>    <a href="interpreter_header.html#217">Value</a>->Val->Character = <a style="color:green" href="lex.html#280">LexUnEscapeCharacter</a>(&<a href="lex.html#130">Lexer</a>->Pos, <a href="lex.html#130">Lexer</a>->End);
<br><a name="394"></a>    <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && *<a href="lex.html#130">Lexer</a>->Pos != '\'')
<br><a name="395"></a>        <a style="color:green" href="platform.html#179">LexFail</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, "expected \"'\"");
<br><a name="396"></a>        
<br><a name="397"></a>    LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="398"></a>    <font color="red">return </font>TokenCharacterConstant;
<br><a name="399"></a>}
<br><a name="400"></a>
<br><a name="401"></a>/* skip a comment - used <font color="red">while </font>scanning */
<br><a name="402"></a>void LexSkipComment(<font color="blue">struct </font><a href="interpreter_header.html#288">LexState</a> *<a href="lex.html#130">Lexer</a>, <font color="blue">char </font><a href="lex.html#432">NextChar</a>, enum LexToken *ReturnToken)
<br><a name="403"></a>{
<br><a name="404"></a>    <font color="red">if </font>(<a href="lex.html#402">NextChar</a> == '*')
<br><a name="405"></a>    {   
<br><a name="406"></a>        /* conventional C comment */
<br><a name="407"></a>        <font color="red">while </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && (*(<a href="lex.html#130">Lexer</a>->Pos-1) != '*' || *<a href="lex.html#130">Lexer</a>->Pos != '/'))
<br><a name="408"></a>        {
<br><a name="409"></a>            <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == '\n')
<br><a name="410"></a>                <a href="lex.html#130">Lexer</a>->EmitExtraNewlines++;
<br><a name="411"></a>
<br><a name="412"></a>            LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="413"></a>        }
<br><a name="414"></a>        
<br><a name="415"></a>        <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End)
<br><a name="416"></a>            LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="417"></a>        
<br><a name="418"></a>        <a href="lex.html#130">Lexer</a>->Mode = LexModeNormal;
<br><a name="419"></a>    }
<br><a name="420"></a>    else
<br><a name="421"></a>    {   
<br><a name="422"></a>        /* C++ style comment */
<br><a name="423"></a>        <font color="red">while </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && *<a href="lex.html#130">Lexer</a>->Pos != '\n')
<br><a name="424"></a>            LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="425"></a>    }
<br><a name="426"></a>}
<br><a name="427"></a>
<br><a name="428"></a>/* get a single token from the source - used <font color="red">while </font>scanning */
<br><a name="429"></a>enum LexToken LexScanGetToken(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#288">LexState</a> *<a href="lex.html#130">Lexer</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> **<a href="interpreter_header.html#217">Value</a>)
<br><a name="430"></a>{
<br><a name="431"></a>    <font color="blue">char </font><a href="lex.html#282">ThisChar</a>;
<br><a name="432"></a>    <font color="blue">char </font><a href="lex.html#402">NextChar</a>;
<br><a name="433"></a>    enum LexToken GotToken = TokenNone;
<br><a name="434"></a>    
<br><a name="435"></a>    /* handle cases line multi-line comments or string constants which mess up the line count */
<br><a name="436"></a>    <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->EmitExtraNewlines > 0)
<br><a name="437"></a>    {
<br><a name="438"></a>        <a href="lex.html#130">Lexer</a>->EmitExtraNewlines--;
<br><a name="439"></a>        <font color="red">return </font>TokenEndOfLine;
<br><a name="440"></a>    }
<br><a name="441"></a>    
<br><a name="442"></a>    /* scan <font color="red">for </font>a token */
<br><a name="443"></a>    do
<br><a name="444"></a>    {
<br><a name="445"></a>        *<a href="interpreter_header.html#217">Value</a> = &pc->Lex<a href="interpreter_header.html#217">Value</a>;
<br><a name="446"></a>        <font color="red">while </font>(<a href="lex.html#130">Lexer</a>->Pos != <a href="lex.html#130">Lexer</a>->End && isspace((int)*<a href="lex.html#130">Lexer</a>->Pos))
<br><a name="447"></a>        {
<br><a name="448"></a>            <font color="red">if </font>(*<a href="lex.html#130">Lexer</a>->Pos == '\n')
<br><a name="449"></a>            {
<br><a name="450"></a>                <a href="lex.html#130">Lexer</a>->Line++;
<br><a name="451"></a>                <a href="lex.html#130">Lexer</a>->Pos++;
<br><a name="452"></a>                <a href="lex.html#130">Lexer</a>->Mode = LexModeNormal;
<br><a name="453"></a>                <a href="lex.html#130">Lexer</a>->CharacterPos = 0;
<br><a name="454"></a>                <font color="red">return </font>TokenEndOfLine;
<br><a name="455"></a>            }
<br><a name="456"></a>            else <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Mode == LexModeHashDefine || <a href="lex.html#130">Lexer</a>->Mode == LexModeHashDefineSpace)
<br><a name="457"></a>                <a href="lex.html#130">Lexer</a>->Mode = LexModeHashDefineSpace;
<br><a name="458"></a>            
<br><a name="459"></a>            else <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Mode == LexModeHashDefineSpaceIdent)
<br><a name="460"></a>                <a href="lex.html#130">Lexer</a>->Mode = LexModeNormal;
<br><a name="461"></a>    
<br><a name="462"></a>            LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="463"></a>        }
<br><a name="464"></a>        
<br><a name="465"></a>        <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Pos == <a href="lex.html#130">Lexer</a>->End || *<a href="lex.html#130">Lexer</a>->Pos == '\0')
<br><a name="466"></a>            <font color="red">return </font>TokenEOF;
<br><a name="467"></a>        
<br><a name="468"></a>        <a href="lex.html#282">ThisChar</a> = *<a href="lex.html#130">Lexer</a>->Pos;
<br><a name="469"></a>        <font color="red">if </font>(isCidstart((int)<a href="lex.html#282">ThisChar</a>))
<br><a name="470"></a>            <font color="red">return </font><a style="color:green" href="lex.html#239">LexGetWord</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, *<a href="interpreter_header.html#217">Value</a>);
<br><a name="471"></a>        
<br><a name="472"></a>        <font color="red">if </font>(isdigit((int)<a href="lex.html#282">ThisChar</a>))
<br><a name="473"></a>            <font color="red">return </font><a style="color:green" href="lex.html#130">LexGetNumber</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, *<a href="interpreter_header.html#217">Value</a>);
<br><a name="474"></a>        
<br><a name="475"></a>        <a href="lex.html#402">NextChar</a> = (<a href="lex.html#130">Lexer</a>->Pos+1 != <a href="lex.html#130">Lexer</a>->End) ? *(<a href="lex.html#130">Lexer</a>->Pos+1) : 0;
<br><a name="476"></a>        LEXER_INC(<a href="lex.html#130">Lexer</a>);
<br><a name="477"></a>        switch (<a href="lex.html#282">ThisChar</a>)
<br><a name="478"></a>        {
<br><a name="479"></a>            case '"': <a href="lex.html#433">GotToken</a> = <a style="color:green" href="lex.html#325">LexGetStringConstant</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, *<a href="interpreter_header.html#217">Value</a>, '"'); break;
<br><a name="480"></a>            case '\'': <a href="lex.html#433">GotToken</a> = <a style="color:green" href="lex.html#390">LexGetCharacterConstant</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, *<a href="interpreter_header.html#217">Value</a>); break;
<br><a name="481"></a>            case '(': <font color="red">if </font>(<a href="lex.html#130">Lexer</a>->Mode == LexModeHashDefineSpaceIdent) <a href="lex.html#433">GotToken</a> = TokenOpenMacroBracket; else <a href="lex.html#433">GotToken</a> = TokenOpenBracket; <a href="lex.html#130">Lexer</a>->Mode = LexModeNormal; break;
<br><a name="482"></a>            case ')': <a href="lex.html#433">GotToken</a> = TokenCloseBracket; break;
<br><a name="483"></a>            case '=': NEXTIS('=', TokenEqual, TokenAssign); break;
<br><a name="484"></a>            case '+': NEXTIS3('=', TokenAddAssign, '+', TokenIncrement, TokenPlus); break;
<br><a name="485"></a>            case '-': NEXTIS4('=', TokenSubtractAssign, '>', TokenArrow, '-', TokenDecrement, TokenMinus); break;
<br><a name="486"></a>            case '*': NEXTIS('=', TokenMultiplyAssign, TokenAsterisk); break;
<br><a name="487"></a>            case '/': <font color="red">if </font>(<a href="lex.html#402">NextChar</a> == '/' || <a href="lex.html#402">NextChar</a> == '*') { LEXER_INC(<a href="lex.html#130">Lexer</a>); <a style="color:green" href="lex.html#402">LexSkipComment</a>(<a href="lex.html#130">Lexer</a>, <a href="lex.html#402">NextChar</a>, &GotToken); } else NEXTIS('=', TokenDivideAssign, TokenSlash); break;
<br><a name="488"></a>            case '%': NEXTIS('=', TokenModulusAssign, TokenModulus); break;
<br><a name="489"></a>            case '&lt;': <font color="red">if </font>(<a href="lex.html#130">Lexer</a>-&gt;Mode == LexModeHashInclude) <a href="lex.html#433">GotToken</a> = <a style="color:green" href="lex.html#325">LexGetStringConstant</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, *<a href="interpreter_header.html#217">Value</a>, '&gt;'); else { NEXTIS3PLUS('=', TokenLessEqual, '&lt;', TokenShiftLeft, '=', TokenShiftLeftAssign, TokenLessThan); } break; 
<br><a name="490"></a>            case '>': NEXTIS3PLUS('=', TokenGreaterEqual, '>', TokenShiftRight, '=', TokenShiftRightAssign, TokenGreaterThan); break;
<br><a name="491"></a>            case ';': <a href="lex.html#433">GotToken</a> = TokenSemicolon; break;
<br><a name="492"></a>            case '&': NEXTIS3('=', TokenArithmeticAndAssign, '&', TokenLogicalAnd, TokenAmpersand); break;
<br><a name="493"></a>            case '|': NEXTIS3('=', TokenArithmeticOrAssign, '|', TokenLogicalOr, TokenArithmeticOr); break;
<br><a name="494"></a>            case '{': <a href="lex.html#433">GotToken</a> = TokenLeftBrace; break;
<br><a name="495"></a>            case '}': <a href="lex.html#433">GotToken</a> = TokenRightBrace; break;
<br><a name="496"></a>            case '<font color="red">[</font>': <a href="lex.html#433">GotToken</a> = TokenLeftSquareBracket; break;
<br><a name="497"></a>            case '<font color="red">]</font>': <a href="lex.html#433">GotToken</a> = TokenRightSquareBracket; break;
<br><a name="498"></a>            case '!': NEXTIS('=', TokenNotEqual, TokenUnaryNot); break;
<br><a name="499"></a>            case '^': NEXTIS('=', TokenArithmeticExorAssign, TokenArithmeticExor); break;
<br><a name="500"></a>            case '~': <a href="lex.html#433">GotToken</a> = TokenUnaryExor; break;
<br><a name="501"></a>            case ',': <a href="lex.html#433">GotToken</a> = TokenComma; break;
<br><a name="502"></a>            case '.': NEXTISEXACTLY3('.', '.', TokenEllipsis, TokenDot); break;
<br><a name="503"></a>            case '?': <a href="lex.html#433">GotToken</a> = TokenQuestionMark; break;
<br><a name="504"></a>            case ':': <a href="lex.html#433">GotToken</a> = TokenColon; break;
<br><a name="505"></a>            default:  <a style="color:green" href="platform.html#179">LexFail</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, "illegal character '%c'", <a href="lex.html#282">ThisChar</a>); break;
<br><a name="506"></a>        }
<br><a name="507"></a>    } <font color="red">while </font>(<a href="lex.html#433">GotToken</a> == TokenNone);
<br><a name="508"></a>    
<br><a name="509"></a>    <font color="red">return </font><a href="lex.html#433">GotToken</a>;
<br><a name="510"></a>}
<br><a name="511"></a>
<br><a name="512"></a>/* what size value goes with each token */
<br><a name="513"></a><font color="blue">int </font>Lex<a href="lex.html#242">Token</a>Size(enum Lex<a href="lex.html#242">Token</a> <a href="lex.html#242">Token</a>)
<br><a name="514"></a>{
<br><a name="515"></a>    switch (<a href="lex.html#242">Token</a>)
<br><a name="516"></a>    {
<br><a name="517"></a>        case TokenIdentifier: case TokenStringConstant: <font color="red">return </font>sizeof(<font color="blue">char </font>*);
<br><a name="518"></a>        case TokenIntegerConstant: <font color="red">return </font>sizeof(long);
<br><a name="519"></a>        case TokenCharacterConstant: <font color="red">return </font>sizeof(<font color="blue">unsigned </font>char);
<br><a name="520"></a>        case TokenFPConstant: <font color="red">return </font>sizeof(double);
<br><a name="521"></a>        default: <font color="red">return </font>0;
<br><a name="522"></a>    }
<br><a name="523"></a>}
<br><a name="524"></a>
<br><a name="525"></a>/* produce tokens from the lexer and <font color="red">return </font>a heap buffer with the result - used <font color="red">for </font>scanning */
<br><a name="526"></a>void *LexTokenise(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#288">LexState</a> *<a href="lex.html#130">Lexer</a>, <font color="blue">int </font>*TokenLen)
<br><a name="527"></a>{
<br><a name="528"></a>    enum Lex<a href="lex.html#242">Token</a> <a href="lex.html#242">Token</a>;
<br><a name="529"></a>    void *HeapMem;
<br><a name="530"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Got<a href="interpreter_header.html#217">Value</a>;
<br><a name="531"></a>    <font color="blue">int </font>MemUsed = 0;
<br><a name="532"></a>    <font color="blue">int </font><a href="lex.html#629">ValueSize</a>;
<br><a name="533"></a>    <font color="blue">int </font>ReserveSpace = (<a href="lex.html#130">Lexer</a>->End - <a href="lex.html#130">Lexer</a>->Pos) * 4 + 16; 
<br><a name="534"></a>    void *TokenSpace = <a style="color:green" href="heap.html#67">HeapAllocStack</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#533">ReserveSpace</a>);
<br><a name="535"></a>    <font color="blue">char </font>*TokenPos = (<font color="blue">char </font>*)<a href="lex.html#534">TokenSpace</a>;
<br><a name="536"></a>    <font color="blue">int </font>LastCharacterPos = 0;
<br><a name="537"></a>
<br><a name="538"></a>    <font color="red">if </font>(<a href="lex.html#534">TokenSpace</a> == NULL)
<br><a name="539"></a>        <a style="color:green" href="platform.html#179">LexFail</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, "out of memory");
<br><a name="540"></a>    
<br><a name="541"></a>    do
<br><a name="542"></a>    { 
<br><a name="543"></a>        /* store the token at the end of the stack area */
<br><a name="544"></a>        <a href="lex.html#242">Token</a> = LexScanGet<a href="lex.html#242">Token</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, &GotValue);
<br><a name="545"></a>
<br><a name="546"></a>#ifdef DEBUG_LEXER
<br><a name="547"></a>        printf("<a href="lex.html#242">Token</a>: %02x\n", <a href="lex.html#242">Token</a>);
<br><a name="548"></a>#endif
<br><a name="549"></a>        *(<font color="blue">unsigned </font><font color="blue">char </font>*)<a href="lex.html#535"><a href="lex.html#242">Token</a>Pos</a> = <a href="lex.html#242">Token</a>;
<br><a name="550"></a>        <a href="lex.html#535">TokenPos</a>++;
<br><a name="551"></a>        <a href="lex.html#531">MemUsed</a>++;
<br><a name="552"></a>
<br><a name="553"></a>        *(<font color="blue">unsigned </font><font color="blue">char </font>*)<a href="lex.html#535">TokenPos</a> = (<font color="blue">unsigned </font>char)<a href="lex.html#536">LastCharacterPos</a>;
<br><a name="554"></a>        <a href="lex.html#535">TokenPos</a>++;
<br><a name="555"></a>        <a href="lex.html#531">MemUsed</a>++;
<br><a name="556"></a>
<br><a name="557"></a>        <a href="lex.html#532">ValueSize</a> = <a style="color:green" href="lex.html#513">Lex<a href="lex.html#242">Token</a>Size</a>(<a href="lex.html#242">Token</a>);
<br><a name="558"></a>        <font color="red">if </font>(<a href="lex.html#532">ValueSize</a> > 0)
<br><a name="559"></a>        { 
<br><a name="560"></a>            /* store a value as well */
<br><a name="561"></a>            memcpy((void *)<a href="lex.html#535">TokenPos</a>, (void *)<a href="lex.html#530">GotValue</a>->Val, <a href="lex.html#532">ValueSize</a>);
<br><a name="562"></a>            <a href="lex.html#535">TokenPos</a> += <a href="lex.html#532">ValueSize</a>;
<br><a name="563"></a>            <a href="lex.html#531">MemUsed</a> += <a href="lex.html#532">ValueSize</a>;
<br><a name="564"></a>        }
<br><a name="565"></a>    
<br><a name="566"></a>        <a href="lex.html#536">LastCharacterPos</a> = <a href="lex.html#130">Lexer</a>->CharacterPos;
<br><a name="567"></a>                    
<br><a name="568"></a>    } <font color="red">while </font>(<a href="lex.html#242">Token</a> != <a href="lex.html#242">Token</a>EOF);
<br><a name="569"></a>    
<br><a name="570"></a>    <a href="lex.html#529">HeapMem</a> = <a style="color:green" href="heap.html#135">HeapAllocMem</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#531">MemUsed</a>);
<br><a name="571"></a>    <font color="red">if </font>(<a href="lex.html#529">HeapMem</a> == NULL)
<br><a name="572"></a>        <a style="color:green" href="platform.html#179">LexFail</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#130">Lexer</a>, "out of memory");
<br><a name="573"></a>        
<br><a name="574"></a>    assert(<a href="lex.html#533">ReserveSpace</a> >= <a href="lex.html#531">MemUsed</a>);
<br><a name="575"></a>    memcpy(<a href="lex.html#529">HeapMem</a>, <a href="lex.html#534">TokenSpace</a>, <a href="lex.html#531">MemUsed</a>);
<br><a name="576"></a>    <a style="color:green" href="heap.html#92">HeapPopStack</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#534">TokenSpace</a>, <a href="lex.html#533">ReserveSpace</a>);
<br><a name="577"></a>#ifdef DEBUG_LEXER
<br><a name="578"></a>    {
<br><a name="579"></a>        <font color="blue">int </font><a href="lex.html#89">Count</a>;
<br><a name="580"></a>        printf("Tokens: ");
<br><a name="581"></a>        <font color="red">for </font>(<a href="lex.html#89">Count</a> = 0; <a href="lex.html#89">Count</a> < <a href="lex.html#531">MemUsed</a>; <a href="lex.html#89">Count</a>++)
<br><a name="582"></a>            printf("%02x ", *((<font color="blue">unsigned </font><font color="blue">char </font>*)<a href="lex.html#529">HeapMem</a>+<a href="lex.html#89">Count</a>));
<br><a name="583"></a>        printf("\n");
<br><a name="584"></a>    }
<br><a name="585"></a>#endif
<br><a name="586"></a>    <font color="red">if </font>(<a href="lex.html#526">TokenLen</a>)
<br><a name="587"></a>        *<a href="lex.html#526">TokenLen</a> = <a href="lex.html#531">MemUsed</a>;
<br><a name="588"></a>    
<br><a name="589"></a>    <font color="red">return </font><a href="lex.html#529">HeapMem</a>;
<br><a name="590"></a>}
<br><a name="591"></a>
<br><a name="592"></a>/* lexically analyse some source text */
<br><a name="593"></a>void *LexAnalyse(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, const <font color="blue">char </font>*FileName, const <font color="blue">char </font>*Source, <font color="blue">int </font>SourceLen, <font color="blue">int </font>*<a href="lex.html#526">TokenLen</a>)
<br><a name="594"></a>{
<br><a name="595"></a>    <font color="blue">struct </font><a href="interpreter_header.html#288">LexState</a> <a href="lex.html#130">Lexer</a>;
<br><a name="596"></a>    
<br><a name="597"></a>    <a href="lex.html#130">Lexer</a>.Pos = <a href="lex.html#593">Source</a>;
<br><a name="598"></a>    <a href="lex.html#130">Lexer</a>.End = <a href="lex.html#593">Source</a> + <a href="lex.html#593">Source</a>Len;
<br><a name="599"></a>    <a href="lex.html#130">Lexer</a>.Line = 1;
<br><a name="600"></a>    <a href="lex.html#130">Lexer</a>.<a href="lex.html#593">FileName</a> = <a href="lex.html#593">FileName</a>;
<br><a name="601"></a>    <a href="lex.html#130">Lexer</a>.Mode = LexModeNormal;
<br><a name="602"></a>    <a href="lex.html#130">Lexer</a>.EmitExtraNewlines = 0;
<br><a name="603"></a>    <a href="lex.html#130">Lexer</a>.CharacterPos = 1;
<br><a name="604"></a>    <a href="lex.html#130">Lexer</a>.<a href="lex.html#593">Source</a>Text = <a href="lex.html#593">Source</a>;
<br><a name="605"></a>    
<br><a name="606"></a>    <font color="red">return </font><a style="color:green" href="lex.html#526">LexTokenise</a>(<a href="lex.html#87">pc</a>, &Lexer, <a href="lex.html#526">TokenLen</a>);
<br><a name="607"></a>}
<br><a name="608"></a>
<br><a name="609"></a>/* prepare to parse a pre-tokenised buffer */
<br><a name="610"></a>void LexInitParser(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *Parser, <a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, const <font color="blue">char </font>*SourceText, void *TokenSource, <font color="blue">char </font>*<a href="lex.html#593">FileName</a>, <font color="blue">int </font>RunIt, <font color="blue">int </font>EnableDebugger)
<br><a name="611"></a>{
<br><a name="612"></a>    <a href="lex.html#610">Parser</a>-><a href="lex.html#87">pc</a> = <a href="lex.html#87">pc</a>;
<br><a name="613"></a>    <a href="lex.html#610">Parser</a>->Pos = <a href="lex.html#610">TokenSource</a>;
<br><a name="614"></a>    <a href="lex.html#610">Parser</a>->Line = 1;
<br><a name="615"></a>    <a href="lex.html#610">Parser</a>-><a href="lex.html#593">FileName</a> = <a href="lex.html#593">FileName</a>;
<br><a name="616"></a>    <a href="lex.html#610">Parser</a>->Mode = <a href="lex.html#610">RunIt</a> ? RunModeRun : RunModeSkip;
<br><a name="617"></a>    <a href="lex.html#610">Parser</a>->SearchLabel = 0;
<br><a name="618"></a>    <a href="lex.html#610">Parser</a>->HashIfLevel = 0;
<br><a name="619"></a>    <a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel = 0;
<br><a name="620"></a>    <a href="lex.html#610">Parser</a>->CharacterPos = 0;
<br><a name="621"></a>    <a href="lex.html#610">Parser</a>-><a href="lex.html#610">SourceText</a> = <a href="lex.html#610">SourceText</a>;
<br><a name="622"></a>    <a href="lex.html#610">Parser</a>->DebugMode = <a href="lex.html#610">EnableDebugger</a>;
<br><a name="623"></a>}
<br><a name="624"></a>
<br><a name="625"></a>/* get the next token, without pre-processing */
<br><a name="626"></a>enum LexToken LexGetRawToken(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> **<a href="interpreter_header.html#217">Value</a>, <font color="blue">int </font>IncPos)
<br><a name="627"></a>{
<br><a name="628"></a>    enum Lex<a href="lex.html#242">Token</a> <a href="lex.html#242">Token</a> = <a href="lex.html#242">Token</a>None;
<br><a name="629"></a>    <font color="blue">int </font><a href="lex.html#532">ValueSize</a>;
<br><a name="630"></a>    <font color="blue">char </font>*Prompt = NULL;
<br><a name="631"></a>    <a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a> = <a href="lex.html#610">Parser</a>-><a href="lex.html#87">pc</a>;
<br><a name="632"></a>    
<br><a name="633"></a>    do
<br><a name="634"></a>    { 
<br><a name="635"></a>        /* get the next token */
<br><a name="636"></a>        <font color="red">if </font>(<a href="lex.html#610">Parser</a>->Pos == NULL && <a href="lex.html#87">pc</a>->InteractiveHead != NULL)
<br><a name="637"></a>            <a href="lex.html#610">Parser</a>->Pos = <a href="lex.html#87">pc</a>->InteractiveHead->Tokens;
<br><a name="638"></a>        
<br><a name="639"></a>        <font color="red">if </font>(<a href="lex.html#610">Parser</a>->FileName != <a href="lex.html#87">pc</a>->StrEmpty || <a href="lex.html#87">pc</a>->InteractiveHead != NULL)
<br><a name="640"></a>        { 
<br><a name="641"></a>            /* skip leading newlines */
<br><a name="642"></a>            <font color="red">while </font>((<a href="lex.html#242">Token</a> = (enum Lex<a href="lex.html#242">Token</a>)*(<font color="blue">unsigned </font><font color="blue">char </font>*)<a href="lex.html#610">Parser</a>->Pos) == <a href="lex.html#242">Token</a>EndOfLine)
<br><a name="643"></a>            {
<br><a name="644"></a>                <a href="lex.html#610">Parser</a>->Line++;
<br><a name="645"></a>                <a href="lex.html#610">Parser</a>->Pos += TOKEN_DATA_OFFSET;
<br><a name="646"></a>            }
<br><a name="647"></a>        }
<br><a name="648"></a>    
<br><a name="649"></a>        <font color="red">if </font>(<a href="lex.html#610">Parser</a>->FileName == <a href="lex.html#87">pc</a>->StrEmpty && (<a href="lex.html#87">pc</a>->InteractiveHead == NULL || <a href="lex.html#242">Token</a> == <a href="lex.html#242">Token</a>EOF))
<br><a name="650"></a>        { 
<br><a name="651"></a>            /* we're at the end of an interactive input token list */
<br><a name="652"></a>            <font color="blue">char </font>LineBuffer<font color="red">[</font>LINEBUFFER_MAX<font color="red">]</font>;
<br><a name="653"></a>            void *LineTokens;
<br><a name="654"></a>            <font color="blue">int </font>LineBytes;
<br><a name="655"></a>            <font color="blue">struct </font><a href="interpreter_header.html#339">TokenLine</a> *LineNode;
<br><a name="656"></a>            
<br><a name="657"></a>            <font color="red">if </font>(<a href="lex.html#87">pc</a>->InteractiveHead == NULL || (<font color="blue">unsigned </font><font color="blue">char </font>*)<a href="lex.html#610">Parser</a>->Pos == &<a href="lex.html#87">pc</a>->InteractiveTail->Tokens<font color="red">[</font><a href="lex.html#87">pc</a>->InteractiveTail->NumBytes-TOKEN_DATA_OFFSET<font color="red">]</font>)
<br><a name="658"></a>            { 
<br><a name="659"></a>                /* get interactive input */
<br><a name="660"></a>                <font color="red">if </font>(<a href="lex.html#87">pc</a>->LexUseStatementPrompt)
<br><a name="661"></a>                {
<br><a name="662"></a>                    <a href="lex.html#630">Prompt</a> = INTERACTIVE_PROMPT_STATEMENT;
<br><a name="663"></a>                    <a href="lex.html#87">pc</a>->LexUseStatementPrompt = FALSE;
<br><a name="664"></a>                }
<br><a name="665"></a>                else
<br><a name="666"></a>                    <a href="lex.html#630">Prompt</a> = INTERACTIVE_PROMPT_LINE;
<br><a name="667"></a>                    
<br><a name="668"></a>                <font color="red">if </font>(<a style="color:green" href="platform_unix.html#39">PlatformGetLine</a>(&LineBuffer<font color="red">[</font>0<font color="red">]</font>, LINEBUFFER_MAX, <a href="lex.html#630">Prompt</a>) == NULL)
<br><a name="669"></a>                    <font color="red">return </font>TokenEOF;
<br><a name="670"></a>
<br><a name="671"></a>                /* put the new line at the end of the linked list of interactive lines */        
<br><a name="672"></a>                <a href="lex.html#653">LineTokens</a> = <a style="color:green" href="lex.html#593">LexAnalyse</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#87">pc</a>->StrEmpty, &<a href="lex.html#652">LineBuffer</a><font color="red">[</font>0<font color="red">]</font>, strlen(<a href="lex.html#652">LineBuffer</a>), &LineBytes);
<br><a name="673"></a>                <a href="lex.html#655">LineNode</a> = <a style="color:green" href="variable.html#68">VariableAlloc</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#610">Parser</a>, sizeof(<font color="blue">struct </font><a href="interpreter_header.html#339">TokenLine</a>), TRUE);
<br><a name="674"></a>                <a href="lex.html#655">LineNode</a>->Tokens = <a href="lex.html#653">LineTokens</a>;
<br><a name="675"></a>                <a href="lex.html#655">LineNode</a>->NumBytes = <a href="lex.html#654">LineBytes</a>;
<br><a name="676"></a>                <font color="red">if </font>(<a href="lex.html#87">pc</a>->InteractiveHead == NULL)
<br><a name="677"></a>                { 
<br><a name="678"></a>                    /* start a new list */
<br><a name="679"></a>                    <a href="lex.html#87">pc</a>->InteractiveHead = <a href="lex.html#655">LineNode</a>;
<br><a name="680"></a>                    <a href="lex.html#610">Parser</a>->Line = 1;
<br><a name="681"></a>                    <a href="lex.html#610">Parser</a>->CharacterPos = 0;
<br><a name="682"></a>                }
<br><a name="683"></a>                else
<br><a name="684"></a>                    <a href="lex.html#87">pc</a>->InteractiveTail->Next = <a href="lex.html#655">LineNode</a>;
<br><a name="685"></a>
<br><a name="686"></a>                <a href="lex.html#87">pc</a>->InteractiveTail = <a href="lex.html#655">LineNode</a>;
<br><a name="687"></a>                <a href="lex.html#87">pc</a>->InteractiveCurrentLine = <a href="lex.html#655">LineNode</a>;
<br><a name="688"></a>                <a href="lex.html#610">Parser</a>->Pos = <a href="lex.html#653">LineTokens</a>;
<br><a name="689"></a>            }
<br><a name="690"></a>            else
<br><a name="691"></a>            { 
<br><a name="692"></a>                /* go to the next token line */
<br><a name="693"></a>                <font color="red">if </font>(<a href="lex.html#610">Parser</a>->Pos != &pc->InteractiveCurrentLine->Tokens<font color="red">[</font>pc->InteractiveCurrentLine->NumBytes-TOKEN_DATA_OFFSET<font color="red">]</font>)
<br><a name="694"></a>                { 
<br><a name="695"></a>                    /* scan <font color="red">for </font>the line */
<br><a name="696"></a>                    <font color="red">for </font>(<a href="lex.html#87">pc</a>->InteractiveCurrentLine = <a href="lex.html#87">pc</a>->InteractiveHead; <a href="lex.html#610">Parser</a>->Pos != &<a href="lex.html#87">pc</a>->InteractiveCurrentLine->Tokens<font color="red">[</font><a href="lex.html#87">pc</a>->InteractiveCurrentLine->NumBytes-TOKEN_DATA_OFFSET<font color="red">]</font>; <a href="lex.html#87">pc</a>->InteractiveCurrentLine = <a href="lex.html#87">pc</a>->InteractiveCurrentLine->Next)
<br><a name="697"></a>                    { assert(<a href="lex.html#87">pc</a>->InteractiveCurrentLine->Next != NULL); }
<br><a name="698"></a>                }
<br><a name="699"></a>
<br><a name="700"></a>                assert(<a href="lex.html#87">pc</a>->InteractiveCurrentLine != NULL);
<br><a name="701"></a>                <a href="lex.html#87">pc</a>->InteractiveCurrentLine = <a href="lex.html#87">pc</a>->InteractiveCurrentLine->Next;
<br><a name="702"></a>                assert(<a href="lex.html#87">pc</a>->InteractiveCurrentLine != NULL);
<br><a name="703"></a>                <a href="lex.html#610">Parser</a>->Pos = <a href="lex.html#87">pc</a>->InteractiveCurrentLine->Tokens;
<br><a name="704"></a>            }
<br><a name="705"></a>
<br><a name="706"></a>            <a href="lex.html#242">Token</a> = (enum Lex<a href="lex.html#242">Token</a>)*(<font color="blue">unsigned </font><font color="blue">char </font>*)<a href="lex.html#610">Parser</a>->Pos;
<br><a name="707"></a>        }
<br><a name="708"></a>    } <font color="red">while </font>((<a href="lex.html#610">Parser</a>->FileName == <a href="lex.html#87">pc</a>->StrEmpty && <a href="lex.html#242">Token</a> == <a href="lex.html#242">Token</a>EOF) || <a href="lex.html#242">Token</a> == <a href="lex.html#242">Token</a>EndOfLine);
<br><a name="709"></a>
<br><a name="710"></a>    <a href="lex.html#610">Parser</a>->CharacterPos = *((<font color="blue">unsigned </font><font color="blue">char </font>*)<a href="lex.html#610">Parser</a>->Pos + 1);
<br><a name="711"></a>    <a href="lex.html#532">ValueSize</a> = <a style="color:green" href="lex.html#513">Lex<a href="lex.html#242">Token</a>Size</a>(<a href="lex.html#242">Token</a>);
<br><a name="712"></a>    <font color="red">if </font>(<a href="lex.html#532">ValueSize</a> > 0)
<br><a name="713"></a>    { 
<br><a name="714"></a>        /* this token requires a value - unpack it */
<br><a name="715"></a>        <font color="red">if </font>(<a href="interpreter_header.html#217">Value</a> != NULL)
<br><a name="716"></a>        { 
<br><a name="717"></a>            switch (<a href="lex.html#242">Token</a>)
<br><a name="718"></a>            {
<br><a name="719"></a>                case TokenStringConstant:       <a href="lex.html#87">pc</a>->LexValue.Typ = <a href="lex.html#87">pc</a>->CharPtrType; break;
<br><a name="720"></a>                case TokenIdentifier:           <a href="lex.html#87">pc</a>->LexValue.Typ = NULL; break;
<br><a name="721"></a>                case TokenIntegerConstant:      <a href="lex.html#87">pc</a>->LexValue.Typ = &<a href="lex.html#87">pc</a>->LongType; break;
<br><a name="722"></a>                case TokenCharacterConstant:    <a href="lex.html#87">pc</a>->LexValue.Typ = &<a href="lex.html#87">pc</a>->CharType; break;
<br><a name="723"></a>#ifndef NO_FP
<br><a name="724"></a>                case TokenFPConstant:           <a href="lex.html#87">pc</a>->LexValue.Typ = &<a href="lex.html#87">pc</a>->FPType; break;
<br><a name="725"></a>#endif
<br><a name="726"></a>                default: break;
<br><a name="727"></a>            }
<br><a name="728"></a>            
<br><a name="729"></a>            memcpy((void *)<a href="lex.html#87">pc</a>->LexValue.Val, (void *)((<font color="blue">char </font>*)<a href="lex.html#610">Parser</a>->Pos + TOKEN_DATA_OFFSET), <a href="lex.html#532">ValueSize</a>);
<br><a name="730"></a>            <a href="lex.html#87">pc</a>->LexValue.ValOnHeap = FALSE;
<br><a name="731"></a>            <a href="lex.html#87">pc</a>->LexValue.ValOnStack = FALSE;
<br><a name="732"></a>            <a href="lex.html#87">pc</a>->LexValue.IsLValue = FALSE;
<br><a name="733"></a>            <a href="lex.html#87">pc</a>->LexValue.LValueFrom = NULL;
<br><a name="734"></a>            *<a href="interpreter_header.html#217">Value</a> = &pc->Lex<a href="interpreter_header.html#217">Value</a>;
<br><a name="735"></a>        }
<br><a name="736"></a>        
<br><a name="737"></a>        <font color="red">if </font>(<a href="lex.html#626">IncPos</a>)
<br><a name="738"></a>            <a href="lex.html#610">Parser</a>->Pos += <a href="lex.html#532">ValueSize</a> + TOKEN_DATA_OFFSET;
<br><a name="739"></a>    }
<br><a name="740"></a>    else
<br><a name="741"></a>    {
<br><a name="742"></a>        <font color="red">if </font>(<a href="lex.html#626">IncPos</a> && <a href="lex.html#242">Token</a> != <a href="lex.html#242">Token</a>EOF)
<br><a name="743"></a>            <a href="lex.html#610">Parser</a>->Pos += TOKEN_DATA_OFFSET;
<br><a name="744"></a>    }
<br><a name="745"></a>    
<br><a name="746"></a>#ifdef DEBUG_LEXER
<br><a name="747"></a>    printf("Got token=%02x inc=%d pos=%d\n", <a href="lex.html#242">Token</a>, <a href="lex.html#626">IncPos</a>, <a href="lex.html#610">Parser</a>->CharacterPos);
<br><a name="748"></a>#endif
<br><a name="749"></a>    assert(<a href="lex.html#242">Token</a> >= <a href="lex.html#242">Token</a>None && <a href="lex.html#242">Token</a> <= <a href="lex.html#242">Token</a>EndOfFunction);
<br><a name="750"></a>    <font color="red">return </font><a href="lex.html#242">Token</a>;
<br><a name="751"></a>}
<br><a name="752"></a>
<br><a name="753"></a>/* correct the token position depending <font color="red">if </font>we already incremented the position */
<br><a name="754"></a>void LexHash<a href="lex.html#626">IncPos</a>(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>, <font color="blue">int </font><a href="lex.html#626">IncPos</a>)
<br><a name="755"></a>{
<br><a name="756"></a>    <font color="red">if </font>(!IncPos)
<br><a name="757"></a>        <a style="color:green" href="lex.html#626">LexGetRawToken</a>(<a href="lex.html#610">Parser</a>, NULL, TRUE);
<br><a name="758"></a>}
<br><a name="759"></a>
<br><a name="760"></a>/* handle a #ifdef directive */
<br><a name="761"></a>void LexHashIfdef(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>, <font color="blue">int </font>IfNot)
<br><a name="762"></a>{
<br><a name="763"></a>    /* get symbol to check */
<br><a name="764"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Ident<a href="interpreter_header.html#217">Value</a>;
<br><a name="765"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Saved<a href="interpreter_header.html#217">Value</a>;
<br><a name="766"></a>    <font color="blue">int </font>IsDefined;
<br><a name="767"></a>    enum Lex<a href="lex.html#242">Token</a> <a href="lex.html#242">Token</a> = LexGetRaw<a href="lex.html#242">Token</a>(<a href="lex.html#610">Parser</a>, &IdentValue, TRUE);
<br><a name="768"></a>    
<br><a name="769"></a>    <font color="red">if </font>(<a href="lex.html#242">Token</a> != <a href="lex.html#242">Token</a>Identifier)
<br><a name="770"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="lex.html#610">Parser</a>, "identifier expected");
<br><a name="771"></a>    
<br><a name="772"></a>    /* is the identifier defined? */
<br><a name="773"></a>    <a href="lex.html#766">IsDefined</a> = <a style="color:green" href="table.html#81">TableGet</a>(&Parser->pc->GlobalTable, <a href="lex.html#764">IdentValue</a>->Val->Identifier, &SavedValue, NULL, NULL, NULL);
<br><a name="774"></a>    <font color="red">if </font>(<a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel == <a href="lex.html#610">Parser</a>->HashIfLevel && ( (<a href="lex.html#766">IsDefined</a> && !<a href="lex.html#761">IfNot</a>) || (!<a href="lex.html#766">IsDefined</a> && <a href="lex.html#761">IfNot</a>)) )
<br><a name="775"></a>    {
<br><a name="776"></a>        /* #<font color="red">if </font>is active, evaluate to this new level */
<br><a name="777"></a>        <a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel++;
<br><a name="778"></a>    }
<br><a name="779"></a>    
<br><a name="780"></a>    <a href="lex.html#610">Parser</a>->HashIfLevel++;
<br><a name="781"></a>}
<br><a name="782"></a>
<br><a name="783"></a>/* handle a #<font color="red">if </font>directive */
<br><a name="784"></a>void LexHashIf(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>)
<br><a name="785"></a>{
<br><a name="786"></a>    /* get symbol to check */
<br><a name="787"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Ident<a href="interpreter_header.html#217">Value</a>;
<br><a name="788"></a>    <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> *Saved<a href="interpreter_header.html#217">Value</a> = NULL;
<br><a name="789"></a>    <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> MacroParser;
<br><a name="790"></a>    enum Lex<a href="lex.html#242">Token</a> <a href="lex.html#242">Token</a> = LexGetRaw<a href="lex.html#242">Token</a>(<a href="lex.html#610">Parser</a>, &IdentValue, TRUE);
<br><a name="791"></a>
<br><a name="792"></a>    <font color="red">if </font>(<a href="lex.html#242">Token</a> == <a href="lex.html#242">Token</a>Identifier)
<br><a name="793"></a>    {
<br><a name="794"></a>        /* look up a value from a macro definition */
<br><a name="795"></a>        <font color="red">if </font>(!TableGet(&Parser->pc->GlobalTable, <a href="lex.html#764">IdentValue</a>->Val->Identifier, &SavedValue, NULL, NULL, NULL))
<br><a name="796"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="lex.html#610">Parser</a>, "'%s' is undefined", <a href="lex.html#764">IdentValue</a>->Val->Identifier);
<br><a name="797"></a>        
<br><a name="798"></a>        <font color="red">if </font>(<a href="lex.html#765">SavedValue</a>->Typ->Base != TypeMacro)
<br><a name="799"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="lex.html#610">Parser</a>, "value expected");
<br><a name="800"></a>        
<br><a name="801"></a>        <a style="color:green" href="parse.html#429">ParserCopy</a>(&MacroParser, &SavedValue->Val->MacroDef.Body);
<br><a name="802"></a>        <a href="lex.html#242">Token</a> = LexGetRaw<a href="lex.html#242">Token</a>(&MacroParser, &IdentValue, TRUE);
<br><a name="803"></a>    }
<br><a name="804"></a>    
<br><a name="805"></a>    <font color="red">if </font>(<a href="lex.html#242">Token</a> != <a href="lex.html#242">Token</a>CharacterConstant && <a href="lex.html#242">Token</a> != <a href="lex.html#242">Token</a>IntegerConstant)
<br><a name="806"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="lex.html#610">Parser</a>, "value expected");
<br><a name="807"></a>    
<br><a name="808"></a>    /* is the identifier defined? */
<br><a name="809"></a>    <font color="red">if </font>(<a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel == <a href="lex.html#610">Parser</a>->HashIfLevel && <a href="lex.html#764">IdentValue</a>->Val->Character)
<br><a name="810"></a>    {
<br><a name="811"></a>        /* #<font color="red">if </font>is active, evaluate to this new level */
<br><a name="812"></a>        <a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel++;
<br><a name="813"></a>    }
<br><a name="814"></a>    
<br><a name="815"></a>    <a href="lex.html#610">Parser</a>->HashIfLevel++;
<br><a name="816"></a>}
<br><a name="817"></a>
<br><a name="818"></a>/* handle a #else directive */
<br><a name="819"></a>void LexHashElse(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>)
<br><a name="820"></a>{
<br><a name="821"></a>    <font color="red">if </font>(<a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel == <a href="lex.html#610">Parser</a>->HashIfLevel - 1)
<br><a name="822"></a>        <a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel++;     /* #<font color="red">if </font>was not active, make this next section active */
<br><a name="823"></a>        
<br><a name="824"></a>    else <font color="red">if </font>(<a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel == <a href="lex.html#610">Parser</a>->HashIfLevel)
<br><a name="825"></a>    {
<br><a name="826"></a>        /* #<font color="red">if </font>was active, now go inactive */
<br><a name="827"></a>        <font color="red">if </font>(<a href="lex.html#610">Parser</a>->HashIfLevel == 0)
<br><a name="828"></a>            <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="lex.html#610">Parser</a>, "#else without #if");
<br><a name="829"></a>            
<br><a name="830"></a>        <a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel--;
<br><a name="831"></a>    }
<br><a name="832"></a>}
<br><a name="833"></a>
<br><a name="834"></a>/* handle a #end<font color="red">if </font>directive */
<br><a name="835"></a>void LexHashEndif(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>)
<br><a name="836"></a>{
<br><a name="837"></a>    <font color="red">if </font>(<a href="lex.html#610">Parser</a>->HashIfLevel == 0)
<br><a name="838"></a>        <a style="color:green" href="platform.html#134">ProgramFail</a>(<a href="lex.html#610">Parser</a>, "#end<font color="red">if </font>without #if");
<br><a name="839"></a>
<br><a name="840"></a>    <a href="lex.html#610">Parser</a>->HashIfLevel--;
<br><a name="841"></a>    <font color="red">if </font>(<a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel > <a href="lex.html#610">Parser</a>->HashIfLevel)
<br><a name="842"></a>        <a href="lex.html#610">Parser</a>->HashIfEvaluateToLevel = <a href="lex.html#610">Parser</a>->HashIfLevel;
<br><a name="843"></a>}
<br><a name="844"></a>
<br><a name="845"></a>#<font color="red">if </font>0 /* useful <font color="red">for </font>debug */
<br><a name="846"></a>void LexPrint<a href="lex.html#242">Token</a>(enum Lex<a href="lex.html#242">Token</a> <a href="lex.html#242">Token</a>)
<br><a name="847"></a>{
<br><a name="848"></a>    char* TokenNames<font color="red">[</font><font color="red">]</font> = {
<br><a name="849"></a>        /* 0x00 */ "None", 
<br><a name="850"></a>        /* 0x01 */ "Comma",
<br><a name="851"></a>        /* 0x02 */ "Assign", "AddAssign", "SubtractAssign", "MultiplyAssign", "DivideAssign", "ModulusAssign",
<br><a name="852"></a>        /* 0x08 */ "ShiftLeftAssign", "ShiftRightAssign", "ArithmeticAndAssign", "ArithmeticOrAssign", "ArithmeticExorAssign",
<br><a name="853"></a>        /* 0x0d */ "QuestionMark", "Colon", 
<br><a name="854"></a>        /* 0x0f */ "LogicalOr", 
<br><a name="855"></a>        /* 0x10 */ "LogicalAnd", 
<br><a name="856"></a>        /* 0x11 */ "ArithmeticOr", 
<br><a name="857"></a>        /* 0x12 */ "ArithmeticExor", 
<br><a name="858"></a>        /* 0x13 */ "Ampersand", 
<br><a name="859"></a>        /* 0x14 */ "Equal", "NotEqual", 
<br><a name="860"></a>        /* 0x16 */ "LessThan", "GreaterThan", "LessEqual", "GreaterEqual",
<br><a name="861"></a>        /* 0x1a */ "ShiftLeft", "ShiftRight", 
<br><a name="862"></a>        /* 0x1c */ "Plus", "Minus", 
<br><a name="863"></a>        /* 0x1e */ "Asterisk", "Slash", "Modulus",
<br><a name="864"></a>        /* 0x21 */ "Increment", "Decrement", "UnaryNot", "UnaryExor", "Sizeof", "Cast",
<br><a name="865"></a>        /* 0x27 */ "LeftSquareBracket", "RightSquareBracket", "Dot", "Arrow", 
<br><a name="866"></a>        /* 0x2b */ "OpenBracket", "CloseBracket",
<br><a name="867"></a>        /* 0x2d */ "Identifier", "IntegerConstant", "FPConstant", "StringConstant", "CharacterConstant",
<br><a name="868"></a>        /* 0x32 */ "Semicolon", "Ellipsis",
<br><a name="869"></a>        /* 0x34 */ "LeftBrace", "RightBrace",
<br><a name="870"></a>        /* 0x36 */ "IntType", "CharType", "FloatType", "DoubleType", "VoidType", "EnumType",
<br><a name="871"></a>        /* 0x3c */ "LongType", "SignedType", "ShortType", "StaticType", "AutoType", "RegisterType", "ExternType", "StructType", "UnionType", "UnsignedType", "Typedef",
<br><a name="872"></a>        /* 0x46 */ "Continue", "Do", "Else", "For", "Goto", "If", "While", "Break", "Switch", "Case", "Default", "Return",
<br><a name="873"></a>        /* 0x52 */ "HashDefine", "HashInclude", "HashIf", "HashIfdef", "HashIfndef", "HashElse", "HashEndif",
<br><a name="874"></a>        /* 0x59 */ "New", "Delete",
<br><a name="875"></a>        /* 0x5b */ "OpenMacroBracket",
<br><a name="876"></a>        /* 0x5c */ "EOF", "EndOfLine", "EndOfFunction"
<br><a name="877"></a>    };
<br><a name="878"></a>    printf("{%s}", TokenNames<font color="red">[</font>Token<font color="red">]</font>);
<br><a name="879"></a>}
<br><a name="880"></a>#endif
<br><a name="881"></a>
<br><a name="882"></a>/* get the next token given a parser state, pre-processing as we go */
<br><a name="883"></a>enum LexToken LexGetToken(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>, <font color="blue">struct </font><a href="interpreter_header.html#217">Value</a> **<a href="interpreter_header.html#217">Value</a>, <font color="blue">int </font><a href="lex.html#626">IncPos</a>)
<br><a name="884"></a>{
<br><a name="885"></a>    enum Lex<a href="lex.html#242">Token</a> <a href="lex.html#242">Token</a>;
<br><a name="886"></a>    <font color="blue">int </font>TryNextToken;
<br><a name="887"></a>    
<br><a name="888"></a>    /* implements the pre-processor #<font color="red">if </font>commands */
<br><a name="889"></a>    do
<br><a name="890"></a>    {
<br><a name="891"></a>        <font color="blue">int </font>WasPreProcToken = TRUE;
<br><a name="892"></a>
<br><a name="893"></a>        <a href="lex.html#242">Token</a> = LexGetRaw<a href="lex.html#242">Token</a>(<a href="lex.html#610">Parser</a>, <a href="interpreter_header.html#217">Value</a>, <a href="lex.html#626">IncPos</a>);
<br><a name="894"></a>        switch (<a href="lex.html#242">Token</a>)
<br><a name="895"></a>        {
<br><a name="896"></a>            case TokenHashIfdef:    <a style="color:green" href="lex.html#754">LexHash<a href="lex.html#626">IncPos</a></a>(<a href="lex.html#610">Parser</a>, <a href="lex.html#626">IncPos</a>); <a style="color:green" href="lex.html#761">LexHashIfdef</a>(<a href="lex.html#610">Parser</a>, FALSE); break;
<br><a name="897"></a>            case TokenHashIfndef:   <a style="color:green" href="lex.html#754">LexHash<a href="lex.html#626">IncPos</a></a>(<a href="lex.html#610">Parser</a>, <a href="lex.html#626">IncPos</a>); <a style="color:green" href="lex.html#761">LexHashIfdef</a>(<a href="lex.html#610">Parser</a>, TRUE); break;
<br><a name="898"></a>            case TokenHashIf:       <a style="color:green" href="lex.html#754">LexHash<a href="lex.html#626">IncPos</a></a>(<a href="lex.html#610">Parser</a>, <a href="lex.html#626">IncPos</a>); <a style="color:green" href="lex.html#784">LexHashIf</a>(<a href="lex.html#610">Parser</a>); break;
<br><a name="899"></a>            case TokenHashElse:     <a style="color:green" href="lex.html#754">LexHash<a href="lex.html#626">IncPos</a></a>(<a href="lex.html#610">Parser</a>, <a href="lex.html#626">IncPos</a>); <a style="color:green" href="lex.html#819">LexHashElse</a>(<a href="lex.html#610">Parser</a>); break;
<br><a name="900"></a>            case TokenHashEndif:    <a style="color:green" href="lex.html#754">LexHash<a href="lex.html#626">IncPos</a></a>(<a href="lex.html#610">Parser</a>, <a href="lex.html#626">IncPos</a>); <a style="color:green" href="lex.html#835">LexHashEndif</a>(<a href="lex.html#610">Parser</a>); break;
<br><a name="901"></a>            default:                <a href="lex.html#891">WasPreProcToken</a> = FALSE; break;
<br><a name="902"></a>        }
<br><a name="903"></a>
<br><a name="904"></a>        /* <font color="red">if </font>we're going to reject this token, increment the token pointer to the next one */
<br><a name="905"></a>        <a href="lex.html#886">TryNext<a href="lex.html#242">Token</a></a> = (<a href="lex.html#610">Parser</a>-&gt;HashIfEvaluateToLevel &lt; <a href="lex.html#610">Parser</a>-&gt;HashIfLevel && <a href="lex.html#242">Token</a> != <a href="lex.html#242">Token</a>EOF) || WasPreProc<a href="lex.html#242">Token</a>;
<br><a name="906"></a>        <font color="red">if </font>(!IncPos && <a href="lex.html#886">TryNextToken</a>)
<br><a name="907"></a>            <a style="color:green" href="lex.html#626">LexGetRawToken</a>(<a href="lex.html#610">Parser</a>, NULL, TRUE);
<br><a name="908"></a>            
<br><a name="909"></a>    } <font color="red">while </font>(<a href="lex.html#886">TryNextToken</a>);
<br><a name="910"></a>    
<br><a name="911"></a>    <font color="red">return </font><a href="lex.html#242">Token</a>;
<br><a name="912"></a>}
<br><a name="913"></a>
<br><a name="914"></a>/* take a quick peek at the next token, skipping any pre-processing */
<br><a name="915"></a>enum LexToken LexRawPeekToken(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>)
<br><a name="916"></a>{
<br><a name="917"></a>    <font color="red">return </font>(enum LexToken)*(<font color="blue">unsigned </font><font color="blue">char </font>*)<a href="lex.html#610">Parser</a>->Pos;
<br><a name="918"></a>}
<br><a name="919"></a>
<br><a name="920"></a>/* find the end of the line */
<br><a name="921"></a>void LexToEndOfLine(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>)
<br><a name="922"></a>{
<br><a name="923"></a>    <font color="red">while </font>(TRUE)
<br><a name="924"></a>    {
<br><a name="925"></a>        enum Lex<a href="lex.html#242">Token</a> <a href="lex.html#242">Token</a> = (enum Lex<a href="lex.html#242">Token</a>)*(<font color="blue">unsigned </font><font color="blue">char </font>*)<a href="lex.html#610">Parser</a>->Pos;
<br><a name="926"></a>        <font color="red">if </font>(<a href="lex.html#242">Token</a> == <a href="lex.html#242">Token</a>EndOfLine || <a href="lex.html#242">Token</a> == <a href="lex.html#242">Token</a>EOF)
<br><a name="927"></a>            return;
<br><a name="928"></a>        else
<br><a name="929"></a>            <a style="color:green" href="lex.html#626">LexGetRawToken</a>(<a href="lex.html#610">Parser</a>, NULL, TRUE);
<br><a name="930"></a>    }
<br><a name="931"></a>}
<br><a name="932"></a>
<br><a name="933"></a>/* copy the tokens from StartParser to EndParser into new memory, removing TokenEOFs and terminate with a TokenEndOfFunction */
<br><a name="934"></a>void *LexCopyTokens(<font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *StartParser, <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *EndParser)
<br><a name="935"></a>{
<br><a name="936"></a>    <font color="blue">int </font>MemSize = 0;
<br><a name="937"></a>    <font color="blue">int </font>CopySize;
<br><a name="938"></a>    <font color="blue">unsigned </font><font color="blue">char </font>*Pos = (<font color="blue">unsigned </font><font color="blue">char </font>*)<a href="lex.html#934">StartParser</a>->Pos;
<br><a name="939"></a>    <font color="blue">unsigned </font><font color="blue">char </font>*NewTokens;
<br><a name="940"></a>    <font color="blue">unsigned </font><font color="blue">char </font>*NewTokenPos;
<br><a name="941"></a>    <font color="blue">struct </font><a href="interpreter_header.html#339">TokenLine</a> *ILine;
<br><a name="942"></a>    <a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a> = <a href="lex.html#934">StartParser</a>-><a href="lex.html#87">pc</a>;
<br><a name="943"></a>    
<br><a name="944"></a>    <font color="red">if </font>(<a href="lex.html#87">pc</a>->InteractiveHead == NULL)
<br><a name="945"></a>    { 
<br><a name="946"></a>        /* non-interactive mode - copy the tokens */
<br><a name="947"></a>        <a href="lex.html#936">MemSize</a> = <a href="lex.html#934">EndParser</a>->Pos - <a href="lex.html#934">StartParser</a>->Pos;
<br><a name="948"></a>        <a href="lex.html#939">NewTokens</a> = <a style="color:green" href="variable.html#68">VariableAlloc</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#934">StartParser</a>, <a href="lex.html#936">MemSize</a> + TOKEN_DATA_OFFSET, TRUE);
<br><a name="949"></a>        memcpy(<a href="lex.html#939">NewTokens</a>, (void *)<a href="lex.html#934">StartParser</a>->Pos, <a href="lex.html#936">MemSize</a>);
<br><a name="950"></a>    }
<br><a name="951"></a>    else
<br><a name="952"></a>    { 
<br><a name="953"></a>        /* we're in interactive mode - add up line by line */
<br><a name="954"></a>        <font color="red">for </font>(<a href="lex.html#87">pc</a>-&gt;InteractiveCurrentLine = <a href="lex.html#87">pc</a>-&gt;InteractiveHead; <a href="lex.html#87">pc</a>-&gt;InteractiveCurrentLine != NULL && (<a href="lex.html#938">Pos</a> &lt; &<a href="lex.html#87">pc</a>-&gt;InteractiveCurrentLine-&gt;Tokens<font color="red">[</font>0<font color="red">]</font> || <a href="lex.html#938">Pos</a> &gt;= &<a href="lex.html#87">pc</a>-&gt;InteractiveCurrentLine-&gt;Tokens<font color="red">[</font><a href="lex.html#87">pc</a>-&gt;InteractiveCurrentLine-&gt;NumBytes<font color="red">]</font>); <a href="lex.html#87">pc</a>-&gt;InteractiveCurrentLine = <a href="lex.html#87">pc</a>-&gt;InteractiveCurrentLine-&gt;Next)
<br><a name="955"></a>        {} /* find the line we just counted */
<br><a name="956"></a>        
<br><a name="957"></a>        <font color="red">if </font>(<a href="lex.html#934">EndParser</a>-&gt;Pos &gt;= <a href="lex.html#934">StartParser</a>-&gt;Pos && <a href="lex.html#934">EndParser</a>-&gt;Pos &lt; &pc-&gt;InteractiveCurrentLine-&gt;Tokens<font color="red">[</font>pc-&gt;InteractiveCurrentLine-&gt;NumBytes<font color="red">]</font>)
<br><a name="958"></a>        { 
<br><a name="959"></a>            /* all on a single line */
<br><a name="960"></a>            <a href="lex.html#936">MemSize</a> = <a href="lex.html#934">EndParser</a>->Pos - <a href="lex.html#934">StartParser</a>->Pos;
<br><a name="961"></a>            <a href="lex.html#939">NewTokens</a> = <a style="color:green" href="variable.html#68">VariableAlloc</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#934">StartParser</a>, <a href="lex.html#936">MemSize</a> + TOKEN_DATA_OFFSET, TRUE);
<br><a name="962"></a>            memcpy(<a href="lex.html#939">NewTokens</a>, (void *)<a href="lex.html#934">StartParser</a>->Pos, <a href="lex.html#936">MemSize</a>);
<br><a name="963"></a>        }
<br><a name="964"></a>        else
<br><a name="965"></a>        { 
<br><a name="966"></a>            /* it's spread across multiple lines */
<br><a name="967"></a>            <a href="lex.html#936">MemSize</a> = &pc->InteractiveCurrentLine->Tokens<font color="red">[</font>pc->InteractiveCurrentLine->NumBytes-TOKEN_DATA_OFFSET<font color="red">]</font> - <a href="lex.html#938">Pos</a>;
<br><a name="968"></a>
<br><a name="969"></a>            <font color="red">for </font>(<a href="lex.html#941">ILine</a> = <a href="lex.html#87">pc</a>-&gt;InteractiveCurrentLine-&gt;Next; <a href="lex.html#941">ILine</a> != NULL && (<a href="lex.html#934">EndParser</a>-&gt;Pos &lt; &<a href="lex.html#941">ILine</a>-&gt;Tokens<font color="red">[</font>0<font color="red">]</font> || <a href="lex.html#934">EndParser</a>-&gt;Pos &gt;= &<a href="lex.html#941">ILine</a>-&gt;Tokens<font color="red">[</font><a href="lex.html#941">ILine</a>-&gt;NumBytes<font color="red">]</font>); <a href="lex.html#941">ILine</a> = <a href="lex.html#941">ILine</a>-&gt;Next)
<br><a name="970"></a>                <a href="lex.html#936">MemSize</a> += <a href="lex.html#941">ILine</a>->NumBytes - TOKEN_DATA_OFFSET;
<br><a name="971"></a>            
<br><a name="972"></a>            assert(<a href="lex.html#941">ILine</a> != NULL);
<br><a name="973"></a>            <a href="lex.html#936">MemSize</a> += <a href="lex.html#934">EndParser</a>->Pos - &ILine->Tokens<font color="red">[</font>0<font color="red">]</font>;
<br><a name="974"></a>            <a href="lex.html#939">NewTokens</a> = <a style="color:green" href="variable.html#68">VariableAlloc</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#934">StartParser</a>, <a href="lex.html#936">MemSize</a> + TOKEN_DATA_OFFSET, TRUE);
<br><a name="975"></a>            
<br><a name="976"></a>            <a href="lex.html#937">CopySize</a> = &pc->InteractiveCurrentLine->Tokens<font color="red">[</font>pc->InteractiveCurrentLine->NumBytes-TOKEN_DATA_OFFSET<font color="red">]</font> - <a href="lex.html#938">Pos</a>;
<br><a name="977"></a>            memcpy(<a href="lex.html#939">NewTokens</a>, <a href="lex.html#938">Pos</a>, <a href="lex.html#937">CopySize</a>);
<br><a name="978"></a>            <a href="lex.html#940">NewTokenPos</a> = <a href="lex.html#939">NewTokens</a> + <a href="lex.html#937">CopySize</a>;
<br><a name="979"></a>            <font color="red">for </font>(<a href="lex.html#941">ILine</a> = <a href="lex.html#87">pc</a>-&gt;InteractiveCurrentLine-&gt;Next; <a href="lex.html#941">ILine</a> != NULL && (<a href="lex.html#934">EndParser</a>-&gt;Pos &lt; &<a href="lex.html#941">ILine</a>-&gt;Tokens<font color="red">[</font>0<font color="red">]</font> || <a href="lex.html#934">EndParser</a>-&gt;Pos &gt;= &<a href="lex.html#941">ILine</a>-&gt;Tokens<font color="red">[</font><a href="lex.html#941">ILine</a>-&gt;NumBytes<font color="red">]</font>); <a href="lex.html#941">ILine</a> = <a href="lex.html#941">ILine</a>-&gt;Next)
<br><a name="980"></a>            {
<br><a name="981"></a>                memcpy(<a href="lex.html#940">NewTokenPos</a>, &<a href="lex.html#941">ILine</a>->Tokens<font color="red">[</font>0<font color="red">]</font>, <a href="lex.html#941">ILine</a>->NumBytes - TOKEN_DATA_OFFSET);
<br><a name="982"></a>                <a href="lex.html#940">NewTokenPos</a> += <a href="lex.html#941">ILine</a>->NumBytes-TOKEN_DATA_OFFSET;
<br><a name="983"></a>            }
<br><a name="984"></a>            assert(<a href="lex.html#941">ILine</a> != NULL);
<br><a name="985"></a>            memcpy(<a href="lex.html#940">NewTokenPos</a>, &ILine->Tokens<font color="red">[</font>0<font color="red">]</font>, <a href="lex.html#934">EndParser</a>->Pos - &ILine->Tokens<font color="red">[</font>0<font color="red">]</font>);
<br><a name="986"></a>        }
<br><a name="987"></a>    }
<br><a name="988"></a>    
<br><a name="989"></a>    NewTokens<font color="red">[</font>MemSize<font color="red">]</font> = (<font color="blue">unsigned </font>char)TokenEndOfFunction;
<br><a name="990"></a>        
<br><a name="991"></a>    <font color="red">return </font><a href="lex.html#939">NewTokens</a>;
<br><a name="992"></a>}
<br><a name="993"></a>
<br><a name="994"></a>/* indicate that we've completed up to this po<font color="blue">int </font>in the interactive input and free expired tokens */
<br><a name="995"></a>void LexInteractiveClear(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>)
<br><a name="996"></a>{
<br><a name="997"></a>    <font color="red">while </font>(<a href="lex.html#87">pc</a>->InteractiveHead != NULL)
<br><a name="998"></a>    {
<br><a name="999"></a>        <font color="blue">struct </font><a href="interpreter_header.html#339">TokenLine</a> *<a href="lex.html#1018">NextLine</a> = <a href="lex.html#87">pc</a>->InteractiveHead->Next;
<br><a name="1000"></a>        
<br><a name="1001"></a>        <a style="color:green" href="heap.html#226">HeapFreeMem</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#87">pc</a>->InteractiveHead->Tokens);
<br><a name="1002"></a>        <a style="color:green" href="heap.html#226">HeapFreeMem</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#87">pc</a>->InteractiveHead);
<br><a name="1003"></a>        <a href="lex.html#87">pc</a>->InteractiveHead = <a href="lex.html#999">NextLine</a>;
<br><a name="1004"></a>    }
<br><a name="1005"></a>
<br><a name="1006"></a>    <font color="red">if </font>(<a href="lex.html#610">Parser</a> != NULL)
<br><a name="1007"></a>        <a href="lex.html#610">Parser</a>->Pos = NULL;
<br><a name="1008"></a>        
<br><a name="1009"></a>    <a href="lex.html#87">pc</a>->InteractiveTail = NULL;
<br><a name="1010"></a>}
<br><a name="1011"></a>
<br><a name="1012"></a>/* indicate that we've completed up to this po<font color="blue">int </font>in the interactive input and free expired tokens */
<br><a name="1013"></a>void LexInteractiveCompleted(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>, <font color="blue">struct </font><a href="interpreter_header.html#116">ParseState</a> *<a href="lex.html#610">Parser</a>)
<br><a name="1014"></a>{
<br><a name="1015"></a>    <font color="red">while </font>(<a href="lex.html#87">pc</a>-&gt;InteractiveHead != NULL && !(<a href="lex.html#610">Parser</a>-&gt;Pos &gt;= &<a href="lex.html#87">pc</a>-&gt;InteractiveHead-&gt;Tokens<font color="red">[</font>0<font color="red">]</font> && <a href="lex.html#610">Parser</a>-&gt;Pos &lt; &<a href="lex.html#87">pc</a>-&gt;InteractiveHead-&gt;Tokens<font color="red">[</font><a href="lex.html#87">pc</a>-&gt;InteractiveHead-&gt;NumBytes<font color="red">]</font>))
<br><a name="1016"></a>    { 
<br><a name="1017"></a>        /* this token line is no longer needed - free it */
<br><a name="1018"></a>        <font color="blue">struct </font><a href="interpreter_header.html#339">TokenLine</a> *<a href="lex.html#999">NextLine</a> = <a href="lex.html#87">pc</a>->InteractiveHead->Next;
<br><a name="1019"></a>        
<br><a name="1020"></a>        <a style="color:green" href="heap.html#226">HeapFreeMem</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#87">pc</a>->InteractiveHead->Tokens);
<br><a name="1021"></a>        <a style="color:green" href="heap.html#226">HeapFreeMem</a>(<a href="lex.html#87">pc</a>, <a href="lex.html#87">pc</a>->InteractiveHead);
<br><a name="1022"></a>        <a href="lex.html#87">pc</a>->InteractiveHead = <a href="lex.html#999">NextLine</a>;
<br><a name="1023"></a>        
<br><a name="1024"></a>        <font color="red">if </font>(<a href="lex.html#87">pc</a>->InteractiveHead == NULL)
<br><a name="1025"></a>        { 
<br><a name="1026"></a>            /* we've emptied the list */
<br><a name="1027"></a>            <a href="lex.html#610">Parser</a>->Pos = NULL;
<br><a name="1028"></a>            <a href="lex.html#87">pc</a>->InteractiveTail = NULL;
<br><a name="1029"></a>        }
<br><a name="1030"></a>    }
<br><a name="1031"></a>}
<br><a name="1032"></a>
<br><a name="1033"></a>/* the next time we prompt, make it the full statement prompt */
<br><a name="1034"></a>void LexInteractiveStatementPrompt(<a href="interpreter_header.html#61">Picoc</a> *<a href="lex.html#87">pc</a>)
<br><a name="1035"></a>{
<br><a name="1036"></a>    <a href="lex.html#87">pc</a>->LexUseStatementPrompt = TRUE;
<br><a name="1037"></a>}
<br><a name="1038"></a></html>